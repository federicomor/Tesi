unit_specific_alpha = FALSE,
time_specific_alpha = TRUE,
update_alpha = TRUE,
include_eta1 = FALSE,
include_phi1 = FALSE,
model_priors = c(1,1,2,4),
alpha_priors = rbind(c(1,1)),
spatial_cohesion = 1,
# sp_params = NA,
# covariate_similarity = NA,
mh = c(0.1,0.1,0.7, 0.1, 0.1),
draws = 1000,
burnin = 100,
thin = 10,
verbose = TRUE
)
TestModule1 <- juliaImport(juliaCall("include", testModule))
TestModule1$MCMC_fit(
Y=Y,
sp_coords = sp_coords,
X_covariates = X_covariates,
M_dp = 1,
# initial_partition = NA,
starting_alpha = 0.5,
unit_specific_alpha = FALSE,
time_specific_alpha = TRUE,
update_alpha = TRUE,
include_eta1 = FALSE,
include_phi1 = FALSE,
model_priors = c(1,1,2,4),
alpha_priors = rbind(c(1,1)),
spatial_cohesion = 1,
# sp_params = NA,
# covariate_similarity = NA,
mh = c(0.1,0.1,0.7, 0.1, 0.1),
draws = 1000,
burnin = 100,
thin = 10,
verbose = TRUE
)
TestModule1 <- juliaImport(juliaCall("include", testModule))
TestModule1$MCMC_fit(
Y=Y,
sp_coords = sp_coords,
X_covariates = X_covariates,
M_dp = 1,
# initial_partition = NA,
starting_alpha = 0.5,
unit_specific_alpha = FALSE,
time_specific_alpha = TRUE,
update_alpha = TRUE,
include_eta1 = FALSE,
include_phi1 = FALSE,
model_priors = c(1,1,2,4),
alpha_priors = rbind(c(1,1)),
spatial_cohesion = 1,
# sp_params = NA,
# covariate_similarity = NA,
mh = c(0.1,0.1,0.7, 0.1, 0.1),
draws = 1000,
burnin = 100,
thin = 10,
verbose = TRUE
)
TestModule1 <- juliaImport(juliaCall("include", testModule))
TestModule1$MCMC_fit(
Y=Y,
sp_coords = sp_coords,
X_covariates = X_covariates,
M_dp = 1,
# initial_partition = NA,
starting_alpha = 0.5,
unit_specific_alpha = FALSE,
time_specific_alpha = TRUE,
update_alpha = TRUE,
include_eta1 = FALSE,
include_phi1 = FALSE,
model_priors = c(1,1,2,4),
alpha_priors = rbind(c(1,1)),
spatial_cohesion = 1,
# sp_params = NA,
# covariate_similarity = NA,
mh = c(0.1,0.1,0.7, 0.1, 0.1),
draws = 1000,
burnin = 100,
thin = 10,
verbose = TRUE
)
TestModule1 <- juliaImport(juliaCall("include", testModule))
TestModule1$MCMC_fit(
Y=Y,
sp_coords = sp_coords,
X_covariates = X_covariates,
M_dp = 1,
# initial_partition = NA,
starting_alpha = 0.5,
unit_specific_alpha = FALSE,
time_specific_alpha = TRUE,
update_alpha = TRUE,
include_eta1 = FALSE,
include_phi1 = FALSE,
model_priors = c(1,1,2,4),
alpha_priors = rbind(c(1,1)),
spatial_cohesion = 1,
# sp_params = NA,
# covariate_similarity = NA,
mh = c(0.1,0.1,0.7, 0.1, 0.1),
draws = 1000,
burnin = 100,
thin = 10,
verbose = TRUE
)
TestModule1 <- juliaImport(juliaCall("include", testModule))
TestModule1$MCMC_fit(
Y=Y,
sp_coords = sp_coords,
X_covariates = X_covariates,
M_dp = 1,
# initial_partition = NA,
starting_alpha = 0.5,
unit_specific_alpha = FALSE,
time_specific_alpha = TRUE,
update_alpha = TRUE,
include_eta1 = FALSE,
include_phi1 = FALSE,
model_priors = c(1,1,2,4),
alpha_priors = rbind(c(1,1)),
spatial_cohesion = 1,
# sp_params = NA,
# covariate_similarity = NA,
mh = c(0.1,0.1,0.7, 0.1, 0.1),
draws = 1000,
burnin = 100,
thin = 10,
verbose = TRUE
)
TestModule1 <- juliaImport(juliaCall("include", testModule))
TestModule1$MCMC_fit(
Y=Y,
sp_coords = sp_coords,
X_covariates = X_covariates,
M_dp = 1,
# initial_partition = NA,
starting_alpha = 0.5,
unit_specific_alpha = FALSE,
time_specific_alpha = TRUE,
update_alpha = TRUE,
include_eta1 = FALSE,
include_phi1 = FALSE,
model_priors = c(1,1,2,4),
alpha_priors = rbind(c(1,1)),
spatial_cohesion = 1,
# sp_params = NA,
# covariate_similarity = NA,
mh = c(0.1,0.1,0.7, 0.1, 0.1),
draws = 1000,
burnin = 100,
thin = 10,
verbose = TRUE
)
TestModule1 <- juliaImport(juliaCall("include", testModule))
TestModule1$MCMC_fit(
Y=Y,
sp_coords = sp_coords,
X_covariates = X_covariates,
M_dp = 1,
# initial_partition = NA,
starting_alpha = 0.5,
unit_specific_alpha = FALSE,
time_specific_alpha = TRUE,
update_alpha = TRUE,
include_eta1 = FALSE,
include_phi1 = FALSE,
model_priors = c(1,1,2,4),
alpha_priors = rbind(c(1,1)),
spatial_cohesion = 1,
# sp_params = NA,
# covariate_similarity = NA,
mh = c(0.1,0.1,0.7, 0.1, 0.1),
draws = 1000,
burnin = 100,
thin = 10,
verbose = TRUE
)
TestModule1 <- juliaImport(juliaCall("include", testModule))
TestModule1$MCMC_fit(
Y=Y,
sp_coords = sp_coords,
X_covariates = X_covariates,
M_dp = 1,
# initial_partition = NA,
starting_alpha = 0.5,
unit_specific_alpha = FALSE,
time_specific_alpha = TRUE,
update_alpha = TRUE,
include_eta1 = FALSE,
include_phi1 = FALSE,
model_priors = c(1,1,2,4),
alpha_priors = rbind(c(1,1)),
spatial_cohesion = 1,
# sp_params = NA,
# covariate_similarity = NA,
mh = c(0.1,0.1,0.7, 0.1, 0.1),
draws = 1000,
burnin = 100,
thin = 10,
verbose = TRUE
)
rnorm(0,3)
rnorm(1,0,3)
devtools::load_all("../../drpm/")
sites = data.frame(
longitude = unique(df_weekly$Longitude),
latitude = unique(df_weekly$Latitude))
# library(drpm)
library(salso)
# preparation
source("include.R") # for having df_agri
source("plot functions/plotter.R")
sites = data.frame(
longitude = unique(df_weekly$Longitude),
latitude = unique(df_weekly$Latitude))
source("include_clusters_functions.R")
stations = unique(df_wsc$IDStations)
y=data.frame()
for(st in stations){
y_we_pm10=cbind(as.data.frame(st),t(df_wsc[which(df_wsc$IDStations==st),"AQ_pm10"]))
y=rbind(y,y_we_pm10)
}
rownames(y) = NULL
colnames(y)<- c("id",paste0("w", 1:53))
df_wsc
y
yred=y[,2:54]
cols = colora(size(yred)[1],56,0)
for(i in 1:size(yred)[1]){
if(i==1){
plot(1:size(yred)[2],yred[i,],col=cols[i],ylim=extrema(yred),type='l',xlab='weeks',ylab='pm10')
}
else{
lines(1:size(yred)[2],yred[i,],col=cols[i])
}
}
time_span = 1:6 # low time span for quick testing, real one will be 1:53
nsubjects = 1:105
### authors suggested to/did scale the spatial locations and also centered the observations
y_fit = y[nsubjects,1+time_span]
y_fit
### and for the scaling of spatial locations
std_sites = data.frame(
longitude = unique(df_wsc$Longitude),
latitude = unique(df_wsc$Latitude))[nsubjects,]
plot(sites)
plot(std_sites)
# niter=3000; nburn=1000; nthin=2
niter=5; nburn=1; nthin=1
# niter=60000; nburn=20000; nthin=40 # original
# niter=100000; nburn=60000; nthin=40 # new one for more data
nout <- (niter-nburn)/nthin
cat(nout,"valid iterations\n")
# seed_choice = round(runif(1,0,1000))
# set.seed(seed_choice)
cat(paste0("seed ",seed_choice,"\n==========================\n",date(),"\n\n"))
seed_choice = round(runif(1,0,1000))
set.seed(seed_choice)
cat(paste0("seed ",seed_choice,"\n==========================\n",date(),"\n\n"))
tempo_inizio <- Sys.time()
drpm1 <- drpm_fit(y=y_fit,
s_coords = std_sites,
M=1,
initial_partition = NULL,
starting_alpha = 0.5,
unit_specific_alpha = FALSE,
# time_specific_alpha = TRUE, # meaning a bit ambiguos
# Ok after experimenting it means that:
# - if true we let alpha be a param that changes over time.
#	At time 1 we have a chain with some behaviour,
#	at time 2 another chain with another behaviour, ecc
# - if false we instead fix alpha, ie all chains of all times
#	will be the same, as they refer to the same parameter estimation
# The authors in their tests set it to false, ie the fixed alpha
alpha_0=FALSE, # modello temporale, questa deve sempre essere falsa
# parameters from the drpm models comparison:
# case E0P1A1
eta1_0=FALSE,
phi1_0=TRUE,
time_specific_alpha = TRUE,
# modelPriors=c(0,100^2,1,1,1,1), # original default one
modelPriors=c(0,100,10,5,5,2,2,1), # author suggestion/used one
# così con 1,1 è una uniforme
alphaPriors=rbind(c(1,1)), # if time_specific_alpha == TRUE
# alphaPriors=matrix(rep(c(1,1),105),105,2), # if unit_specific_alpha == TRUE
# alphaPriors=matrix(rep(c(1,1),105),105,2), # if both the above are TRUE
simpleModel = 0,
theta_tau2 = c(0, 2), # only used if simpleModel=1
# SpatialCohesion=3, # auxiliary similarity
SpatialCohesion=4, # double dipper similarity, default one
# cParms=c(0, 1, 2, 1), # default one
cParms=c(0, 1, 5, 1), # author suggestion/used one (with 5)
# mh=c(0.5,1,0.1, 0.1, 0.1), # default one
mh=c(0.1,0.1,0.7, 0.1, 0.1), # with a bit of author suggestion/used one
verbose=TRUE,
# draws=1100,burn=100,thin=1) # quick one
# draws=31000,burn=1000,thin=1) # for trace plot analysis
# draws=8000,burn=3000,thin=5) # a bit more serious seriou one
# draws=10000,burn=2000,thin=8) # more serious one
draws=niter,burn=nburn,thin=nthin) # adaptable one
devtools::load_all("../../drpm/")
# Load necessary library
library(ggplot2)
# Create the sites data frame
sites <- data.frame(
longitude = c(0, 1, 2, 0, 1, 2, 0, 1, 2) / 2,# + runif(9,-0.2,0),
latitude = c(2,2,2,1, 1, 1,0,0,0) / 2        #+ runif(9,-0.2,0)
)
sites
sites = (sites-sapply(sites,mean)) / sapply(sites,sd)
sites
YM = 5
# Generate yt data frame with three clusters for t1
yt = data.frame(
t1 = c(rnorm(1,YM),rnorm(1),rnorm(1),rnorm(1,YM),rnorm(2,1),rnorm(1,YM),rnorm(2,-YM)),
t2 = c(rnorm(2,YM),rnorm(1),rnorm(1,YM),rnorm(1),rnorm(1,-YM),rnorm(1,YM),rnorm(2,-YM)),
t3 = c(rnorm(2,YM),rnorm(1),rnorm(2,YM),rnorm(1,-YM),rnorm(1,YM),rnorm(2,-YM))
)
yt
clusters_t1 <- cut(yt$t1, breaks = c(-Inf, -5, 5, Inf), labels = c("cl1", "cl2", "cl3"))
clusters_t2 <- cut(yt$t2, breaks = c(-Inf, -5, 5, Inf), labels = c("cl1", "cl2", "cl3"))
clusters_t3 <- cut(yt$t3, breaks = c(-Inf, -5, 5, Inf), labels = c("cl1", "cl2", "cl 3"))
boxplot(yt)
cat(sapply(yt,mean),"\n")
cat(sapply(yt,sd),"\n")
# yt = (yt-sapply(yt,mean)) / sapply(yt,sd)
# yt
# boxplot(yt)
plot(sites,col=clusters_t1,pch=19,cex=1.4,main="t=1 - real data")
plot(sites,col=clusters_t2,pch=19,cex=1.4,main="t=2 - real data")
plot(sites,col=clusters_t3,pch=19,cex=1.4,main="t=3 - real data")
yred=yt
cols = colora(size(yred)[1],56,0)
for(i in 1:size(yred)[1]){
if(i==1){
plot(1:size(yred)[2],yred[i,],col=cols[i],ylim=extrema(yred),type='l',xlab='weeks',ylab='pm10')
}
else{
lines(1:size(yred)[2],yred[i,],col=cols[i])
}
}
niter=3; nburn=1; nthin=1
nout <- (niter-nburn)/nthin
cat(nout,"valid iterations\n")
seed_choice = round(runif(1,0,1000))
set.seed(seed_choice)
cat(paste0("seed ",seed_choice,"\n==========================\n",date(),"\n\n"))
tempo_inizio <- Sys.time()
drpm1 <- drpm_fit(y=yt,
s_coords = sites,
M=1,
initial_partition = NULL,
starting_alpha = 0.5,
unit_specific_alpha = FALSE,
# time_specific_alpha = TRUE, # meaning a bit ambiguos
# Ok after experimenting it means that:
# - if true we let alpha be a param that changes over time.
#	At time 1 we have a chain with some behaviour,
#	at time 2 another chain with another behaviour, ecc
# - if false we instead fix alpha, ie all chains of all times
#	will be the same, as they refer to the same parameter estimation
# The authors in their tests set it to false, ie the fixed alpha
alpha_0=FALSE, # modello temporale, questa deve sempre essere falsa
# parameters from the drpm models comparison:
# case E0P1A1
eta1_0=FALSE,
phi1_0=TRUE,
time_specific_alpha = TRUE,
# modelPriors=c(0,100^2,1,1,1,1), # original default one
modelPriors=c(0,100,10,5,5,2,2,1), # author suggestion/used one
# così con 1,1 è una uniforme
alphaPriors=rbind(c(1,1)), # if time_specific_alpha == TRUE
# alphaPriors=matrix(rep(c(1,1),105),105,2), # if unit_specific_alpha == TRUE
# alphaPriors=matrix(rep(c(1,1),105),105,2), # if both the above are TRUE
simpleModel = 0,
theta_tau2 = c(0, 2), # only used if simpleModel=1
# SpatialCohesion=3, # auxiliary similarity
SpatialCohesion=4, # double dipper similarity, default one
# cParms=c(0, 1, 2, 1), # default one
cParms=c(0, 1, 5, 1), # author suggestion/used one (with 5)
# mh=c(0.5,1,0.1, 0.1, 0.1), # default one
mh=c(0.1,0.1,0.7, 0.1, 0.1), # with a bit of author suggestion/used one
verbose=TRUE,
# draws=1100,burn=100,thin=1) # quick one
# draws=31000,burn=1000,thin=1) # for trace plot analysis
# draws=8000,burn=3000,thin=5) # a bit more serious seriou one
# draws=10000,burn=2000,thin=8) # more serious one
draws=niter,burn=nburn,thin=nthin) # adaptable one
tempo_fine <- Sys.time()
differenza_tempo <- tempo_fine - tempo_inizio
cat(crayon::cyan("Fit took:\n"))
print(round(differenza_tempo,digits = 4))
cat(crayon::blue("That was for fitting",max(time_span),"time steps.\nSo for fitting all 53 weeks the expected time with these parameters will be:\n"))
print(round(differenza_tempo/max(time_span)*53,digits=4))
cat(crayon::red("\nLPML =",drpm1$lpml, "\nWAIC =",drpm1$waic))
devtools::load_all("../../drpm/")
niter=3; nburn=1; nthin=1
nout <- (niter-nburn)/nthin
cat(nout,"valid iterations\n")
seed_choice = round(runif(1,0,1000))
set.seed(seed_choice)
cat(paste0("seed ",seed_choice,"\n==========================\n",date(),"\n\n"))
tempo_inizio <- Sys.time()
drpm1 <- drpm_fit(y=yt,
s_coords = sites,
M=1,
initial_partition = NULL,
starting_alpha = 0.5,
unit_specific_alpha = FALSE,
# time_specific_alpha = TRUE, # meaning a bit ambiguos
# Ok after experimenting it means that:
# - if true we let alpha be a param that changes over time.
#	At time 1 we have a chain with some behaviour,
#	at time 2 another chain with another behaviour, ecc
# - if false we instead fix alpha, ie all chains of all times
#	will be the same, as they refer to the same parameter estimation
# The authors in their tests set it to false, ie the fixed alpha
alpha_0=FALSE, # modello temporale, questa deve sempre essere falsa
# parameters from the drpm models comparison:
# case E0P1A1
eta1_0=FALSE,
phi1_0=TRUE,
time_specific_alpha = TRUE,
# modelPriors=c(0,100^2,1,1,1,1), # original default one
modelPriors=c(0,100,10,5,5,2,2,1), # author suggestion/used one
# così con 1,1 è una uniforme
alphaPriors=rbind(c(1,1)), # if time_specific_alpha == TRUE
# alphaPriors=matrix(rep(c(1,1),105),105,2), # if unit_specific_alpha == TRUE
# alphaPriors=matrix(rep(c(1,1),105),105,2), # if both the above are TRUE
simpleModel = 0,
theta_tau2 = c(0, 2), # only used if simpleModel=1
# SpatialCohesion=3, # auxiliary similarity
SpatialCohesion=4, # double dipper similarity, default one
# cParms=c(0, 1, 2, 1), # default one
cParms=c(0, 1, 5, 1), # author suggestion/used one (with 5)
# mh=c(0.5,1,0.1, 0.1, 0.1), # default one
mh=c(0.1,0.1,0.7, 0.1, 0.1), # with a bit of author suggestion/used one
verbose=TRUE,
# draws=1100,burn=100,thin=1) # quick one
# draws=31000,burn=1000,thin=1) # for trace plot analysis
# draws=8000,burn=3000,thin=5) # a bit more serious seriou one
# draws=10000,burn=2000,thin=8) # more serious one
draws=niter,burn=nburn,thin=nthin) # adaptable one
tempo_fine <- Sys.time()
differenza_tempo <- tempo_fine - tempo_inizio
cat(crayon::cyan("Fit took:\n"))
print(round(differenza_tempo,digits = 4))
cat(crayon::blue("That was for fitting",max(time_span),"time steps.\nSo for fitting all 53 weeks the expected time with these parameters will be:\n"))
print(round(differenza_tempo/max(time_span)*53,digits=4))
cat(crayon::red("\nLPML =",drpm1$lpml, "\nWAIC =",drpm1$waic))
cat(paste0("seed ",seed_choice,"\n==========================\n",date(),"\n\n"))
tempo_inizio <- Sys.time()
drpm1 <- drpm_fit(y=yt,
s_coords = sites,
M=1,
initial_partition = NULL,
starting_alpha = 0.5,
unit_specific_alpha = FALSE,
# time_specific_alpha = TRUE, # meaning a bit ambiguos
# Ok after experimenting it means that:
# - if true we let alpha be a param that changes over time.
#	At time 1 we have a chain with some behaviour,
#	at time 2 another chain with another behaviour, ecc
# - if false we instead fix alpha, ie all chains of all times
#	will be the same, as they refer to the same parameter estimation
# The authors in their tests set it to false, ie the fixed alpha
alpha_0=FALSE, # modello temporale, questa deve sempre essere falsa
# parameters from the drpm models comparison:
# case E0P1A1
eta1_0=FALSE,
phi1_0=TRUE,
time_specific_alpha = TRUE,
# modelPriors=c(0,100^2,1,1,1,1), # original default one
modelPriors=c(0,100,10,5,5,2,2,1), # author suggestion/used one
# così con 1,1 è una uniforme
alphaPriors=rbind(c(1,1)), # if time_specific_alpha == TRUE
# alphaPriors=matrix(rep(c(1,1),105),105,2), # if unit_specific_alpha == TRUE
# alphaPriors=matrix(rep(c(1,1),105),105,2), # if both the above are TRUE
simpleModel = 0,
theta_tau2 = c(0, 2), # only used if simpleModel=1
# SpatialCohesion=3, # auxiliary similarity
SpatialCohesion=4, # double dipper similarity, default one
# cParms=c(0, 1, 2, 1), # default one
cParms=c(0, 1, 5, 1), # author suggestion/used one (with 5)
# mh=c(0.5,1,0.1, 0.1, 0.1), # default one
mh=c(0.1,0.1,0.7, 0.1, 0.1), # with a bit of author suggestion/used one
verbose=TRUE,
# draws=1100,burn=100,thin=1) # quick one
# draws=31000,burn=1000,thin=1) # for trace plot analysis
# draws=8000,burn=3000,thin=5) # a bit more serious seriou one
# draws=10000,burn=2000,thin=8) # more serious one
draws=niter,burn=nburn,thin=nthin) # adaptable one
tempo_fine <- Sys.time()
differenza_tempo <- tempo_fine - tempo_inizio
cat(crayon::cyan("Fit took:\n"))
print(round(differenza_tempo,digits = 4))
cat(crayon::blue("That was for fitting",max(time_span),"time steps.\nSo for fitting all 53 weeks the expected time with these parameters will be:\n"))
print(round(differenza_tempo/max(time_span)*53,digits=4))
cat(crayon::red("\nLPML =",drpm1$lpml, "\nWAIC =",drpm1$waic))
TestModule1 <- juliaImport(juliaCall("include", testModule))
TestModule1 <- juliaImport(juliaCall("include", testModule))
library(JuliaConnectoR)
juliaSetupOk()
# setup project
juliaEval("using Pkg; Pkg.status()")
