---
title: "R Notebook"
output: html_document
---

```{r}
source("../src/include.R")
# colora and other helper functions
```


# JuliaConnectoR (better)
```{r}
library(JuliaConnectoR)
juliaSetupOk()

# setup project
juliaEval("using Pkg; Pkg.status()")
juliaEval("Pkg.activate(\"../../JDRPM\")")
juliaEval("using Pkg; Pkg.status()")

# examples
# which we dont need if we activate the project
# juliaEval("using Random; Random.seed!(5);")
# juliaEval("using Statistics")
# juliaEval("using Logging")
# juliaEval("using Distributions")
# juliaEval("rand(Beta(10,10))")
```

# data
```{r}
# Importing a module without a package
getwd()
testModule = normalizePath("../../JDRPM/src/JDRPM.jl")
cat(testModule)
# take a look at the file
# writeLines(readLines(testModule))
# load in Julia
# juliaCall("include", testModule)
# import in R via relative module path
# TestModule1 <- juliaImport(".JDRPM")

# Importing a local module is also possible in one line,
# by directly using the module object returned by "include".
TestModule1 <- juliaImport(juliaCall("include", testModule))
x = TestModule1$my_example(300)
```


```{r}
n = 5
bigT = 3
p = 2
# nxbigT matrix of normally distributed random numbers
Y <- matrix(rnorm(n * bigT), nrow = n, ncol = bigT)
# nx3xbigT array of normally distributed random numbers
X_covariates <- array(rnorm(n * p * bigT), dim = c(n, p, bigT))
# nx2 matrix of uniformly distributed random numbers between 0 and 1
sp_coords <- matrix(runif(n * 2), nrow = n, ncol = 2)
```


## fit
```{r}
seed_choice = round(runif(1,0,1000))
set.seed(seed_choice)
cat("seed",seed_choice)

# params
m0_phi0 = 0
s20_phi0 = 1
A_ub_sigma = 5
a_sigma = 5; b_sigma=2
A_ub_tau = 5
a_tau = 5; b_tau=2
A_ub_lambda = 5
a_lambda = 5; b_lambda=2
eta1_scale = 0.9

sig_mh_sig2 = 0.2
sig_mh_tau2 = 0.2
sig_mh_lambda2 = 0.2
sig_mh_eta1 = 0.2
sig_mh_phi1 = 0.2

mu0 = 0 
k0 = 1
v0 = 5
L0 = 1

a_alpha = 2; b_alpha = 2
```


```{r}
TestModule1 <- juliaImport(juliaCall("include", testModule))
out = module_JDRPM$MCMC_fit(
	Y=as.matrix(Y),              
	sp_coords = as.matrix(sp_coords),
	M_dp = 1,                     
	initial_partition = NA,
	Xlk_covariates = NA,
	Xcl_covariates = NA,
	
	starting_alpha = 0.5,         
	unit_specific_alpha = FALSE,       
	time_specific_alpha = TRUE,       
	update_alpha = TRUE,             
	
	include_eta1 = TRUE,                    
	include_phi1 = TRUE,
	update_eta1 = FALSE,                    
	update_phi1 = FALSE,
	
	sig2h_priors = c(a_sigma,b_sigma),
	eta1_priors = c(eta1_scale,sig_mh_eta1^2),
	beta_priors = c(rep(1,p),2),
	tau2_priors = c(a_tau,b_tau),
	phi0_priors = c(m0_phi0,s20_phi0),
	phi1_priors = sig_mh_phi1^2,
	lambda2_priors = c(a_lambda,b_lambda),
	alpha_priors = c(a_alpha,b_alpha),  
	
	spatial_cohesion_idx = 4,
	sp_params = list(c(1,2),1,2,matrix(c(1,2,2,4),nrow=2)),
	
	# covariate_similarity_idx = NA,  
	draws = 400,                    
	burnin = 200,                   
	thin = 10,                     
	logging = FALSE,
	seed = seed_choice
)
```


## explore output
```{r}
rout = juliaGet(out)
names(rout)  = c("Si_out",
				 "gamma_out",
				 "alpha_out", 
				 "sigma2h_out", 
				 "muh_out", 
				 "eta1_iter",
				 "beta_out",
				 "theta_out", 
				 "tau2_out", 
				 "phi0_out", 
				 "phi1_out",
				 "lambda2_out",
				 "fitted",
				 "llike",
				 "lpml",
				 "waic")

# reshape some stuff to uniform it to drpm output
rout$Si_out       = aperm(rout$Si_out,       c(2, 1, 3))
rout$gamma_out    = aperm(rout$gamma_out,    c(2, 1, 3))
rout$sigma2h_out  = aperm(rout$sigma2h_out,  c(2, 1, 3))
rout$muh_out      = aperm(rout$muh_out,      c(2, 1, 3))
# rout$fitted       = aperm(rout$fitted,       c(2, 1, 3))
# rout$llike        = aperm(rout$llike,        c(2, 1, 3))
rout$alpha_out    = aperm(rout$alpha_out,    c(2, 1))
rout$theta_out    = aperm(rout$theta_out,    c(2, 1))
rout$tau2_out     = aperm(rout$tau2_out,     c(2, 1))
rout$eta1_iter    = aperm(rout$eta1_iter,    c(2, 1))
rout$phi0_out     = matrix(rout$phi0_out,    ncol = 1)
rout$phi1_out     = matrix(rout$phi1_out,    ncol = 1)
rout$lambda2_out  = matrix(rout$lambda2_out, ncol = 1)
```




```{r}
cat("Si_out       size = ",size(rout$Si_out),"\n")
cat("gamma_out    size = ",size(rout$gamma_out),"\n")
cat("sigma2h_out  size = ",size(rout$sigma2h_out),"\n")
cat("muh_out      size = ",size(rout$muh_out),"\n")
cat("alpha_out    size = ",size(rout$alpha_out),"\n")
cat("theta_out    size = ",size(rout$theta_out),"\n")
cat("tau2_out     size = ",size(rout$tau2_out),"\n")
cat("eta1_iter    size = ",size(rout$eta1_iter),"\n")
cat("phi0_out     size = ",size(rout$phi0_out),"\n")
cat("phi1_out     size = ",size(rout$phi1_out),"\n")
cat("lambda2_out  size = ",size(rout$lambda2_out),"\n")
cat("beta_out     size = ",size(rout$beta_out),"\n")
cat("fitted       size = ",size(rout$fitted),"\n")
cat("llike        size = ",size(rout$llike),"\n")

cat("lpml = ",rout$lpml,"\n")
cat("waic = ",rout$waic,"\n")
```

```{r}
Y
rout$fitted[,,8]

plot(Y[1,],col="red",type="l",)
lines(rout$fitted[1,,8],col="blue")
```

```{r}
# Define the matrices
matrix1 <- matrix(c(
  0.321124835, -0.58572011, -1.1622874,
  0.004176844, 1.12721652, -1.2906668,
  -0.706780298, -0.03721424, 0.2726288,
  -0.960866004, 2.98684939, -0.6814143,
  0.441265274, 0.40017530, -0.1315125
), nrow = 5, byrow = TRUE)

matrix2 <- matrix(c(
  -0.1980815, 0.266524520, -0.48613111,
  -0.1980815, -0.004148949, -1.11968817,
  -0.1980815, -0.441191320, -0.02323013,
  -0.1980815, 0.609221027, -1.89376193,
  -0.1980815, -0.268351657, -0.24336314
), nrow = 5, byrow = TRUE)

# Flatten the matrices into vectors
vec1 <- as.vector(matrix1)
vec2 <- as.vector(matrix2)

# Plot vec1 against vec2
plot(vec1, vec2, xlab = "Matrix 1 Values", ylab = "Matrix 2 Values", main = "Scatter Plot of Matrix1 vs Matrix2", pch = 19, col = "blue")

```



```{r}
par(mar=c(4,2,2,2))
for (time in 1:bigT) {
	plot(rout$alpha_out[,time],
		 ylim=c(0,1),
		 type="l",
		 xlab="iterates",
		 ylab="",
		 main=bquote("Trace plot of " * alpha[.(time)] ))
}
```
# muh
```{r}
subject = 1
for (time in 1:bigT){
	plot(rout$muh_out[time,subject,],type="l",
		 main=bquote("Trace plot of " * mu * " at time " * .(time) * 
		 				" - subject " * .(subject)),
		 xlab = "MCMC iterations",ylab="values")
}
for (time in 1:bigT){
	par(mar=c(4,4,3,2))
	acf(rout$muh_out[time,subject,],main=bquote("ACF plot of " * mu * " at time " * .(time) * 
		 				" - subject " * .(subject)))
}
```


## close log
```{r}
TestModule1$close_log_file()
```









