cat(crayon::cyan("Fit took:\n"))
print(round(differenza_tempo,digits = 4))
cat(crayon::blue("That was for fitting",max(time_span),"time steps.\nSo for fitting all 53 weeks the expected time with these parameters will be:\n"))
print(round(differenza_tempo/max(time_span)*53,digits=4))
cat(crayon::red("\nLPML =",drpm1$lpml, "\nWAIC =",drpm1$waic))
devtools::load_all("../../drpm/")
niter=3; nburn=1; nthin=1
nout <- (niter-nburn)/nthin
cat(nout,"valid iterations\n")
seed_choice = round(runif(1,0,1000))
set.seed(seed_choice)
cat(paste0("seed ",seed_choice,"\n==========================\n",date(),"\n\n"))
tempo_inizio <- Sys.time()
drpm1 <- drpm_fit(y=yt,
s_coords = sites,
M=1,
initial_partition = NULL,
starting_alpha = 0.5,
unit_specific_alpha = FALSE,
# time_specific_alpha = TRUE, # meaning a bit ambiguos
# Ok after experimenting it means that:
# - if true we let alpha be a param that changes over time.
#	At time 1 we have a chain with some behaviour,
#	at time 2 another chain with another behaviour, ecc
# - if false we instead fix alpha, ie all chains of all times
#	will be the same, as they refer to the same parameter estimation
# The authors in their tests set it to false, ie the fixed alpha
alpha_0=FALSE, # modello temporale, questa deve sempre essere falsa
# parameters from the drpm models comparison:
# case E0P1A1
eta1_0=FALSE,
phi1_0=TRUE,
time_specific_alpha = TRUE,
# modelPriors=c(0,100^2,1,1,1,1), # original default one
modelPriors=c(0,100,10,5,5,2,2,1), # author suggestion/used one
# così con 1,1 è una uniforme
alphaPriors=rbind(c(1,1)), # if time_specific_alpha == TRUE
# alphaPriors=matrix(rep(c(1,1),105),105,2), # if unit_specific_alpha == TRUE
# alphaPriors=matrix(rep(c(1,1),105),105,2), # if both the above are TRUE
simpleModel = 0,
theta_tau2 = c(0, 2), # only used if simpleModel=1
# SpatialCohesion=3, # auxiliary similarity
SpatialCohesion=4, # double dipper similarity, default one
# cParms=c(0, 1, 2, 1), # default one
cParms=c(0, 1, 5, 1), # author suggestion/used one (with 5)
# mh=c(0.5,1,0.1, 0.1, 0.1), # default one
mh=c(0.1,0.1,0.7, 0.1, 0.1), # with a bit of author suggestion/used one
verbose=TRUE,
# draws=1100,burn=100,thin=1) # quick one
# draws=31000,burn=1000,thin=1) # for trace plot analysis
# draws=8000,burn=3000,thin=5) # a bit more serious seriou one
# draws=10000,burn=2000,thin=8) # more serious one
draws=niter,burn=nburn,thin=nthin) # adaptable one
tempo_fine <- Sys.time()
differenza_tempo <- tempo_fine - tempo_inizio
cat(crayon::cyan("Fit took:\n"))
print(round(differenza_tempo,digits = 4))
cat(crayon::blue("That was for fitting",max(time_span),"time steps.\nSo for fitting all 53 weeks the expected time with these parameters will be:\n"))
print(round(differenza_tempo/max(time_span)*53,digits=4))
cat(crayon::red("\nLPML =",drpm1$lpml, "\nWAIC =",drpm1$waic))
devtools::load_all("../../drpm/")
niter=3; nburn=1; nthin=1
nout <- (niter-nburn)/nthin
cat(nout,"valid iterations\n")
seed_choice = round(runif(1,0,1000))
set.seed(seed_choice)
cat(paste0("seed ",seed_choice,"\n==========================\n",date(),"\n\n"))
tempo_inizio <- Sys.time()
drpm1 <- drpm_fit(y=yt,
s_coords = sites,
M=1,
initial_partition = NULL,
starting_alpha = 0.5,
unit_specific_alpha = FALSE,
# time_specific_alpha = TRUE, # meaning a bit ambiguos
# Ok after experimenting it means that:
# - if true we let alpha be a param that changes over time.
#	At time 1 we have a chain with some behaviour,
#	at time 2 another chain with another behaviour, ecc
# - if false we instead fix alpha, ie all chains of all times
#	will be the same, as they refer to the same parameter estimation
# The authors in their tests set it to false, ie the fixed alpha
alpha_0=FALSE, # modello temporale, questa deve sempre essere falsa
# parameters from the drpm models comparison:
# case E0P1A1
eta1_0=FALSE,
phi1_0=TRUE,
time_specific_alpha = TRUE,
# modelPriors=c(0,100^2,1,1,1,1), # original default one
modelPriors=c(0,100,10,5,5,2,2,1), # author suggestion/used one
# così con 1,1 è una uniforme
alphaPriors=rbind(c(1,1)), # if time_specific_alpha == TRUE
# alphaPriors=matrix(rep(c(1,1),105),105,2), # if unit_specific_alpha == TRUE
# alphaPriors=matrix(rep(c(1,1),105),105,2), # if both the above are TRUE
simpleModel = 0,
theta_tau2 = c(0, 2), # only used if simpleModel=1
# SpatialCohesion=3, # auxiliary similarity
SpatialCohesion=4, # double dipper similarity, default one
# cParms=c(0, 1, 2, 1), # default one
cParms=c(0, 1, 5, 1), # author suggestion/used one (with 5)
# mh=c(0.5,1,0.1, 0.1, 0.1), # default one
mh=c(0.1,0.1,0.7, 0.1, 0.1), # with a bit of author suggestion/used one
verbose=TRUE,
# draws=1100,burn=100,thin=1) # quick one
# draws=31000,burn=1000,thin=1) # for trace plot analysis
# draws=8000,burn=3000,thin=5) # a bit more serious seriou one
# draws=10000,burn=2000,thin=8) # more serious one
draws=niter,burn=nburn,thin=nthin) # adaptable one
tempo_fine <- Sys.time()
differenza_tempo <- tempo_fine - tempo_inizio
cat(crayon::cyan("Fit took:\n"))
print(round(differenza_tempo,digits = 4))
cat(crayon::blue("That was for fitting",max(time_span),"time steps.\nSo for fitting all 53 weeks the expected time with these parameters will be:\n"))
print(round(differenza_tempo/max(time_span)*53,digits=4))
cat(crayon::red("\nLPML =",drpm1$lpml, "\nWAIC =",drpm1$waic))
devtools::load_all("../../drpm/")
cat(paste0("seed ",seed_choice,"\n==========================\n",date(),"\n\n"))
tempo_inizio <- Sys.time()
drpm1 <- drpm_fit(y=yt,
s_coords = sites,
M=1,
initial_partition = NULL,
starting_alpha = 0.5,
unit_specific_alpha = FALSE,
# time_specific_alpha = TRUE, # meaning a bit ambiguos
# Ok after experimenting it means that:
# - if true we let alpha be a param that changes over time.
#	At time 1 we have a chain with some behaviour,
#	at time 2 another chain with another behaviour, ecc
# - if false we instead fix alpha, ie all chains of all times
#	will be the same, as they refer to the same parameter estimation
# The authors in their tests set it to false, ie the fixed alpha
alpha_0=FALSE, # modello temporale, questa deve sempre essere falsa
# parameters from the drpm models comparison:
# case E0P1A1
eta1_0=FALSE,
phi1_0=TRUE,
time_specific_alpha = TRUE,
# modelPriors=c(0,100^2,1,1,1,1), # original default one
modelPriors=c(0,100,10,5,5,2,2,1), # author suggestion/used one
# così con 1,1 è una uniforme
alphaPriors=rbind(c(1,1)), # if time_specific_alpha == TRUE
# alphaPriors=matrix(rep(c(1,1),105),105,2), # if unit_specific_alpha == TRUE
# alphaPriors=matrix(rep(c(1,1),105),105,2), # if both the above are TRUE
simpleModel = 0,
theta_tau2 = c(0, 2), # only used if simpleModel=1
# SpatialCohesion=3, # auxiliary similarity
SpatialCohesion=4, # double dipper similarity, default one
# cParms=c(0, 1, 2, 1), # default one
cParms=c(0, 1, 5, 1), # author suggestion/used one (with 5)
# mh=c(0.5,1,0.1, 0.1, 0.1), # default one
mh=c(0.1,0.1,0.7, 0.1, 0.1), # with a bit of author suggestion/used one
verbose=TRUE,
# draws=1100,burn=100,thin=1) # quick one
# draws=31000,burn=1000,thin=1) # for trace plot analysis
# draws=8000,burn=3000,thin=5) # a bit more serious seriou one
# draws=10000,burn=2000,thin=8) # more serious one
draws=niter,burn=nburn,thin=nthin) # adaptable one
tempo_fine <- Sys.time()
differenza_tempo <- tempo_fine - tempo_inizio
cat(crayon::cyan("Fit took:\n"))
print(round(differenza_tempo,digits = 4))
cat(crayon::blue("That was for fitting",max(time_span),"time steps.\nSo for fitting all 53 weeks the expected time with these parameters will be:\n"))
print(round(differenza_tempo/max(time_span)*53,digits=4))
cat(crayon::red("\nLPML =",drpm1$lpml, "\nWAIC =",drpm1$waic))
devtools::load_all("../../drpm/")
cat(paste0("seed ",seed_choice,"\n==========================\n",date(),"\n\n"))
tempo_inizio <- Sys.time()
drpm1 <- drpm_fit(y=yt,
s_coords = sites,
M=1,
initial_partition = NULL,
starting_alpha = 0.5,
unit_specific_alpha = FALSE,
# time_specific_alpha = TRUE, # meaning a bit ambiguos
# Ok after experimenting it means that:
# - if true we let alpha be a param that changes over time.
#	At time 1 we have a chain with some behaviour,
#	at time 2 another chain with another behaviour, ecc
# - if false we instead fix alpha, ie all chains of all times
#	will be the same, as they refer to the same parameter estimation
# The authors in their tests set it to false, ie the fixed alpha
alpha_0=FALSE, # modello temporale, questa deve sempre essere falsa
# parameters from the drpm models comparison:
# case E0P1A1
eta1_0=FALSE,
phi1_0=TRUE,
time_specific_alpha = TRUE,
# modelPriors=c(0,100^2,1,1,1,1), # original default one
modelPriors=c(0,100,10,5,5,2,2,1), # author suggestion/used one
# così con 1,1 è una uniforme
alphaPriors=rbind(c(1,1)), # if time_specific_alpha == TRUE
# alphaPriors=matrix(rep(c(1,1),105),105,2), # if unit_specific_alpha == TRUE
# alphaPriors=matrix(rep(c(1,1),105),105,2), # if both the above are TRUE
simpleModel = 0,
theta_tau2 = c(0, 2), # only used if simpleModel=1
# SpatialCohesion=3, # auxiliary similarity
SpatialCohesion=4, # double dipper similarity, default one
# cParms=c(0, 1, 2, 1), # default one
cParms=c(0, 1, 5, 1), # author suggestion/used one (with 5)
# mh=c(0.5,1,0.1, 0.1, 0.1), # default one
mh=c(0.1,0.1,0.7, 0.1, 0.1), # with a bit of author suggestion/used one
verbose=TRUE,
# draws=1100,burn=100,thin=1) # quick one
# draws=31000,burn=1000,thin=1) # for trace plot analysis
# draws=8000,burn=3000,thin=5) # a bit more serious seriou one
# draws=10000,burn=2000,thin=8) # more serious one
draws=niter,burn=nburn,thin=nthin) # adaptable one
tempo_fine <- Sys.time()
differenza_tempo <- tempo_fine - tempo_inizio
cat(crayon::cyan("Fit took:\n"))
print(round(differenza_tempo,digits = 4))
cat(crayon::blue("That was for fitting",max(time_span),"time steps.\nSo for fitting all 53 weeks the expected time with these parameters will be:\n"))
print(round(differenza_tempo/max(time_span)*53,digits=4))
cat(crayon::red("\nLPML =",drpm1$lpml, "\nWAIC =",drpm1$waic))
sites = data.frame(
longitude = unique(df_weekly$Longitude),
latitude = unique(df_weekly$Latitude))
stations = unique(df_wsc$IDStations)
y=data.frame()
for(st in stations){
y_we_pm10=cbind(as.data.frame(st),t(df_wsc[which(df_wsc$IDStations==st),"AQ_pm10"]))
y=rbind(y,y_we_pm10)
}
rownames(y) = NULL
colnames(y)<- c("id",paste0("w", 1:53))
df_wsc
y
yred=y[,2:54]
cols = colora(size(yred)[1],56,0)
for(i in 1:size(yred)[1]){
if(i==1){
plot(1:size(yred)[2],yred[i,],col=cols[i],ylim=extrema(yred),type='l',xlab='weeks',ylab='pm10')
}
else{
lines(1:size(yred)[2],yred[i,],col=cols[i])
}
}
cols = colora(105,56,show=F)
chosen_variable_name = "AQ_pm10"
trendYearStation_week <- function(file_name){
data_from_to = df_wsc
len_time = 54
chosen_variable = (data_from_to[,chosen_variable_name])
# Crea il grafico ggplot
station_trend <- ggplot(data_from_to,aes(x = week,
y = AQ_pm10,
group=IDStations,
color = as.factor(IDStations))) +
geom_line(show.legend = FALSE) +
labs(x = "Stations", y = chosen_variable_name, title = "Year: 2018 all stations") +
ylim(range(na.omit(chosen_variable))) +
scale_color_manual(values = cols) +
theme_bw()+
theme(panel.grid = element_blank()) +
guides(color = guide_legend())+
labs(x="week")
len_time = (len_time%/%5)
return(trend_animator(file_name,station_trend, data_from_to$week,len_time))
}
trendYearStation_week("None")
size(y)
?drpm
devtools::load_all("../../drpm/")
?drpm_fit
size(sites)
install.packages("JuliaCall")
library(JuliaCall)
julia_setup()
library(devtools)
?load_all
?.C
?.julia
?JuliaCall::julia_do.call
?julia_do.call
?julia_call
pwd()
gewd()
getwd()
library(JuliaCall)
julia_source("../../drpm_julia/julia_on_R_test.jl")
julia_source("../../drpm_julia/julia_on_R_test.jl")
library(JuliaCall)
julia_source("../../drpm_julia/julia_on_R_test.jl")
?julia_source
julia_call("my_sum",4,5)
julia_call("my_sum",4,5,show_value = T)
julia_source("../../drpm_julia/julia_on_R_test.jl")
julia_call("my_sum",4,5,show_value = TRUE)
library(JuliaCall)
julia_source("../../drpm_julia/julia_on_R_test.jl")
julia_call("my_sum",4,5,show_value = TRUE)
?julia_call
julia_call("my_sum",4,5,
need_return = "R",
show_value = TRUE)
julia_call("my_sum",4,5,
need_return = "Julia",
show_value = TRUE)
julia_call("my_sum",4,5,
need_return = "R",
show_value = TRUE)
julia_source("../../drpm_julia/julia_on_R_test.jl")
julia_call("my_sum",4,5,FALSE,
need_return = "R",
show_value = FALSE)
avec = c(1,2,3)
bvec = c(1,2,3)
avec = c(1,2,3)
bvec = c(1,2,3)
a = 4
b = 5
a = 4
a = 4
b = 5
julia_source("../../drpm_julia/julia_on_R_test.jl")
julia_call("my_sum",4,5,FALSE,
need_return = "R",
show_value = FALSE)
julia_source("../../drpm_julia/julia_on_R_test.jl")
julia_call("my_sum",4,5,FALSE,
need_return = "R",
show_value = TRUE)
julia_source("../../drpm_julia/julia_on_R_test.jl")
julia_call("my_sum",4,5,TRUE,
need_return = "R",
show_value = TRUE)
julia_source("../../drpm_julia/julia_on_R_test.jl")
julia_call("my_sum",4,5,TRUE,
need_return = "R",
show_value = TRUE)
julia_source("../../drpm_julia/julia_on_R_test.jl")
julia_call("my_sum",4,5,TRUE,
need_return = "R",
show_value = TRUE)
julia_source("../../drpm_julia/julia_on_R_test.jl")
julia_call("my_sum",4,5,TRUE,
need_return = "R",
show_value = TRUE)
julia_call("my_sum",4,5,FALSE,
need_return = "R",
show_value = TRUE)
julia_call("my_sum",4,5,0,
need_return = "R",
show_value = TRUE)
julia_source("../../drpm_julia/julia_on_R_test.jl")
julia_call("my_sum",4,5,0,
need_return = "R",
show_value = TRUE)
julia_call("my_sum",4,5,1,
need_return = "R",
show_value = TRUE)
julia_call("my_sum",4,7,1,
need_return = "R",
show_value = TRUE)
julia_call("my_sum",4,7,1,
need_return = "R",
show_value = FALSE)
?capture.output
julia_source("../../drpm_julia/julia_on_R_test.jl")
output <- capture.output(
julia_call("my_sum",4,7,1,
need_return = "R",
show_value = FALSE)
)
cat(output, sep = "\n")
julia_source("../../drpm_julia/julia_on_R_test.jl")
julia_call("my_sum",4,7,1,
need_return = "R",
show_value = FALSE)
julia_install_package("Printf")
julia_source("../../drpm_julia/julia_on_R_test.jl")
julia_call("my_sum",4,7,1,
need_return = "R",
show_value = FALSE)
julia_source("../../drpm_julia/julia_on_R_test.jl")
output <- capture.output(
julia_call("my_sum",4,7,1,
need_return = "R",
show_value = FALSE)
)
cat(output, sep = "\n")
julia_source("../../drpm_julia/julia_on_R_test.jl")
julia_source("../../drpm_julia/julia_on_R_test.jl")
julia_call("my_sum",4,7,1,
need_return = "R",
show_value = FALSE)
version
version()
julia_source("../../drpm_julia/julia_on_R_test.jl")
julia_call("my_sum",4,7,1,
need_return = "R",
show_value = FALSE)
julia_source("../../drpm_julia/julia_on_R_test.jl")
julia_call("my_sum",4,7,
need_return = "R",
show_value = FALSE)
julia_call("my_sum",4,8,
need_return = "R",
show_value = FALSE)
julia_source("../../drpm_julia/julia_on_R_test.jl")
julia_call("my_sum",4,8,
need_return = "R",
show_value = FALSE)
julia_source("../../drpm_julia/julia_on_R_test.jl")
julia_call("my_sum",4,8,
need_return = "R",
show_value = TRUE)
library(JuliaCall)
julia_setup()
julia_source("../../drpm_julia/julia_on_R_test.jl")
julia_call("my_sum",4,8,
need_return = "R",
show_value = TRUE)
julia_call("my_sum",4,8,
need_return = "R",
show_value = TRUE)
julia_install_package("Suppressor")
a = 4
b = 5
julia_source("../../drpm_julia/julia_on_R_test.jl")
julia_call("my_sum",4,8,
need_return = "R",
show_value = TRUE)
julia_install_package("RCall")
julia_source("../../drpm_julia/julia_on_R_test.jl")
julia_call("my_sum",4,8,
need_return = "R",
show_value = TRUE)
julia_command('sqrt(2)')
julia_command('sqrt(2)')
julia_command('R"library(JuliaCall)"')
julia_source("../../drpm_julia/julia_on_R_test.jl")
julia_call("my_sum",4,8,
need_return = "R",
show_value = TRUE)
julia_do.call("my_sum",4,8,
need_return = "R",
show_value = TRUE)
julia_do.call("my_sum",4,8,
need_return = "R",
show_value = TRUE)
julia_do.call("my_sum",4,8)
?julia_do.call
julia_do.call("my_sum",list(4,8))
julia_call("my_sum",4,8,
need_return = "R",
show_value = TRUE)
julia_command('R"library(JuliaCall)"')
julia_source("../../drpm_julia/julia_on_R_test.jl")
julia_call("my_sum",4,8,
need_return = "R",
show_value = TRUE)
julia_source("../../drpm_julia/julia_on_R_test.jl")
julia_call("my_sum",4,8,
need_return = "R",
show_value = TRUE)
julia_call("my_sum",4,10,
need_return = "R",
show_value = TRUE)
julia_source("../../drpm_julia/julia_on_R_test.jl")
julia_call("my_sum",4,10,
need_return = "R",
show_value = TRUE)
julia_command("function Rprint(s) ccall((:Rprintf,RCall.libR),Void,(Ptr{Cchar},), s) end")
julia_command("function Rprint(s) ccall((:Rprintf,RCall.libR),Void,(Ptr{Cchar},), s) end")
julia_call("my_sum",4,10,
need_return = "R",
show_value = TRUE)
julia_command("
function print_strings()
println(\"Hello from Julia!\")
println(\"This is another string.\")
end
")
julia_call("print_strings")
julia_command("
function capture_output()
io = IOBuffer()
println(io, \"Hello from Julia!\")
println(io, \"This is another string.\")
String(take!(io))
end
")
output <- julia_call("capture_output")
cat(output)
outputjulia_call("capture_output")
julia_call("capture_output")
julia_command("
function print_in_real_time()
for i in 1:5
println(\"Step $i\")
flush(stdout)  # Ensure output is displayed immediately
sleep(1)       # Simulate computation
end
end
")
# Call the Julia function
julia_call("print_in_real_time")
julia_command("
function real_time_output()
io = IOBuffer()
for i in 1:5
println(io, \"Step $i\")
flush(io)  # Ensure output is captured
println(stdout, String(take!(io)))  # Print immediately to R console
sleep(0.1)  # Simulate computation
end
end
")
# Call the Julia function
julia_call("real_time_output")
