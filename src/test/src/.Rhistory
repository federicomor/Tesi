df_temp = data.frame(
clusters = salso_out
)
df_temp$Time = rep(time,dim(df_temp)[1])
df_cluster = rbind(df_cluster,df_temp)
# clusters log
clusters_now = df_temp$clusters
n_clusters = unique(clusters_now)
cat(crayon::red("Time",time,"- #clusters =",length(unique(clusters_now)),"\n"))
}
library(mclust)
# build the ARI matrix
ARImats <- matrix(NA, nrow=LEN, ncol=LEN)
rho_ARI <- list()
for(k in 1:LEN){
rho_ARI[[k]] <- salso(t(FIT$Si[k,,]),
loss=binder(a=1),
# loss=loss,
# loss="VI.lb",
# maxNClusters = maxNClusters
) # adjust with your fit $Si dimension
}
for(k in 1: LEN){
for(kk in 1: LEN){
ARImats[k,kk] <- adjustedRandIndex(rho_ARI[[k]], rho_ARI[[kk]])
}
}
ncols_ari = 100
if (min(ARImats)<0){
cols_ARI = colora(ncols_ari,79,0)
brks = seq(floor(min(ARImats)),1,length.out=ncols_ari+1)
} else {
cols_ARI = colora(ncols_ari,56,0)
cols_ARI = rev(cols_ARI) # must be ordered from cold to warm
brks = seq(0,1,length.out=ncols_ari+1)
}
# or see ?designer.colors for colors
library(fields)
image.plot(ARImats,
main=paste0("Lagged ARI values - ",model_name),axes=FALSE,col=cols_ARI,
breaks=brks)
mtext(text=c(paste("",1:LEN)), side=2, line=0.3,at=seq(0,1,length=LEN), las=1, cex=0.8)
mtext(text=c(paste("",1:LEN)), side=1, line=0.3,at=seq(0,1,length=LEN), las=2, cex=0.8)
##########################################################
cols = colora(size(yred)[1],56,0)
# cols = colora(size(yred)[1],"div",show = 0)
# take last sample (maybe not the best choice)
yredC=t(drpm1$fitted[,,size(drpm1$fitted)[3]])
par(mar=c(4,4,4,2))
for(i in 1:size(yredC)[1]){
if(i==1){
plot(1:size(yredC)[2],yredC[i,],col=cols[i],
ylim=extrema(yred,yredJ,yredC),
type='l',xlab='time',ylab="fitted values",main="model C")
}
else{
lines(1:size(yredC)[2],yredC[i,],col=cols[i])
}
}
# take last sample (maybe not the best choice)
yredJ=t(rout$fitted[,,size(rout$fitted)[3]])
par(mar=c(4,4,4,2))
for(i in 1:size(yredJ)[1]){
if(i==1){
plot(1:size(yredJ)[2],yredJ[i,],col=cols[i],
ylim=extrema(yred,yredJ,yredC),
type='l',xlab='time',ylab="fitted values",main="model J")
}
else{
lines(1:size(yredJ)[2],yredJ[i,],col=cols[i])
}
}
# original real data
yred=y
for(i in 1:size(yred)[1]){
if(i==1){
plot(1:size(yred)[2],yred[i,],col=cols[i],type='l',
xlab='time',ylab='values',main="original data",
ylim=extrema(yred,yredJ,yredC))
}
else{
lines(1:size(yred)[2],yred[i,],col=cols[i])
}
}
num_cols = 4
cols = qualitative_hcl(num_cols, palette = "Dark 3")
# cols <- rainbow(num_cols)
# cols <- brewer.pal(num_cols, "Paired")
# cols <- c(brewer.pal(12, "Paired"), brewer.pal(12, "Set3"))
par(mfrow=c(4,5),par=c(2,2,4,2))
for(time in time_span){
df_cluster_cut = df_cluster[df_cluster$Time==time,]
plot(s_std,
col=cols[df_cluster_cut$clusters],
pch=19,
cex=2,
main=paste("Time",time)
)
}
num_cols = 4
cols = qualitative_hcl(num_cols, palette = "Dark 3")
# cols <- rainbow(num_cols)
# cols <- brewer.pal(num_cols, "Paired")
# cols <- c(brewer.pal(12, "Paired"), brewer.pal(12, "Set3"))
par(mfrow=c(4,5),par=c(1,1,1,1))
for(time in time_span){
df_cluster_cut = df_cluster[df_cluster$Time==time,]
plot(s_std,
col=cols[df_cluster_cut$clusters],
pch=19,
cex=2,
main=paste("Time",time)
)
}
num_cols = 4
cols = qualitative_hcl(num_cols, palette = "Dark 3")
# cols <- rainbow(num_cols)
# cols <- brewer.pal(num_cols, "Paired")
# cols <- c(brewer.pal(12, "Paired"), brewer.pal(12, "Set3"))
par(mfrow=c(4,5))
x11()
for(time in time_span){
df_cluster_cut = df_cluster[df_cluster$Time==time,]
plot(s_std,
col=cols[df_cluster_cut$clusters],
pch=19,
cex=2,
main=paste("Time",time)
)
}
num_cols = 4
cols = qualitative_hcl(num_cols, palette = "Dark 3")
# cols <- rainbow(num_cols)
# cols <- brewer.pal(num_cols, "Paired")
# cols <- c(brewer.pal(12, "Paired"), brewer.pal(12, "Set3"))
par(mfrow=c(4,5))
x11()
for(time in time_span){
df_cluster_cut = df_cluster[df_cluster$Time==time,]
plot(s_std,
col=cols[df_cluster_cut$clusters],
pch=19,
cex=2,
main=paste("Time",time)
)
}
num_cols = 10
cols = qualitative_hcl(num_cols, palette = "Dark 3")
# cols <- rainbow(num_cols)
# cols <- brewer.pal(num_cols, "Paired")
# cols <- c(brewer.pal(12, "Paired"), brewer.pal(12, "Set3"))
par(mfrow=c(4,5))
x11()
for(time in time_span){
df_cluster_cut = df_cluster[df_cluster$Time==time,]
plot(s_std,
col=cols[df_cluster_cut$clusters],
pch=19,
cex=2,
main=paste("Time",time)
)
}
num_cols = 10
cols = qualitative_hcl(num_cols, palette = "Dark 3")
# cols <- rainbow(num_cols)
# cols <- brewer.pal(num_cols, "Paired")
# cols <- c(brewer.pal(12, "Paired"), brewer.pal(12, "Set3"))
# par(mfrow=c(4,5))
# x11()
for(time in time_span){
df_cluster_cut = df_cluster[df_cluster$Time==time,]
plot(s_std,
col=cols[df_cluster_cut$clusters],
pch=19,
cex=2,
main=paste("Time",time)
)
}
num_cols = 10
cols = qualitative_hcl(num_cols, palette = "Dark 3")
# cols <- rainbow(num_cols)
# cols <- brewer.pal(num_cols, "Paired")
# cols <- c(brewer.pal(12, "Paired"), brewer.pal(12, "Set3"))
for(time in time_span){
df_cluster_cut = df_cluster[df_cluster$Time==time,]
plot(s_std,
col=cols[df_cluster_cut$clusters],
pch=19,
cex=2,
main=paste("Time",time)
)
}
##########################
model_name = "model C"
FIT = drpm1
##########################
df_cluster = data.frame(Longitude=c(),Latitude=c(),values=c(),clusters=c(),Time=c())
for(time in time_span){
salso_out <- salso(t(FIT$Si[time-(min(time_span)-1),,]),
loss=binder(a=1),
# loss="VI",
# loss="VI.lb",
)
df_temp = data.frame(
Longitude = sites$longitude,
Latitude = sites$latitude,
clusters = salso_out[1:105]
)
df_temp$Time = rep(time,dim(df_temp)[1])
df_cluster = rbind(df_cluster,df_temp)
# clusters log
clusters_now = df_temp$clusters
n_clusters = unique(clusters_now)
ycurrent = y[,paste0("w",time)]
cat(crayon::red("Time",time,"- #clusters =",length(unique(clusters_now)),"\n"))
}
clusters_old = NULL
for(time in time_span){
cat(crayon::red("Time",time,"\n"))
df_cluster_cut = df_cluster[df_cluster$Time==time,]
clusters_now = df_cluster_cut$clusters
####### no mode correct now
# clusters_now = mode_correct_clusters(clusters_old,clusters_now,very_verbose = 0)
# se fai heat plot non serve fare la mode correct
# perché la heat plot la usi per vedere anche i valori di pm10, non la coerenza temporale
# nei gruppi, che con la heat coloration si perde come visibilità (non so se è chiaro)
df_cluster_cut$clusters = clusters_now
# meglio l'idea 1
cols = color_correct_clusters(df_cluster_cut,idea=1,verbose=0)
# q = get_graph_plot(df_cluster_cut,cols)
# print(q)
p = plot_graph_and_hist(df_cluster_cut,cols,titolo = model_name)
clusters_old = clusters_now
}
# preparation
source("plot functions/plotter.R")
source("include_clusters_functions.R")
sites = data.frame(
longitude = unique(df_weekly$Longitude),
latitude = unique(df_weekly$Latitude))
##########################
model_name = "model C"
FIT = drpm1
##########################
df_cluster = data.frame(Longitude=c(),Latitude=c(),values=c(),clusters=c(),Time=c())
for(time in time_span){
salso_out <- salso(t(FIT$Si[time-(min(time_span)-1),,]),
loss=binder(a=1),
# loss="VI",
# loss="VI.lb",
)
df_temp = data.frame(
Longitude = sites$longitude,
Latitude = sites$latitude,
clusters = salso_out[1:105]
)
df_temp$Time = rep(time,dim(df_temp)[1])
df_cluster = rbind(df_cluster,df_temp)
# clusters log
clusters_now = df_temp$clusters
n_clusters = unique(clusters_now)
ycurrent = y[,paste0("w",time)]
cat(crayon::red("Time",time,"- #clusters =",length(unique(clusters_now)),"\n"))
}
clusters_old = NULL
for(time in time_span){
cat(crayon::red("Time",time,"\n"))
df_cluster_cut = df_cluster[df_cluster$Time==time,]
clusters_now = df_cluster_cut$clusters
####### no mode correct now
# clusters_now = mode_correct_clusters(clusters_old,clusters_now,very_verbose = 0)
# se fai heat plot non serve fare la mode correct
# perché la heat plot la usi per vedere anche i valori di pm10, non la coerenza temporale
# nei gruppi, che con la heat coloration si perde come visibilità (non so se è chiaro)
df_cluster_cut$clusters = clusters_now
# meglio l'idea 1
cols = color_correct_clusters(df_cluster_cut,idea=1,verbose=0)
# q = get_graph_plot(df_cluster_cut,cols)
# print(q)
p = plot_graph_and_hist(df_cluster_cut,cols,titolo = model_name)
clusters_old = clusters_now
}
##########################
model_name = "model J"
FIT = rout
##########################
df_cluster = data.frame(Longitude=c(),Latitude=c(),values=c(),clusters=c(),Time=c())
for(time in time_span){
salso_out <- salso(t(FIT$Si[time-(min(time_span)-1),,]),
loss=binder(a=1),
# loss="VI",
# loss="VI.lb",
maxNClusters = 2
)
df_temp = data.frame(
Longitude = sites$longitude,
Latitude = sites$latitude,
clusters = salso_out[1:105]
)
df_temp$Time = rep(time,dim(df_temp)[1])
df_cluster = rbind(df_cluster,df_temp)
# clusters log
clusters_now = df_temp$clusters
n_clusters = unique(clusters_now)
ycurrent = y[,paste0("w",time)]
cat(crayon::red("Time",time,"- #clusters =",length(unique(clusters_now)),"\n"))
}
clusters_old = NULL
for(time in time_span){
cat(crayon::red("Time",time,"\n"))
df_cluster_cut = df_cluster[df_cluster$Time==time,]
clusters_now = df_cluster_cut$clusters
####### no mode correct now
# clusters_now = mode_correct_clusters(clusters_old,clusters_now,very_verbose = 0)
# se fai heat plot non serve fare la mode correct
# perché la heat plot la usi per vedere anche i valori di pm10, non la coerenza temporale
# nei gruppi, che con la heat coloration si perde come visibilità (non so se è chiaro)
df_cluster_cut$clusters = clusters_now
# meglio l'idea 1
cols = color_correct_clusters(df_cluster_cut,idea=1,verbose=0)
# q = get_graph_plot(df_cluster_cut,cols)
# print(q)
p = plot_graph_and_hist(df_cluster_cut,cols,titolo = model_name)
clusters_old = clusters_now
}
seed = as.integer(runif(1,0,1000))*1.0
seed = 398.0
set.seed(seed)
cat(seed)
source("../Supplementary material/Functions.R")
N <- 5; Tm<-6; M<-1;
alpha = 0.99
ndata <- 100
dat <- rtpartition1(N=N,M=M,rho=alpha,ntime=Tm,tau=5,sig=1,
Caron=FALSE,FirstPart=NULL,TYPE="Random",
phi0=0, phi1=1)
y<- t(dat$YMat)
cols = colora(N,seed = 56,show = 0)
yred=y
cols = colora(size(yred)[1],56,0)
for(i in 1:size(yred)[1]){
if(i==1){
plot(1:size(yred)[2],yred[i,],col=cols[i],ylim=extrema(yred),type='l',xlab='weeks',ylab='pm10')
}
else{
lines(1:size(yred)[2],yred[i,],col=cols[i])
}
}
niter=20; nburn=1; nthin=2
nout <- (niter-nburn)/nthin
cat(nout,"valid iterations\n")
niter=20; nburn=10; nthin=2
nout <- (niter-nburn)/nthin
cat(nout,"valid iterations\n")
# params
m0_phi0 = 0
s20_phi0 = 1
A_ub_sigma = 5
A_ub_tau = 5
A_ub_lambda = 5
a_sigma  = 5; b_sigma  = 2
a_tau    = 5; b_tau    = 2
a_lambda = 5; b_lambda = 2
eta1_scale = 0.9
sig_mh_sig2 = 0.2
sig_mh_tau2 = 0.2
sig_mh_lambda2 = 0.2
sig_mh_eta1 = 0.2
sig_mh_phi1 = 0.2
update_eta1 = TRUE
update_phi1 = TRUE
mu0 = 0
k0 = 1
v0 = 5
L0 = 1
a_alpha = 2; b_alpha = 2
currwd = getwd()
setwd("C:/Users/feder/Desktop/Uni magistrale/Tesi/src/test/Supplementary material/")
source("Functions.R")
library(salso)
library(drpm)
library(MCMCpack)
library(mclust)
# This data is found in the gstat package
library(gstat)
data(DE_RB_2005)
dat <- DE_RB_2005
# Create ymat with columns corresponding to time rows stations
N <- length(dat@sp)
Tm <- 365
y <- matrix(NA, nrow=N, ncol=Tm)
for(i in 1:Tm){
y[dat@index[dat@index[,2]==i,1], i] <- dat@data[dat@index[,2]==i,1]
}
# Try to create an average PM10 per month
year <- c(rep(1,31),rep(2,28),rep(3,31),rep(4,30),rep(5,31),
rep(6,30),rep(7,31),rep(8,31),rep(9,30),rep(10,31),
rep(11,30),rep(12,31))
week <- rep(1:52, each=7)
ymn <- t(apply(y, 1, function(x) tapply(x,year,mean, na.rm=TRUE)))
## Keep those that don't have any missing values when overageing over a month
ysub2 <- ymn[-c(4,16,25,27,30,43,52,59,69),]
mn <- apply(ysub2,2,mean)
sd <- apply(ysub2,2,sd)
# Center the observations
y <- t(t(ysub2) - mn)
Tm = tps <- ncol(y) # time span
N = size(y)[1] # number of units
s_coords <- (dat@sp@coords)[-c(4,16,25,27,30,43,52,59,69),]
smn <- apply(s_coords,2,mean)
ssd <- apply(s_coords,2,sd)
s_std <- t((t(s_coords) - smn)/ssd)
setwd(currwd)
### subset test
kk = 10
y = y[1:k,]
s_std = s_std[1:k,]
k
### subset test
kk = 10
y = y[1:kk,]
s_std = s_std[1:kk,]
# Create ymat with columns corresponding to time rows stations
N <- length(dat@sp)
Tm <- 365
y <- matrix(NA, nrow=N, ncol=Tm)
for(i in 1:Tm){
y[dat@index[dat@index[,2]==i,1], i] <- dat@data[dat@index[,2]==i,1]
}
# Try to create an average PM10 per month
year <- c(rep(1,31),rep(2,28),rep(3,31),rep(4,30),rep(5,31),
rep(6,30),rep(7,31),rep(8,31),rep(9,30),rep(10,31),
rep(11,30),rep(12,31))
week <- rep(1:52, each=7)
ymn <- t(apply(y, 1, function(x) tapply(x,year,mean, na.rm=TRUE)))
## Keep those that don't have any missing values when overageing over a month
ysub2 <- ymn[-c(4,16,25,27,30,43,52,59,69),]
mn <- apply(ysub2,2,mean)
sd <- apply(ysub2,2,sd)
# Center the observations
y <- t(t(ysub2) - mn)
Tm = tps <- ncol(y) # time span
N = size(y)[1] # number of units
s_coords <- (dat@sp@coords)[-c(4,16,25,27,30,43,52,59,69),]
smn <- apply(s_coords,2,mean)
ssd <- apply(s_coords,2,sd)
s_std <- t((t(s_coords) - smn)/ssd)
setwd(currwd)
### subset test
kk = 10
y = y[1:kk,]
s_std = s_std[1:kk,]
s_std
y
seed = as.integer(runif(1,0,1000))*1.0
seed = 98.0
cat("seed",seed,"\n")
# niter=1000; nburn=500; nthin=2
# niter=50000; nburn=10000; nthin=40 # they did this in their tests
# niter=60000; nburn=20000; nthin=20
niter=10; nburn=8; nthin=2
nout <- (niter-nburn)/nthin
cat(nout,"valid iterations\n")
# params
m0_phi0 = 0
s20_phi0 = 1
A_ub_sigma = 5
A_ub_tau = 5
A_ub_lambda = 5
a_sigma  = 5; b_sigma  = 2
a_tau    = 2; b_tau    = 10
a_lambda = 5; b_lambda = 2
eta1_scale = 0.9
sig_mh_sig2 = 0.2
sig_mh_tau2 = 0.2
sig_mh_lambda2 = 0.2
sig_mh_eta1 = 0.2
sig_mh_phi1 = 0.2
update_eta1 = TRUE
update_phi1 = TRUE
a_alpha = 2; b_alpha = 2
# now space
spatial_cohesion = 3
mu0 = 0
k0 = 1
v0 = 5
L0 = 1
# params
m0_phi0 = 0
s20_phi0 = 1
A_ub_sigma = 5
A_ub_tau = 5
A_ub_lambda = 5
a_sigma  = 2; b_sigma  = 2
a_tau    = 2; b_tau    = 2
a_lambda = 2; b_lambda = 2
eta1_scale = 0.9
sig_mh_sig2 = 0.2
sig_mh_tau2 = 0.2
sig_mh_lambda2 = 0.2
sig_mh_eta1 = 0.2
sig_mh_phi1 = 0.2
update_eta1 = TRUE
update_phi1 = TRUE
a_alpha = 2; b_alpha = 2
# now space
spatial_cohesion = 3
mu0 = 0
k0 = 1
v0 = 5
L0 = 1
module_JDRPM <- juliaImport(juliaCall("include", module))
