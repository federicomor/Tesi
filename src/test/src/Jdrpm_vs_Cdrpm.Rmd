---
title: "R Notebook"
output: html_document
---

# setup
```{r, warning=FALSE}
library(salso)
library(RColorBrewer)
source("include.R")
```



# LOAD 
## load C drpm
```{r}
devtools::load_all("../../drpm_main/")
# devtools::load_all("../../drpm_sporcato//")
```

## load J drpm
```{r}
library(JuliaConnectoR)
juliaSetupOk()

# juliaEval("using Pkg")
# juliaEval("Pkg.activate(\"../../JDRPM\")")
# juliaEval("Pkg.instantiate()")

# juliaEval("Pkg.status()")

# setup project
juliaEval("using Pkg; Pkg.status()")
juliaEval("Pkg.activate(\"../../JDRPM\")")
juliaEval("using Pkg; Pkg.status()")

module = normalizePath("../../JDRPM/src/JDRPM.jl")
module_JDRPM <- juliaImport(juliaCall("include", module))
```


# ===========
# 1. PAPER TEST
## data used in Page paper
```{r}
seed = as.integer(runif(1,0,1000))*1.0
seed = 398.0
# seed = 881.0
set.seed(seed)
cat(seed)

source("../Supplementary material/Functions.R")
# N <- 5; Tm<-6; M<-1;
# alpha = 0.99

N <- 10; Tm<-12; M<-1;
alpha = 0.5

ndata <- 100
dat <- rtpartition1(N=N,M=M,rho=alpha,ntime=Tm,tau=5,sig=1,
					Caron=FALSE,FirstPart=NULL,TYPE="Random",
				    phi0=0, phi1=1)

y<- t(dat$YMat)

cols = colora(N,seed = 56,show = 0)
yred=y
cols = colora(size(yred)[1],56,0)
for(i in 1:size(yred)[1]){
   if(i==1){
     plot(1:size(yred)[2],yred[i,],col=cols[i],ylim=extrema(yred),type='l',xlab='weeks',ylab='pm10')
 	  } 
	  else{
		  lines(1:size(yred)[2],yred[i,],col=cols[i])
	  }
}
```

## introduce NA test
```{r}
##### at a new time 7
# y_with_na = cbind(y,rep(NA,5))
# y
# y_with_na
# module_JDRPM$test_R_to_J_conversion(as.matrix(y_with_na))

##### deleting values at existent time t, to maybe study MSE
t = 4
y_with_na = y
y_with_na[,t] = rep(NA,5)

##### just some NA
y_with_na = y
y_with_na[3,3] = NA
y_with_na[1,2] = NA
y_with_na[5,5] = NA

y
y_with_na
```


## Fits
```{r}
# niter=40000; nburn=28000; nthin=12
# niter=50000; nburn=30000; nthin=20
niter=20000; nburn=12000; nthin=8
# niter=30000; nburn=20000; nthin=10
# niter=10000; nburn=2000; nthin=8
# niter=1000; nburn=200; nthin=4

nout <- (niter-nburn)/nthin
cat(nout,"valid iterations\n")

```


```{r}
# params
m0_phi0 = 0
s20_phi0 = 10
A_ub_sigma = 5
A_ub_tau = 5
A_ub_lambda = 5
a_sigma  = 2; b_sigma  = 2
a_tau    = 2; b_tau    = 2
a_lambda = 2; b_lambda = 2
eta1_scale = 0.9

sig_mh_sig2 = 0.3
sig_mh_tau2 = 0.3
sig_mh_lambda2 = 0.3
sig_mh_eta1 = 0.2
sig_mh_phi1 = 0.2

update_eta1 = TRUE
update_phi1 = TRUE

mu0 = 0 
k0 = 1
v0 = 5
L0 = 1

a_alpha = 2; b_alpha = 2
```

## drpm C
```{r}
set.seed(1)
tempo_inizio <- Sys.time()
drpm1 <- drpm_fit(
		y=y,
		# y=y_with_na, 
		# s_coords = NA,
        M=1,
        initial_partition = NULL,
		
        starting_alpha = 0.5,
        unit_specific_alpha = FALSE,
        time_specific_alpha = TRUE,
        alpha_0=FALSE,
		
        eta1_0=!(update_eta1),
        phi1_0=!(update_phi1),
        # modelPriors=c(0,100^2,1,1,1,1), # original default one
        modelPriors=c(m0_phi0,s20_phi0,A_ub_sigma,A_ub_tau,A_ub_lambda,eta1_scale),

        alphaPriors=rbind(c(a_alpha,b_alpha)), # if time_specific_alpha == TRUE
        
        simpleModel = 0,
        theta_tau2 = c(0, 2), # only used if simpleModel=1

		SpatialCohesion=3, # auxiliary similarity
		# SpatialCohesion=4, # double dipper similarity
		cParms=c(mu0, k0, v0, L0),
		
		mh=c(sig_mh_sig2,sig_mh_tau2,sig_mh_lambda2,sig_mh_eta1,sig_mh_phi1),
		verbose=TRUE,
		draws=niter,burn=nburn,thin=nthin)

tempo_fine <- Sys.time()
differenza_tempo <- tempo_fine - tempo_inizio
cat(crayon::cyan("Fit took:\n"))
print(round(differenza_tempo,digits = 4))

cat(crayon::red("\nLPML =",drpm1$lpml, "\nWAIC =",drpm1$waic))
```
```{r}
names(drpm1)

cat("\nSi     size = ",size(drpm1$Si),"\n")
cat("gamma  size = ",size(drpm1$gamma),"\n")
cat("mu     size = ",size(drpm1$mu),"\n")
cat("sig2   size = ",size(drpm1$sig2),"\n")
cat("alpha  size = ",size(drpm1$alpha),"\n")
cat("theta  size = ",size(drpm1$theta),"\n")
cat("tau2   size = ",size(drpm1$tau2),"\n")
cat("eta1   size = ",size(drpm1$eta1),"\n")
cat("phi0   size = ",size(drpm1$phi0),"\n")
cat("phi1   size = ",size(drpm1$phi1),"\n")
cat("lam2   size = ",size(drpm1$lam2),"\n")
cat("llike  size = ",size(drpm1$llike),"\n")
cat("fitted size = ",size(drpm1$fitted),"\n")
```



## drpm J
```{r}
module_JDRPM <- juliaImport(juliaCall("include", module))
out = module_JDRPM$MCMC_fit(
	Y=as.matrix(y),
	# Y=as.matrix(y_with_na),
	sp_coords = NA,
	M_dp = 1,                     
	initial_partition = NA,
	Xlk_covariates = NA,
	Xcl_covariates = NA,
	# initial_partition = c(1,2,1,2,2),
	
	starting_alpha = 0.5,         
	unit_specific_alpha = FALSE,       
	time_specific_alpha = TRUE,       
	update_alpha = TRUE,             
	
	include_eta1 = TRUE,                    
	include_phi1 = TRUE,
	update_eta1 = update_eta1,                    
	update_phi1 = update_phi1,
	
	sig2h_priors = c(a_sigma,b_sigma),
	eta1_priors = c(eta1_scale,sig_mh_eta1),
	# beta_priors = c(rep(1,p),2),
	beta_priors = NA,
	tau2_priors = c(a_tau,b_tau),
	phi0_priors = c(m0_phi0,s20_phi0),
	phi1_priors = sig_mh_phi1,
	lambda2_priors = c(a_lambda,b_lambda),
	alpha_priors = c(a_alpha,b_alpha),  
	
	# spatial_cohesion_idx = 4,
	# sp_params = list(c(1,2),1,2,matrix(c(1,2,2,4),nrow=2)),
	
	# covariate_similarity_idx = NA,  
	draws = niter,	burnin = nburn,thin = nthin,
	# draws = 100000,	burnin = 60000,thin = 40,
	logging = FALSE,
	seed = 314.0
)
```


```{r}
rout = juliaGet(out)
names(rout)  = c("Si",
				 "gamma",
				 "alpha", 
				 "sigma2h", 
				 "muh", 
				 "eta1",
				 "beta",
				 "theta", 
				 "tau2", 
				 "phi0", 
				 "phi1",
				 "lambda2",
				 "fitted",
				 "llike",
				 "lpml",
				 "waic")

# reshape some stuff to uniform it to drpm output
rout$Si           = aperm(rout$Si,       c(2, 1, 3))
rout$gamma        = aperm(rout$gamma,    c(2, 1, 3))
rout$sigma2h      = aperm(rout$sigma2h,  c(2, 1, 3))
rout$muh          = aperm(rout$muh,      c(2, 1, 3))
rout$fitted       = aperm(rout$fitted,   c(2, 1, 3))
rout$llike        = aperm(rout$llike,    c(2, 1, 3))
if (is.null(size(rout$alpha))) {
	# do nothing
# } else if size(rout$alpha) == 2 {
} else {
	rout$alpha        = aperm(rout$alpha,    c(2, 1))
}
rout$theta        = aperm(rout$theta,    c(2, 1))
rout$tau2         = aperm(rout$tau2,     c(2, 1))
rout$eta1         = aperm(rout$eta1,    c(2, 1))
rout$phi0     = matrix(rout$phi0,    ncol = 1)
rout$phi1     = matrix(rout$phi1,    ncol = 1)
rout$lambda2  = matrix(rout$lambda2, ncol = 1)
cat(crayon::red("\nLPML =",rout$lpml, "\nWAIC =",rout$waic))
```

## NA/MSE analysis

```{r}
# y_with_na
y
j = 3
t = 3
size(rout$fitted)
plot(rout$fitted[t,j,],type="l",main=paste0("trace plot of j=",j," at t=",t))
abline(h=y[j,t],col="#005500")
```

```{r}
##### take last sample (maybe not the best choice)
# for (it in 0:10){
yredJ=t(rout$fitted[,,size(rout$fitted)[3]])

##### take the median/mean/mode
summary_fitted = t(rout$fitted[,,size(rout$fitted)[3]])*0
for(j in 1:N){
	for(t in 1:Tm){
		values_j = c()
		for (it in 1:size(rout$fitted)[3]){
			values_j = c(values_j,rout$fitted[t,j,it])
		}
		summary_fitted[j,t] = mean(values_j)
		# summary_fitted[j,t] = median(values_j)
		# summary_fitted[j,t] = Mode(values_j) # function from include.R
	}
}
yredJ = summary_fitted
yred=y

par(mar=c(4,4,4,2))
cols = colora(size(yredJ)[1],56,0)
for(i in 1:size(yredJ)[1]){
   if(i==1){
     plot(1:size(yredJ)[2],yredJ[i,],col=cols[i],
     	 ylim=extrema(yredJ,yred),type='l',xlab='time',ylab="fitted values",
     	 # main=paste("model J",it))
     	 main="model J")
 	  } 
	  else{
		  lines(1:size(yredJ)[2],yredJ[i,],col=cols[i])
	  }
}

# original real data
cols = colora(N,seed = 56,show = 0)
cols = colora(size(yred)[1],56,0)
for(i in 1:size(yred)[1]){
   if(i==1){
     plot(1:size(yred)[2],yred[i,],col=cols[i],ylim=extrema(yred,yredJ),type='l',
     	 xlab='time',ylab='values',main="original data")
 	  }
	  else{
		  lines(1:size(yred)[2],yred[i,],col=cols[i])
	  }
	text(0.92,yred[i,1],paste(i),col=cols[i])
}
# legend("topleft", legend = paste("Unit", 1:size(yred)[1]), col = cols, lty = 1,cex=0.5)

```

```{r}
y_with_na
```


```{r}
names(rout)

cat("Si           size = ",size(rout$Si),"\n")
cat("gamma        size = ",size(rout$gamma),"\n")
cat("sigma2h      size = ",size(rout$sigma2h),"\n")
cat("muh          size = ",size(rout$muh),"\n")
cat("alpha        size = ",size(rout$alpha),"\n")
cat("theta        size = ",size(rout$theta),"\n")
cat("tau2         size = ",size(rout$tau2),"\n")
cat("eta1         size = ",size(rout$eta1),"\n")
cat("phi0         size = ",size(rout$phi0),"\n")
cat("phi1         size = ",size(rout$phi1),"\n")
cat("lambda2      size = ",size(rout$lambda2),"\n")
cat("beta         size = ",size(rout$beta),"\n")
cat("fitted       size = ",size(rout$fitted),"\n")
cat("llike        size = ",size(rout$llike),"\n")

cat("lpml = ",rout$lpml,"\n")
cat("waic = ",rout$waic,"\n")
```


## Trace plots

### alpha
```{r}
for (time in 1:Tm){
		par(mfrow=c(1,2),mar=c(2,2,4,2))

plot(drpm1$alpha[,time],type="l",
	 main=bquote("Model DRPM C\nTrace plot of alpha at time "*.(time)
	 ), ylim=c(0,1),
	 xlab = "MCMC iterations",ylab="values")
plot(rout$alpha[,time],type="l",
	 main=bquote("Model DRPM J\nTrace plot of alpha at time "*.(time)
	 ), ylim=c(0,1),
	 xlab = "MCMC iterations",ylab="values")
}
```
### mu
```{r}
size(drpm1$mu)
size(rout$muh)
unitj = 1
for (time in 1:Tm){
		par(mfrow=c(1,2),mar=c(2,2,4,2))

	plot(drpm1$mu[time,unitj,],type="l",
		 ylim=c(min(drpm1$mu[time,unitj,],rout$muh[time,unitj,]),
		 	   max(drpm1$mu[time,unitj,],rout$muh[time,unitj,])),
		 main=bquote("Model DRPM C\nTrace plot of mu at time "*.(time) * " unit " * .(unitj)),
		 xlab = "MCMC iterations",ylab="values")
	plot(rout$muh[time,unitj,],type="l",
		 ylim=c(min(drpm1$mu[time,unitj,],rout$muh[time,unitj,]),
		 	   max(drpm1$mu[time,unitj,],rout$muh[time,unitj,])),
		 main=bquote("Model DRPM J\nTrace plot of mu at time "*.(time) * " unit " * .(unitj)),
		 xlab = "MCMC iterations",ylab="values")
}
```

### sigma2
```{r}
size(drpm1$sig2)
size(rout$sigma2h)
unitj = 1
for (time in 1:Tm){
		par(mfrow=c(1,2),mar=c(2,2,4,2))

	plot(drpm1$sig2[time,unitj,],type="l",
		 main=bquote("Model DRPM C\nTrace plot of sigma2 at time "*.(time) * " unit " * .(unitj)),
		 ylim=c(0,max(drpm1$sig2[time,unitj,], rout$sigma2h[time,unitj,])),
		 xlab = "MCMC iterations",ylab="values")
	plot(rout$sigma2h[time,unitj,],type="l",
		 main=bquote("Model DRPM J\nTrace plot of sigma2 at time "*.(time) * " unit " * .(unitj)),
		 ylim=c(0,max(drpm1$sig2[time,unitj,], rout$sigma2h[time,unitj,])),
		 xlab = "MCMC iterations",ylab="values")
}
```

### eta1
```{r}
dim(drpm1$eta1)
dim(rout$eta1)

cat("did we update eta1?", update_eta1)
for (unit in 1:N){
	par(mfrow=c(1,2),mar=c(2,2,4,2))
	plot(drpm1$eta1[,unit],type="l",
		 ylim=c(min(drpm1$eta1[,unit],rout$eta1[,unit]),
		 	    max(drpm1$eta1[,unit],rout$eta1[,unit])),
		 main=bquote("Model DRPM C\nTrace plot of eta1 at unit "*.(unit)),
		 xlab = "MCMC iterations",ylab="values")
	plot(rout$eta1[,unit],type="l",
		 ylim=c(min(drpm1$eta1[,unit],rout$eta1[,unit]),
		 	    max(drpm1$eta1[,unit],rout$eta1[,unit])),
		 main=bquote("Model DRPM J\nTrace plot of eta1 at unit "*.(unit)),
		 xlab = "MCMC iterations",ylab="values")
}
```


### theta
```{r}
for (time in 1:Tm){
	par(mfrow=c(1,2),mar=c(2,2,4,2))
	plot(drpm1$theta[,time],type="l",
		  ylim=c(min(drpm1$theta[,time],rout$theta[,time]),
		 	    max(drpm1$theta[,time],rout$theta[,time])),
		 main=bquote("Model DRPM C\nTrace plot of theta at time "*.(time)),
		 xlab = "MCMC iterations",ylab="values")
	plot(rout$theta[,time],type="l",
		  ylim=c(min(drpm1$theta[,time],rout$theta[,time]),
		 	    max(drpm1$theta[,time],rout$theta[,time])),
		 main=bquote("Model DRPM J\nTrace plot of theta at time "*.(time)),
		 xlab = "MCMC iterations",ylab="values")
}
```

### tau2
```{r}
dim(drpm1$tau2)
dim(rout$tau2)

for (time in 1:Tm){
	par(mfrow=c(1,2),mar=c(2,2,4,2))
	plot(drpm1$tau2[,time],type="l",
		 ylim=c(0,max(drpm1$tau2[,time],rout$tau2[,time])),
		 main=bquote("Model DRPM C\nTrace plot of tau2 at time "*.(time)),
		 xlab = "MCMC iterations",ylab="values")
	plot(rout$tau2[,time],type="l",
		 ylim=c(0,max(drpm1$tau2[,time],rout$tau2[,time])),
		 main=bquote("Model DRPM J\nTrace plot of tau2 at time "*.(time)),
		 xlab = "MCMC iterations",ylab="values")
}
```


### layer three
phi1, phi0, lambda2
```{r}
dim(drpm1$phi1)
dim(rout$phi1)

cat("did we update phi1?", update_phi1)
par(mfrow=c(1,2),mar=c(2,2,4,2))
plot(drpm1$phi1[,1],type="l",
	  ylim=c(min(drpm1$phi1[,1],rout$phi1[,1]),
		 	    max(drpm1$phi1[,1],rout$phi1[,1])),
	 main=bquote("Model DRPM C\nTrace plot of phi1"),
	 xlab = "MCMC iterations",ylab="values")
plot(rout$phi1[,1],type="l",
	  ylim=c(min(drpm1$phi1[,1],rout$phi1[,1]),
		 	    max(drpm1$phi1[,1],rout$phi1[,1])),
	 main=bquote("Model DRPM J\nTrace plot of phi1"),
	 xlab = "MCMC iterations",ylab="values")

dim(drpm1$phi0)
dim(rout$phi0)

par(mfrow=c(1,2),mar=c(2,2,4,2))
plot(drpm1$phi0[,1],type="l",
	 	  ylim=c(min(drpm1$phi0[,1],rout$phi0[,1]),
		 	    max(drpm1$phi0[,1],rout$phi0[,1])),
	 main=bquote("Model DRPM C\nTrace plot of phi0"),
	 xlab = "MCMC iterations",ylab="values")
plot(rout$phi0[,1],type="l",
	 	  ylim=c(min(drpm1$phi0[,1],rout$phi0[,1]),
		 	    max(drpm1$phi0[,1],rout$phi0[,1])),
	 main=bquote("Model DRPM J\nTrace plot of phi0"),
	 xlab = "MCMC iterations",ylab="values")


dim(drpm1$lam2)
dim(rout$lambda2)

par(mfrow=c(1,2),mar=c(2,2,4,2))
plot(drpm1$lam2[,1],type="l",
	 	  ylim=c(min(drpm1$lam2[,1],rout$lambda2[,1]),
		 	    max(drpm1$lam2[,1],rout$lambda2[,1])),
	 main=bquote("Model DRPM C\nTrace plot of lambda2"),
	 xlab = "MCMC iterations",ylab="values")
plot(rout$lambda2[,1],type="l",
	 	  ylim=c(min(drpm1$lam2[,1],rout$lambda2[,1]),
		 	    max(drpm1$lam2[,1],rout$lambda2[,1])),
	 main=bquote("Model DRPM J\nTrace plot of lambda2"),
	 xlab = "MCMC iterations",ylab="values")
```


# functions
```{r}
N = size(y)[1]
Tm = size(y)[2]

generate_partition = function(model){
	partition = list()
	for (t in 1:Tm){
		Si_jt <- model$Si[t, , ]
		Si_jt <- t(Si_jt) 
		partition[[t]] <- salso(Si_jt, loss = "binder")
	}
	return(partition)
}

plot_partition_with_numbers = function(partition,title){
	partition_matrix <- do.call(cbind, partition)
	plot(NULL, NULL, xlim = c(1, Tm), ylim = c(1, N)+c(-0.5,0.5),
	     xlab = "time", ylab = "units",
	     xaxt = "n", yaxt = "n", main = title)
	axis(1, at = 1:Tm, labels = 1:Tm)
	for (t in 1:Tm) {
	  for (unit in 1:N) {
	    text(x = t, y = unit, labels = as.character(unit),
	         col = partition_matrix[unit, t], cex = 1.5)
	  }
	}
}

plot_partition_with_chars = function(partition,title){
	pchs = letters[1:length(partition[[1]])]
	partition_matrix <- do.call(cbind, partition)
	plot(NULL, NULL, xlim = c(1, Tm), ylim = c(1, N)+c(-0.5,0.5),
	     xlab = "time", ylab = "units",
	     xaxt = "n", yaxt = "n", main = title)
	axis(1, at = 1:Tm, labels = 1:Tm)
	for (t in 1:Tm) {
	  for (unit in 1:N) {
	    text(x = t, y = unit, 
	    	 # labels = as.character(unit),
	    	 labels = pchs[unit],
	         col = partition_matrix[unit, t], cex = 1.5)
	  }
	}
}

plot_ARI = function(partition,title){
	LEN = Tm
	df_cluster = data.frame(clusters=c(),Time=c())
	for(time in 1:Tm){
		salso_out <- partition[[time]]
		df_temp = data.frame(
			clusters = salso_out
		)
		df_temp$Time = rep(time,dim(df_temp)[1])
		df_cluster = rbind(df_cluster,df_temp)
		# clusters log
		# clusters_now = df_temp$clusters
		# n_clusters = unique(clusters_now)
		# cat(crayon::red("Time",time,"- #clusters =",length(unique(clusters_now)),"\n"))
	}
	library(mclust)
	# build the ARI matrix
	ARImats <- matrix(NA, nrow=LEN, ncol=LEN)
	rho_ARI <- list()
	for(k in 1:LEN){
		rho_ARI[[k]] <- partition[[k]]
	}
	for(k in 1: LEN){
		for(kk in 1: LEN){
			ARImats[k,kk] <- adjustedRandIndex(rho_ARI[[k]], rho_ARI[[kk]])
		}
	}
	ncols_ari = 100
	# if (min(ARImats)<0){
		# cols_ARI = colora(ncols_ari,79,0)
		# brks = seq(min(-1,floor(min(ARImats))),1,length.out=ncols_ari+1)
	# } else {
		# cols_ARI = colora(ncols_ari,56,0)
		# cols_ARI = rev(cols_ARI) # must be ordered from cold to warm
		cols_ARI = rev(colora(ncols_ari,104,0)) # or 109
		# cols_ARI = colora(ncols_ari,102,0)
		# brks = seq(0,1,length.out=ncols_ari+1)
		brks = seq(min(-1,floor(min(ARImats))),1,length.out=ncols_ari+1)
	# }
	# or see ?designer.colors for colors
	library(fields)
	image.plot(ARImats,
			   main=paste0("Lagged ARI values - ",title),axes=FALSE,col=cols_ARI,
			   breaks=brks)
	mtext(text=c(paste("",1:LEN)), side=2, line=0.3,at=seq(0,1,length=LEN), las=1, cex=0.8)
	mtext(text=c(paste("",1:LEN)), side=1, line=0.3,at=seq(0,1,length=LEN), las=2, cex=0.8)
}
```

```{r}
parts = generate_partition(rout)
plot_partition_with_numbers(parts,title="model J")
plot_partition_with_chars(parts,title="model J")
plot_ARI(parts,title="model J")

parts = generate_partition(drpm1)
plot_partition_with_numbers(parts,title="model C")
plot_partition_with_chars(parts,title="model C")
plot_ARI(parts,title="model C")
```


## Partition plots
```{r}
# partition_plots = function(drpm1, rout){ 
# Initialize a list to store the partitions for each time instant
partitions_drpmc <- generate_partition(drpm1)
partitions_drpmj <- generate_partition(rout)


# partition_matrix <- do.call(cbind, partitions)
# pdf(file="partizioni.pdf",width=10,height = 5)
par(mar=c(4,1,3,1),mfrow=c(1,2),oma=c(1,0.5,0.5,0.5))
plot_partition_with_chars(partitions_drpmc, title="model C")
plot_partition_with_chars(partitions_drpmj, title="model J")
# dev.off()

par(mar=c(4,1,3,1),mfrow=c(1,2),oma=c(1,0.5,0.5,0.5))
plot_partition_with_numbers(partitions_drpmc, title="model C")
plot_partition_with_numbers(partitions_drpmj, title="model J")

# pdf(file="ari.pdf",width=10,height = 5)
par(mar=c(2,2,3,2),mfrow=c(1,2),oma=c(0.5,0.5,0.5,2))
plot_ARI(partitions_drpmc, title="model C")
plot_ARI(partitions_drpmj, title="model J")
# dev.off()
```


```{r}
yredC=t(drpm1$fitted[,,size(drpm1$fitted)[3]])
yredJ=t(rout$fitted[,,size(rout$fitted)[3]])
yredORIG=y

# pdf(file="C_mean_prediction.pdf",height = 6,width=10)
# pdf(file="C_last_iteration.pdf",height = 6,width=10)
##### take the median/mean/mode
summary_fitted = t(drpm1$fitted[,,size(rout$fitted)[3]])*0
for(j in 1:N){
	for(t in 1:Tm){
		values_j = c()
		for (it in 1:size(drpm1$fitted)[3]){
			values_j = c(values_j,drpm1$fitted[t,j,it])
		}
		summary_fitted[j,t] = mean(values_j)
		# summary_fitted[j,t] = median(values_j)
		# summary_fitted[j,t] = Mode(values_j) # function from include.R
	}
}
yred=summary_fitted
# take last sample (maybe not the best choice)
# yred=t(drpm1$fitted[,,size(drpm1$fitted)[3]])

par(mar=c(2,2,2,1))
cols = colora(size(yred)[1],56,0)
for(i in 1:size(yred)[1]){
   if(i==1){
     plot(1:size(yred)[2],yred[i,],col=cols[i],
     	 ylim=extrema(yredJ,yredC,yredORIG),type='l',xlab='',ylab="",
     	 main="C fitted values - last iteration")
     	 # main="C fitted values - iterations mean")
 	  } 
	  else{
		  lines(1:size(yred)[2],yred[i,],col=cols[i])
	  }
}
# dev.off()
#################################################################
# pdf(file="J_mean_prediction.pdf",height = 6,width=10)
# pdf(file="J_last_iteration.pdf",height = 6,width=10)
summary_fitted = t(rout$fitted[,,size(rout$fitted)[3]])*0
for(j in 1:N){
	for(t in 1:Tm){
		values_j = c()
		for (it in 1:size(rout$fitted)[3]){
			values_j = c(values_j,rout$fitted[t,j,it])
		}
		summary_fitted[j,t] = mean(values_j)
		# summary_fitted[j,t] = median(values_j)
		# summary_fitted[j,t] = Mode(values_j) # function from include.R
	}
}
yred=summary_fitted
# take last sample (maybe not the best choice)
# yred=t(rout$fitted[,,size(rout$fitted)[3]])

par(mar=c(2,2,2,1))
cols = colora(size(yred)[1],56,0)
for(i in 1:size(yred)[1]){
   if(i==1){
     plot(1:size(yred)[2],yred[i,],col=cols[i],
     	 ylim=extrema(yredJ,yredC,yredORIG),type='l',xlab='',ylab="",
     	 main="J fitted values - last iteration")
     	 # main="J fitted values - iterations mean")
 	  } 
	  else{
		  lines(1:size(yred)[2],yred[i,],col=cols[i])
	  }
}
# dev.off()
#################################################################


yred=y
cols = colora(N,"div")
# pdf(file="test_1_generated_data.pdf",height = 6,width=10)
par(mar=c(2,2,2,1))
for(i in 1:size(yred)[1]){
   if(i==1){
     plot(1:size(yred)[2],yred[i,],col=cols[i],ylim=extrema(yredJ,yredC,yredORIG),type='l',
     	 xlab='time',
     	 main='Generated values')
 	  } 
	  else{
		  lines(1:size(yred)[2],yred[i,],col=cols[i])
	  }
}
# pchs
# offsets = c(-0.1,-0.2,0,0,0,0.2,0,0,0.1,0.3)
# for(i in 1:N){
# 	text(12.1,yred[i,12]+offsets[i],label=pchs[i],col=cols[i],cex=0.8)
# }
# offsets = c(-0.2,-0.4,0.1,0.7,0.82,-0.8,0,0,0.2,0.1)
# for(i in 1:N){
# 	text(0.92,yred[i,1]+offsets[i],label=pchs[i],col=cols[i],cex=0.8)
# }
# dev.off()
legend("topleft", legend = paste("Unit", 1:size(yred)[1]), col = cols, lty = 1,cex=0.5)
```

```{r}
for(i in 1:size(yred)[1]){
   if(i==1){
     plot(1:size(yred)[2],yred[i,],
     	 col=partitions_drpmc[i],ylim=extrema(yredJ,yredC,yredORIG),
     	 type='p',
     	 xlab='time',
     	 main='Generated values',pch=19)
 	  } 
	  else{
		  points(1:size(yred)[2],yred[i,],col=cols[i],pch=19)
	  }
}
```


# compute mse
```{r}
MSE_matrices = function(m1,m2){
	MSE = 0
	for (i in 1:size(m1)[1]){
		for (t in 1:size(m1)[2]){
			MSE = MSE + (m1[i,t]-m2[i,t])^2
		}
	}
	MSE = MSE/(size(m1)[1]*size(m1)[2])
	return(MSE)
}

##### take the median/mean/mode
summary_fitted = t(drpm1$fitted[,,size(rout$fitted)[3]])*0
for(j in 1:N){
	for(t in 1:Tm){
		values_j = c()
		for (it in 1:size(drpm1$fitted)[3]){
			values_j = c(values_j,drpm1$fitted[t,j,it])
		}
		summary_fitted[j,t] = mean(values_j)
		# summary_fitted[j,t] = median(values_j)
		# summary_fitted[j,t] = Mode(values_j) # function from include.R
	}
}
yredC=summary_fitted
# take last sample (maybe not the best choice)
# yredC=t(drpm1$fitted[,,size(drpm1$fitted)[3]])
#################################################################
summary_fitted = t(rout$fitted[,,size(rout$fitted)[3]])*0
for(j in 1:N){
	for(t in 1:Tm){
		values_j = c()
		for (it in 1:size(rout$fitted)[3]){
			values_j = c(values_j,rout$fitted[t,j,it])
		}
		summary_fitted[j,t] = mean(values_j)
		# summary_fitted[j,t] = median(values_j)
		# summary_fitted[j,t] = Mode(values_j) # function from include.R
	}
}
yredJ=summary_fitted
# take last sample (maybe not the best choice)
# yredJ=t(rout$fitted[,,size(rout$fitted)[3]])
#################################################################
yredORIGI=y

#################################################################
MSE_matrices(yredC,yredORIGI)
# MSE_matrices(yredC,yredJ)
MSE_matrices(yredJ,yredORIGI)
```


## ari pairwise
```{r,warning=F}
LEN = Tm
compare_ARI = function(Cmod1,Jmod2){
	ARIvec <- matrix(NA, nrow=1, ncol=LEN)
	for(k in 1: LEN){
		rhoC = generate_partition(Cmod1)
		rhoJ = generate_partition(Jmod2)
		ARIvec[k] <- adjustedRandIndex(rhoC[[k]][1:N], rhoJ[[k]][1:N])
	}	
	ncols_ari = 100
	cols_ARI = colora(ncols_ari,79,0)
	# cols_ARI = rev(cols_ARI)
	brks = seq(-1,1,length.out=ncols_ari+1)
	# pdf(paste0("./figures/DRPM/ARI/ari.pdf"), height=8, width=10)
	# svg(paste0("./figures/",base_folder,"/ARI/ari.svg"), height=8, width=10)
	# png(paste0("./figures/",base_folder,"/ARI/ari.png"),  width=700,height=600)
	library(fields)
	plot(1:Tm,ARIvec,type="l",main=paste0("ARI values"),ylim=c(-0.5,1))
	abline(h=0,col="gray80",lty=3)
	
	# image.plot(ARIvec,
	# 		   main=paste0("ARI values - ",mod1," vs ",mod2),axes=FALSE,col=cols_ARI,
	# 		   breaks=brks)
	# mtext(text=c(paste("",1:LEN)), side=2, line=0.3,at=seq(0,1,length=LEN), las=1, cex=0.8)

}

mods = c("DRPM","sPPM","Gaussian PPMx","Curve PPMx")
Cmod1 = drpm1
Jmod2 = rout
compare_ARI(Cmod1,Jmod2)
```


# ==========

# 2. SPACE DATA
Spatio-temporal data set with rural background PM10 concentrations in Germany 2005
```{r}
currwd = getwd()
setwd("C:/Users/feder/Desktop/Uni magistrale/Tesi/src/test/Supplementary material/")
source("Functions.R")
library(salso)
# library(drpm)
library(MCMCpack)
library(mclust)

# This data is found in the gstat package
library(gstat)
data(DE_RB_2005)
dat <- DE_RB_2005

# Create ymat with columns corresponding to time rows stations
N <- length(dat@sp)
Tm <- 365
y <- matrix(NA, nrow=N, ncol=Tm)
for(i in 1:Tm){
	y[dat@index[dat@index[,2]==i,1], i] <- dat@data[dat@index[,2]==i,1]
}

# Try to create an average PM10 per month
year <- c(rep(1,31),rep(2,28),rep(3,31),rep(4,30),rep(5,31),
         rep(6,30),rep(7,31),rep(8,31),rep(9,30),rep(10,31),
         rep(11,30),rep(12,31))
week <- rep(1:52, each=7)
ymn <- t(apply(y, 1, function(x) tapply(x,year,mean, na.rm=TRUE)))


## Keep those that don't have any missing values when overageing over a month
ysub2 <- ymn[-c(4,16,25,27,30,43,52,59,69),]


mn <- apply(ysub2,2,mean)
sd <- apply(ysub2,2,sd)

# Center the observations
y <- t(t(ysub2) - mn)

Tm = tps <- ncol(y) # time span
N = size(y)[1] # number of units

s_coords <- (dat@sp@coords)[-c(4,16,25,27,30,43,52,59,69),]
smn <- apply(s_coords,2,mean)
ssd <- apply(s_coords,2,sd)
s_std <- t((t(s_coords) - smn)/ssd)
setwd(currwd)

cat(size(y),"\n")
cat("N =",N,"\n")
cat("T =",Tm,"\n")
### subset test
# sub_k = 1
# y = y[1:sub_k,]
# s_std = s_std[1:sub_k,]

cols = colora(len=size(y)[1],56,0)
# original real data
for(i in 1:size(y)[1]){
   if(i==1){
     plot(1:size(y)[2],y[i,],col=cols[i],type='l',
     	 xlab='time',ylab='values',main="original data",
     	 ylim=extrema(y))
 	  } 
	  else{
		  lines(1:size(y)[2],y[i,],col=cols[i])
	  }
}
```

## Fits
```{r}
# as.integer(runif(1,0,1000))*1.0
# seed = 881.0
seed = 314.0
cat("seed",seed,"\n")

# niter=50000; nburn=34000; nthin=8
# niter=30000; nburn=22000; nthin=8
niter=50000; nburn=30000; nthin=20
# niter=2000; nburn=1000; nthin=2
# niter=10000; nburn=8000; nthin=2
nout <- (niter-nburn)/nthin
cat(nout,"valid iterations\n")
```


```{r}
# params
m0_phi0 = 0
s20_phi0 = 10
A_ub_sigma = 5
A_ub_tau = 5
A_ub_lambda = 5

a_sigma  = 2; b_sigma  = 3
a_tau    = 2; b_tau    = 3
a_lambda = 2; b_lambda = 3
eta1_scale = 1

sig_mh_sig2 = 0.3
sig_mh_tau2 = 0.3
sig_mh_lambda2 = 0.3
sig_mh_eta1 = 0.1
sig_mh_phi1 = 0.1

update_eta1 = TRUE
update_phi1 = TRUE

a_alpha = 2; b_alpha = 2

# now space
spatial_cohesion = 3
mu0 = 0 
k0 = 1
v0 = 5
L0 = 1
```

## drpm C
```{r}
tempo_inizio <- Sys.time()
drpm1 <- drpm_fit(
		y=y, 
		s_coords = s_std,
        M=1,
        initial_partition = NULL,
		
        starting_alpha = 0.5,
        unit_specific_alpha = FALSE,
        time_specific_alpha = TRUE,
        alpha_0=FALSE,
		
        eta1_0=!(update_eta1),
        phi1_0=!(update_phi1),
        # modelPriors=c(0,100^2,1,1,1,1), # original default one
        modelPriors=c(m0_phi0,s20_phi0,A_ub_sigma,A_ub_tau,A_ub_lambda,eta1_scale),

        alphaPriors=rbind(c(a_alpha,b_alpha)), # if time_specific_alpha == TRUE
        
        simpleModel = 0,
        theta_tau2 = c(0, 2), # only used if simpleModel=1

		SpatialCohesion=spatial_cohesion, # auxiliary similarity
		# SpatialCohesion=4, # double dipper similarity
		cParms=c(mu0, k0, v0, L0),
		
		mh=c(sig_mh_sig2,sig_mh_tau2,sig_mh_lambda2,sig_mh_eta1,sig_mh_phi1),
		verbose=TRUE,
		draws=niter,burn=nburn,thin=nthin)

tempo_fine <- Sys.time()
differenza_tempo <- tempo_fine - tempo_inizio
cat(crayon::cyan("Fit took:\n"))
print(round(differenza_tempo,digits = 4))

cat(crayon::red("\nLPML =",drpm1$lpml, "\nWAIC =",drpm1$waic))
```

```{r}
names(drpm1)

cat("\nSi     size = ",size(drpm1$Si),"\n")
cat("gamma  size = ",size(drpm1$gamma),"\n")
cat("mu     size = ",size(drpm1$mu),"\n")
cat("sig2   size = ",size(drpm1$sig2),"\n")
cat("alpha  size = ",size(drpm1$alpha),"\n")
cat("theta  size = ",size(drpm1$theta),"\n")
cat("tau2   size = ",size(drpm1$tau2),"\n")
cat("eta1   size = ",size(drpm1$eta1),"\n")
cat("phi0   size = ",size(drpm1$phi0),"\n")
cat("phi1   size = ",size(drpm1$phi1),"\n")
cat("lam2   size = ",size(drpm1$lam2),"\n")
cat("llike  size = ",size(drpm1$llike),"\n")
cat("fitted size = ",size(drpm1$fitted),"\n")
```

senza inbounds
done!
Elapsed time: 5 minutes, 20 seconds, 382 milliseconds
LPML: -1462.288259753217 (the higher the better)
WAIC: 2654.844561442508 (the lower the better)

con inbounds
done!
Elapsed time: 5 minutes, 10 seconds, 745 milliseconds
LPML: -1462.288259753217 (the higher the better)
WAIC: 2654.844561442508 (the lower the better)


## drpm J
```{r}
module_JDRPM <- juliaImport(juliaCall("include", module))
out = module_JDRPM$MCMC_fit(
	Y=as.matrix(y),              
	sp_coords = s_std,
	M_dp = 1,                     
	initial_partition = NA,
	Xlk_covariates = NA,
	Xcl_covariates = NA,
	
	starting_alpha = 0.5,         
	unit_specific_alpha = FALSE,       
	time_specific_alpha = TRUE,       
	update_alpha = TRUE,             
	
	include_eta1 = TRUE,                    
	include_phi1 = TRUE,
	update_eta1 = update_eta1,                    
	update_phi1 = update_phi1,
	
	sig2h_priors = c(a_sigma,b_sigma),
	eta1_priors = c(eta1_scale,sig_mh_eta1),
	# beta_priors = c(rep(1,p),2),
	beta_priors = NA,
	tau2_priors = c(a_tau,b_tau),
	phi0_priors = c(m0_phi0,s20_phi0),
	phi1_priors = sig_mh_phi1,
	lambda2_priors = c(a_lambda,b_lambda),
	alpha_priors = c(a_alpha,b_alpha),  
	
	spatial_cohesion_idx = spatial_cohesion,
	sp_params = list(c(mu0,mu0),k0,v0,matrix(c(L0,0.0,0.0,L0),nrow=2)),
	
	# spatial_cohesion_idx = 1,
	# sp_params = list(0.1),
	
	# covariate_similarity_idx = NA,
	# draws = 2000,burnin = 0, thin = 1,
	draws = niter,burnin = nburn, thin = nthin,
	logging = FALSE,
	seed = seed,
	simple_return = FALSE
)
```


```{r}
#### if simple_return is TRUE
rout = juliaGet(out)
names(rout) = c("Si","lpml","waic")
rout$Si = aperm(rout$Si, c(2, 1, 3))

#### if simple_return is FALSE
rout = juliaGet(out)
names(rout)  = c("Si",
				 "gamma",
				 "alpha", 
				 "sigma2h", 
				 "muh", 
				 "eta1",
				 "beta",
				 "theta", 
				 "tau2", 
				 "phi0", 
				 "phi1",
				 "lambda2",
				 "fitted",
				 "llike",
				 "lpml",
				 "waic")

# reshape some stuff to uniform it to drpm output
rout$Si           = aperm(rout$Si,       c(2, 1, 3))
rout$gamma        = aperm(rout$gamma,    c(2, 1, 3))
rout$sigma2h      = aperm(rout$sigma2h,  c(2, 1, 3))
rout$muh          = aperm(rout$muh,      c(2, 1, 3))
rout$fitted       = aperm(rout$fitted,   c(2, 1, 3))
rout$llike        = aperm(rout$llike,    c(2, 1, 3))
rout$alpha        = aperm(rout$alpha,    c(2, 1))
rout$theta        = aperm(rout$theta,    c(2, 1))
rout$tau2         = aperm(rout$tau2,     c(2, 1))
rout$eta1         = aperm(rout$eta1,    c(2, 1))
rout$phi0     = matrix(rout$phi0,    ncol = 1)
rout$phi1     = matrix(rout$phi1,    ncol = 1)
rout$lambda2  = matrix(rout$lambda2, ncol = 1)
cat(crayon::red("\nLPML =",rout$lpml, "\nWAIC =",rout$waic))
```
```{r}
names(rout)

cat("Si           size = ",size(rout$Si),"\n")
cat("gamma        size = ",size(rout$gamma),"\n")
cat("sigma2h      size = ",size(rout$sigma2h),"\n")
cat("muh          size = ",size(rout$muh),"\n")
cat("alpha        size = ",size(rout$alpha),"\n")
cat("theta        size = ",size(rout$theta),"\n")
cat("tau2         size = ",size(rout$tau2),"\n")
cat("eta1         size = ",size(rout$eta1),"\n")
cat("phi0         size = ",size(rout$phi0),"\n")
cat("phi1         size = ",size(rout$phi1),"\n")
cat("lambda2      size = ",size(rout$lambda2),"\n")
cat("beta         size = ",size(rout$beta),"\n")
cat("fitted       size = ",size(rout$fitted),"\n")
cat("llike        size = ",size(rout$llike),"\n")

cat("lpml = ",rout$lpml,"\n")
cat("waic = ",rout$waic,"\n")
```

```{r}
# save(drpm1, rout, file = "ran_section2_withspace_30k22b8t_of0409.Rdata")
load(file = "ran_section2_withspace_30k22b8t_of0409.Rdata")
```


## Trace plots
### alpha
```{r}
for (time in 1:Tm){
		par(mfrow=c(1,2),mar=c(2,2,4,2))

plot(drpm1$alpha[,time],type="l",
	 main=bquote("Model DRPM C\nTrace plot of alpha at time "*.(time)
	 ), ylim=c(0,1),
	 xlab = "MCMC iterations",ylab="values")
plot(rout$alpha[,time],type="l",
	 main=bquote("Model DRPM J\nTrace plot of alpha at time "*.(time)
	 ), ylim=c(0,1),
	 xlab = "MCMC iterations",ylab="values")
}
```
### mu
```{r}
size(drpm1$mu)
size(rout$muh)
unitj = 1
for (time in 1:Tm){
		par(mfrow=c(1,2),mar=c(2,2,4,2))

	plot(drpm1$mu[time,unitj,],type="l",
		 ylim=c(min(drpm1$mu[time,unitj,],rout$muh[time,unitj,]),
		 	   max(drpm1$mu[time,unitj,],rout$muh[time,unitj,])),
		 main=bquote("Model DRPM C\nTrace plot of mu at time "*.(time) * " unit " * .(unitj)),
		 xlab = "MCMC iterations",ylab="values")
	plot(rout$muh[time,unitj,],type="l",
		 ylim=c(min(drpm1$mu[time,unitj,],rout$muh[time,unitj,]),
		 	   max(drpm1$mu[time,unitj,],rout$muh[time,unitj,])),
		 main=bquote("Model DRPM J\nTrace plot of mu at time "*.(time) * " unit " * .(unitj)),
		 xlab = "MCMC iterations",ylab="values")
}
```

### sigma2
```{r}
size(drpm1$sig2)
size(rout$sigma2h)
unitj = 1
for (time in 1:Tm){
		par(mfrow=c(1,2),mar=c(2,2,4,2))

	plot(drpm1$sig2[time,unitj,],type="l",
		 main=bquote("Model DRPM C\nTrace plot of sigma2 at time "*.(time) * " unit " * .(unitj)),
		 ylim=c(0,max(drpm1$sig2[time,unitj,], rout$sigma2h[time,unitj,])),
		 xlab = "MCMC iterations",ylab="values")
	plot(rout$sigma2h[time,unitj,],type="l",
		 main=bquote("Model DRPM J\nTrace plot of sigma2 at time "*.(time) * " unit " * .(unitj)),
		 ylim=c(0,max(drpm1$sig2[time,unitj,], rout$sigma2h[time,unitj,])),
		 xlab = "MCMC iterations",ylab="values")
}
```

### eta1
```{r}
dim(drpm1$eta1)
dim(rout$eta1)

cat("did we update eta1?", update_eta1)
for (unit in 1:N){
	par(mfrow=c(1,2),mar=c(2,2,4,2))
	plot(drpm1$eta1[,unit],type="l",
		 ylim=c(min(drpm1$eta1[,unit],rout$eta1[,unit]),
		 	    max(drpm1$eta1[,unit],rout$eta1[,unit])),
		 main=bquote("Model DRPM C\nTrace plot of eta1 at unit "*.(unit)),
		 xlab = "MCMC iterations",ylab="values")
	plot(rout$eta1[,unit],type="l",
		 ylim=c(min(drpm1$eta1[,unit],rout$eta1[,unit]),
		 	    max(drpm1$eta1[,unit],rout$eta1[,unit])),
		 main=bquote("Model DRPM J\nTrace plot of eta1 at unit "*.(unit)),
		 xlab = "MCMC iterations",ylab="values")
}
```


### theta
```{r}
for (time in 1:Tm){
	par(mfrow=c(1,2),mar=c(2,2,4,2))
	plot(drpm1$theta[,time],type="l",
		  ylim=c(min(drpm1$theta[,time],rout$theta[,time]),
		 	    max(drpm1$theta[,time],rout$theta[,time])),
		 main=bquote("Model DRPM C\nTrace plot of theta at time "*.(time)),
		 xlab = "MCMC iterations",ylab="values")
	plot(rout$theta[,time],type="l",
		  ylim=c(min(drpm1$theta[,time],rout$theta[,time]),
		 	    max(drpm1$theta[,time],rout$theta[,time])),
		 main=bquote("Model DRPM J\nTrace plot of theta at time "*.(time)),
		 xlab = "MCMC iterations",ylab="values")
}
```

### tau2
```{r}
dim(drpm1$tau2)
dim(rout$tau2)

for (time in 1:Tm){
	par(mfrow=c(1,2),mar=c(2,2,4,2))
	plot(drpm1$tau2[,time],type="l",
		 ylim=c(0,max(drpm1$tau2[,time],rout$tau2[,time])),
		 main=bquote("Model DRPM C\nTrace plot of tau2 at time "*.(time)),
		 xlab = "MCMC iterations",ylab="values")
	plot(rout$tau2[,time],type="l",
		 ylim=c(0,max(drpm1$tau2[,time],rout$tau2[,time])),
		 main=bquote("Model DRPM J\nTrace plot of tau2 at time "*.(time)),
		 xlab = "MCMC iterations",ylab="values")
}
```


### layer three
phi1, phi0, lambda2
```{r}
dim(drpm1$phi1)
dim(rout$phi1)

cat("did we update phi1?", update_phi1)
par(mfrow=c(1,2),mar=c(2,2,4,2))
plot(drpm1$phi1[,1],type="l",
	  ylim=c(min(drpm1$phi1[,1],rout$phi1[,1]),
		 	    max(drpm1$phi1[,1],rout$phi1[,1])),
	 main=bquote("Model DRPM C\nTrace plot of phi1"),
	 xlab = "MCMC iterations",ylab="values")
plot(rout$phi1[,1],type="l",
	  ylim=c(min(drpm1$phi1[,1],rout$phi1[,1]),
		 	    max(drpm1$phi1[,1],rout$phi1[,1])),
	 main=bquote("Model DRPM J\nTrace plot of phi1"),
	 xlab = "MCMC iterations",ylab="values")

dim(drpm1$phi0)
dim(rout$phi0)

par(mfrow=c(1,2),mar=c(2,2,4,2))
plot(drpm1$phi0[,1],type="l",
	 	  ylim=c(min(drpm1$phi0[,1],rout$phi0[,1]),
		 	    max(drpm1$phi0[,1],rout$phi0[,1])),
	 main=bquote("Model DRPM C\nTrace plot of phi0"),
	 xlab = "MCMC iterations",ylab="values")
plot(rout$phi0[,1],type="l",
	 	  ylim=c(min(drpm1$phi0[,1],rout$phi0[,1]),
		 	    max(drpm1$phi0[,1],rout$phi0[,1])),
	 main=bquote("Model DRPM J\nTrace plot of phi0"),
	 xlab = "MCMC iterations",ylab="values")


dim(drpm1$lam2)
dim(rout$lambda2)

par(mfrow=c(1,2),mar=c(2,2,4,2))
plot(drpm1$lam2[,1],type="l",
	 	  ylim=c(min(drpm1$lam2[,1],rout$lambda2[,1]),
		 	    max(drpm1$lam2[,1],rout$lambda2[,1])),
	 main=bquote("Model DRPM C\nTrace plot of lambda2"),
	 xlab = "MCMC iterations",ylab="values")
plot(rout$lambda2[,1],type="l",
	 	  ylim=c(min(drpm1$lam2[,1],rout$lambda2[,1]),
		 	    max(drpm1$lam2[,1],rout$lambda2[,1])),
	 main=bquote("Model DRPM J\nTrace plot of lambda2"),
	 xlab = "MCMC iterations",ylab="values")
```




## Partition plots
```{r, warning=F}
maxNClusters = 3

# partition_plots = function(drpm1, rout){ 
# Initialize a list to store the partitions for each time instant
partitions_drpmc <- list()
partitions_drpmj <- list()

# Loop over each time instant to extract the consensus partition
for (t in 1:Tm) {
  Sic_t <- drpm1$Si[t, , ]
  Sic_t <- t(Sic_t) 
  partitions_drpmc[[t]] <- salso(Sic_t, loss = "binder"
  							   # , maxNClusters = maxNClusters
  							   )

  Sij_t <- rout$Si[t, , ]
  Sij_t <- t(Sij_t) 
  partitions_drpmj[[t]] <- salso(Sij_t, loss = "binder"
  							   # , maxNClusters = maxNClusters
  							   )
}
maxk = 0
cat(crayon::red("DRPM - C\n"))
for (t in 1:Tm){
	cat("Time",t,"- #clusters =",length(unique(partitions_drpmc[[t]])),"\n")
	maxk = max(length(unique(partitions_drpmc[[t]])),maxk)
}
cat("\n")
cat(crayon::red("DRPM - J\n"))
for (t in 1:Tm){
	cat("Time",t,"- #clusters =",length(unique(partitions_drpmj[[t]])),"\n")
	maxk = max(length(unique(partitions_drpmj[[t]])),maxk)
}
```


```{r, warning=F}
# cols=colora(len=maxk, seed=67, show=1)
# cols=colora(len=maxk, seed=41, show=0) # greens/light-blues
# cols=colora(len=maxk, seed=73, show=0) # dark blues
# cols=colora(len=maxk, seed=32, show=0) # viridis
# cols=colora(len=maxk, seed=22, show=0) # reds/blues
# cols=colora(len=maxk, seed=44, show=0) # greens
cols=colora(len=maxk, seed=56, show=0) # la 56
# cols = colora(len=10,"rand")

heatmap_matrix <- do.call(rbind, partitions_drpmc)
# Generate the heatmap
heatmap(heatmap_matrix, Rowv = NA, Colv = NA, scale = "none",
		main="model C", xlab = "units", ylab = "time instants",
        # col = terrain.colors(length(unique(as.vector(heatmap_matrix)))))
		col = cols)
heatmap_matrix <- do.call(rbind, partitions_drpmj)
# Generate the heatmap
heatmap(heatmap_matrix, Rowv = NA, Colv = NA, scale = "none",
		main="model J",xlab = "units", ylab = "time instants",
        # col = terrain.colors(length(unique(as.vector(heatmap_matrix)))))
		col = cols)

####################################################################

partitions = partitions_drpmc
partition_matrix <- do.call(cbind, partitions)
num_units <- nrow(partition_matrix)
Tm <- ncol(partition_matrix)
# Set up the plot
par(mar=c(4,4,2,2))
plot(1:Tm, rep(NA, Tm), type = "n",
     xlab = "Time Instants", ylab = "clusters", main="model C",
     ylim = range(partition_matrix)+c(-0.1,0.1), xaxt = "n", yaxt = "n")
axis(1, at = 1:Tm, labels = 1:Tm)
axis(2, at = unique(as.vector(partition_matrix)), las = 2)
# Add grid lines for clarity
abline(h = unique(as.vector(partition_matrix)), col = "lightgray", lty = "dotted")
abline(v = 1:Tm, col = "lightgray", lty = "dotted")
# Plot lines and points for each unit
for (unit in 1:num_units) {
  lines(1:Tm, partition_matrix[unit, ], type = "l", pch = 19,
        col = unit, lwd = 1)
}
# legend("topright", legend = paste("Unit", 1:num_units), col = 1:num_units,
       # lty = 1, lwd = 2, pch = 19, bty = "n")


partitions = partitions_drpmj
partition_matrix <- do.call(cbind, partitions)
num_units <- nrow(partition_matrix)
Tm <- ncol(partition_matrix)
# Set up the plot
par(mar=c(4,4,2,2))
plot(1:Tm, rep(NA, Tm), type = "n",
     xlab = "Time Instants", ylab = "clusters", main="model J",
     ylim = range(partition_matrix)+c(-0.1,0.1), xaxt = "n", yaxt = "n")
axis(1, at = 1:Tm, labels = 1:Tm)
axis(2, at = unique(as.vector(partition_matrix)), las = 2)
abline(h = unique(as.vector(partition_matrix)), col = "lightgray", lty = "dotted")
abline(v = 1:Tm, col = "lightgray", lty = "dotted")
for (unit in 1:num_units) {
  lines(1:Tm, partition_matrix[unit, ], type = "l", pch = 19,
        col = unit, lwd = 1)
}
# legend("topright", legend = paste("Unit", 1:num_units), col = 1:num_units,
       # lty = 1, lwd = 2, pch = 19, bty = "n")


####################################################################

partitions = partitions_drpmc
partition_matrix <- do.call(cbind, partitions)
par(mar=c(3.8,1,3,1),mfrow=c(1,2))
plot(NULL, NULL, xlim = c(1, Tm), ylim = c(1, num_units)+c(-0.5,0.5),
     xlab = "Time Instants", ylab = "Units",
     xaxt = "n", yaxt = "n", main = "model C")
axis(1, at = 1:Tm, labels = 1:Tm)
for (t in 1:Tm) {
  for (unit in 1:num_units) {
    text(x = t, y = unit, labels = as.character(unit),
         col = partition_matrix[unit, t], cex = 0.5)
  }
}

partitions = partitions_drpmj
partition_matrix <- do.call(cbind, partitions)
plot(NULL, NULL, xlim = c(1, Tm), ylim = c(1, num_units)+c(-0.5,0.5),
     xlab = "Time Instants", ylab = "Units",
     xaxt = "n", yaxt = "n", main = "model J")
axis(1, at = 1:Tm, labels = 1:Tm)
for (t in 1:Tm) {
  for (unit in 1:num_units) {
    text(x = t, y = unit, labels = as.character(unit),
         col = partition_matrix[unit, t], cex = 0.5)
  }
}
```
## Ari plot
```{r warning=FALSE}
LEN = Tm
##########################
model_name = "model C"
partition = partitions_drpmc
##########################

df_cluster = data.frame(clusters=c(),Time=c())
for(time in 1:Tm){
	salso_out <- partition[[time]]
	df_temp = data.frame(
		clusters = salso_out
	)
	df_temp$Time = rep(time,dim(df_temp)[1])
	df_cluster = rbind(df_cluster,df_temp)
	
	# clusters log
	clusters_now = df_temp$clusters
	n_clusters = unique(clusters_now)
	cat(crayon::red("Time",time,"- #clusters =",length(unique(clusters_now)),"\n"))
}
library(mclust)
# build the ARI matrix
ARImats <- matrix(NA, nrow=LEN, ncol=LEN)
rho_ARI <- list()
for(k in 1:LEN){
	rho_ARI[[k]] <- partition[[k]]
}
for(k in 1: LEN){
	for(kk in 1: LEN){
		ARImats[k,kk] <- adjustedRandIndex(rho_ARI[[k]], rho_ARI[[kk]])
	}
}
ncols_ari = 100
# if (min(ARImats)<0){
	# cols_ARI = colora(ncols_ari,79,0)
	# brks = seq(min(-1,floor(min(ARImats))),1,length.out=ncols_ari+1)
# } else {
	# cols_ARI = colora(ncols_ari,56,0)
	# cols_ARI = rev(cols_ARI) # must be ordered from cold to warm
	cols_ARI = rev(colora(ncols_ari,104,0)) # or 109
	# cols_ARI = colora(ncols_ari,102,0)
	# brks = seq(0,1,length.out=ncols_ari+1)
	brks = seq(min(-1,floor(min(ARImats))),1,length.out=ncols_ari+1)
# }
# or see ?designer.colors for colors
library(fields)
image.plot(ARImats,
		   main=paste0("Lagged ARI values - ",model_name),axes=FALSE,col=cols_ARI,
		   breaks=brks)
mtext(text=c(paste("",1:LEN)), side=2, line=0.3,at=seq(0,1,length=LEN), las=1, cex=0.8)
mtext(text=c(paste("",1:LEN)), side=1, line=0.3,at=seq(0,1,length=LEN), las=2, cex=0.8)

##########################
model_name = "model J"
partition = partitions_drpmj
##########################

df_cluster = data.frame(clusters=c(),Time=c())
for(time in 1:Tm){
	salso_out <- partition[[time]]
	df_temp = data.frame(
		clusters = salso_out
	)
	df_temp$Time = rep(time,dim(df_temp)[1])
	df_cluster = rbind(df_cluster,df_temp)
	
	# clusters log
	clusters_now = df_temp$clusters
	n_clusters = unique(clusters_now)
	cat(crayon::red("Time",time,"- #clusters =",length(unique(clusters_now)),"\n"))
}
library(mclust)
# build the ARI matrix
ARImats <- matrix(NA, nrow=LEN, ncol=LEN)
rho_ARI <- list()
for(k in 1:LEN){
	rho_ARI[[k]] <- partition[[k]]
}
for(k in 1: LEN){
	for(kk in 1: LEN){
		ARImats[k,kk] <- adjustedRandIndex(rho_ARI[[k]], rho_ARI[[kk]])
	}
}
ncols_ari = 100
# if (min(ARImats)<0){
	# cols_ARI = colora(ncols_ari,79,0)
	# brks = seq(min(-1,floor(min(ARImats))),1,length.out=ncols_ari+1)
# } else {
	# cols_ARI = colora(ncols_ari,56,0)
	# cols_ARI = rev(cols_ARI) # must be ordered from cold to warm
	cols_ARI = rev(colora(ncols_ari,104,0)) # or 109
	# cols_ARI = colora(ncols_ari,102,0)
	# brks = seq(0,1,length.out=ncols_ari+1)
	brks = seq(min(-1,floor(min(ARImats))),1,length.out=ncols_ari+1)
# }
# or see ?designer.colors for colors
library(fields)
image.plot(ARImats,
		   main=paste0("Lagged ARI values - ",model_name),axes=FALSE,col=cols_ARI,
		   breaks=brks)
mtext(text=c(paste("",1:LEN)), side=2, line=0.3,at=seq(0,1,length=LEN), las=1, cex=0.8)
mtext(text=c(paste("",1:LEN)), side=1, line=0.3,at=seq(0,1,length=LEN), las=2, cex=0.8)

##########################################################

# take last sample (maybe not the best choice)
yredC=t(drpm1$fitted[,,size(drpm1$fitted)[3]])
yredJ=t(rout$fitted[,,size(rout$fitted)[3]])
yred=y

cols = colora(size(yred)[1],56,0)
# cols = colora(size(yred)[1],"div",show = 0)

par(mar=c(4,4,4,2))
for(i in 1:size(yredC)[1]){
   if(i==1){
     plot(1:size(yredC)[2],yredC[i,],col=cols[i],
     	 ylim=extrema(yred,yredJ,yredC),
     	 type='l',xlab='time',ylab="fitted values",main="model C")
 	  } 
	  else{
		  lines(1:size(yredC)[2],yredC[i,],col=cols[i])
	  }
}

par(mar=c(4,4,4,2))
for(i in 1:size(yredJ)[1]){
   if(i==1){
     plot(1:size(yredJ)[2],yredJ[i,],col=cols[i],
     	 ylim=extrema(yred,yredJ,yredC),
     	 type='l',xlab='time',ylab="fitted values",main="model J")
 	  } 
	  else{
		  lines(1:size(yredJ)[2],yredJ[i,],col=cols[i])
	  }
}

# original real data
for(i in 1:size(yred)[1]){
   if(i==1){
     plot(1:size(yred)[2],yred[i,],col=cols[i],type='l',
     	 xlab='time',ylab='values',main="original data",
     	 ylim=extrema(yred,yredJ,yredC))
 	  } 
	  else{
		  lines(1:size(yred)[2],yred[i,],col=cols[i])
	  }
}
```

## salso plots
```{r}
##########################
model_name = "model C"
partition = partitions_drpmc
##########################

par(mar=c(1,1,1,1))
for (time in 1:Tm){
	salso_out = partition[[time]]
	ssout = summary(salso_out)
	# plot(ssout,type="heatmap")
	# plot(ssout,type="mds")
	plot(ssout,type="pairs",data=s_std)
	text(0.3,0.91,pos=3,paste0(model_name," - Time ",time))
	# plot(ssout,type="dendrogram")
	# dev.off()
}
```

```{r}
##########################
model = "J"
partition = partitions_drpmj
# model = "C"
# partition = partitions_drpmc
##########################
par(mfrow=c(3,4),mar=c(1,1,2,1),oma=c(1,1,1,1))
# cols = rainbow(12)
for (time in 1:Tm){
	plot(s_std,pch=19,
		 # col=cols[partition[[time]]],
		 col=partition[[time]],
		 xlab="",ylab="",
		 axes = F,
		 cex=pmax(y[, time]/6, rep(0.5, N)),
		 main=paste0(model," at t=",time))
}
```



# ==========

# 3. PM10 DATA
of the bayesian project

## covariates inspection
```{r}
numerical_covariates = c(
	"Altitude"
	,"WE_temp_2m"
	,"WE_wind_speed_10m_mean"
	,"WE_wind_speed_10m_max"
	# ,"WE_mode_wind_direction_10m"
	, "WE_tot_precipitation"
	# ,"WE_precipitation_t" # t was for type, categorical
	,"WE_surface_pressure"
	,"WE_solar_radiation"
	,"WE_rh_min"
	,"WE_rh_mean"
	,"WE_rh_max"
	,"WE_wind_speed_100m_mean"
	,"WE_wind_speed_100m_max"
	# ,"WE_mode_wind_direction_100m"
	,"WE_blh_layer_max"
	,"WE_blh_layer_min"
	,"EM_nh3_livestock_mm"
	,"EM_nh3_agr_soils"
	,"EM_nh3_agr_waste_burn"
	,"EM_nh3_sum"
	,"EM_nox_traffic"
	,"EM_nox_sum"
	,"EM_so2_sum"
	,"LI_pigs"
	,"LI_bovine"
	,"LI_pigs_v2"
	,"LI_bovine_v2"
	,"LA_hvi"
	,"LA_lvi"
	,"LA_land_use"
	# ,"day"
	# ,"week"
	)

Tm_cor_comp = 53

yfull=data.frame()
for(st in stations){
	y_we_pm10=cbind(as.data.frame(st),t(df_wsc[which(df_wsc$IDStations==st),"AQ_pm10"]))
	yfull=rbind(yfull,y_we_pm10)
}
rownames(yfull) = NULL
colnames(yfull)<- c("id",paste0("w", 1:53))

time_span = 1:53
nsubjects = 1:105
y = yfull[nsubjects,1+time_span]

cor_matrix <- matrix(NA, nrow=length(numerical_covariates), ncol=Tm_cor_comp)
rownames(cor_matrix) <- numerical_covariates
colnames(cor_matrix) <- paste("Time", 1:Tm_cor_comp, sep="_")

# Loop over the covariates and time points
for (t in 1:Tm_cor_comp) {
	df_at_t = df_wsc[which(df_wsc$Time==unique(df_wsc$Time)[t]),]
  for (i in 1:length(numerical_covariates)) {
    covariata <- numerical_covariates[i]
    cor_matrix[i, t] <- cor(df_at_t[[covariata]], y[, t])
    # y[,t] represents the PM10 values at time t
  }
}
```


```{r}
size(cor_matrix)

ncols_ari = 100
cols_ARI = rev(colora(ncols_ari,104,0)) # or 109
brks = seq(min(-1,floor(min(cor_matrix))),1,length.out=ncols_ari+1)
	
# pdf("cova.pdf",height = 6.3,width = 10)
par(mar=c(2,9,2,1))

library(fields)
image.plot(t(cor_matrix),
		   main="Correlation between Covariates and PM10 values",axes=F,col=cols_ARI,
		   breaks=brks)

# mtext(text=c(paste("",1:size(cor_matrix)[1])), side=2, 
mtext(text=numerical_covariates[1:size(cor_matrix)[1]], side=2, 
	  line=0.3,at=seq(0,1,length=size(cor_matrix)[1]), las=1, cex=0.7)
mtext(text=c(paste("",1:size(cor_matrix)[2])), side=1, 
	  line=0.3,at=seq(0,1,length=size(cor_matrix)[2]), las=2, cex=0.8)

# dev.off()
```

```{r}
pdf("heatmap_covariate_cor.pdf",width = 25, height = 20)

# layout(matrix(c(1,0,0,2), 2, 2, byrow = TRUE),
# 	   widths = c(1,1,4,4), heights =c(1,1,4,4))

library(gplots)
heatmap.2(cor_matrix, 
          Rowv=NA, Colv=NA, 
          dendrogram="none", 
          trace="none", 
          # col=colorRampPalette(c("blue", "white", "red"))(100),
		  col = rev(colora(100,seed=104,0)),
		  key=TRUE,
		  key.title="Correlation", key.xlab="Value",
          density.info="none", 
          margins=c(6, 12),  # Adjust margins to fit labels
          cellnote=round(cor_matrix, 1),  # Display correlation values in cells
          notecol="black",  # Color of the text in cells
          # notecol="white",  # Color of the text in cells
          xlab="Time", ylab="Covariates",
          main="Correlation Heatmap",
		  )
dev.off()
```



```{r}
numerical_covariates_focus = c("WE_temp_2m",
							   "Altitude",
							   "WE_wind_speed_10m_mean",
								"EM_nh3_sum"
							   )
for (covariata in numerical_covariates_focus) {
	for (t in 1:Tm){
		df_at_t = df_wsc[which(df_wsc$Time==unique(df_wsc$Time)[t]),]
		
		par(mar=c(2,4,2,0))
			plot(df_at_t[[covariata]], y[,t],
				 ylab="PM10 values",
				 xlab="",
				 main=paste(covariata,"- Correlation:",
				 		   round(cor(df_at_t[[covariata]],y[,t]),2),
				 		   "- time",t)
				 )
		}
}
```


## real PM10 data
```{r}
sites = data.frame(
	longitude = unique(df_weekly$Longitude), 
	latitude = unique(df_weekly$Latitude))
std_sites = data.frame(
	longitude = unique(df_wsc$Longitude), 
	latitude = unique(df_wsc$Latitude))
stations = unique(df_wsc$IDStations)
yfull=data.frame()

target = "AQ_pm10"
# target = "WE_tot_precipitation"

for(st in stations){
	y_we_pm10=cbind(as.data.frame(st),t(df_wsc[which(df_wsc$IDStations==st),target]))
	yfull=rbind(yfull,y_we_pm10)
}
rownames(yfull) = NULL
colnames(yfull)<- c("id",paste0("w", 1:53))

time_span = 1:2 # low time span for quick testing, real one will be 1:53

### alcuni a caso:
# quanti = 7; nsubjects = sample(1:105, quanti,replace = F)
### alcuni:
# nsubjects = 1:10
### tutti:
nsubjects = 1:105

y = yfull[nsubjects,1+time_span]

#############################################
# authors suggested to/did scale the spatial locations and also centered the observations

mn <- apply(y,2,mean)
sd <- apply(y,2,sd)

y <- t(t(y) - mn)

Tm = tps <- ncol(y) # time span
N = size(y)[1] # number of units
num_units = N

sites = sites[nsubjects,]
smn <- apply(sites,2,mean)
ssd <- apply(sites,2,sd)
s_std <- t((t(sites) - smn)/ssd)
########################################

yred=y[,time_span]
par(mar=c(4,4,2,2))
cols = colora(size(yred)[1],56,0)
for(i in 1:size(yred)[1]){
   if(i==1){
     plot(1:size(yred)[2],yred[i,],col=cols[i],ylim=extrema(yred),type='l',xlab='weeks',ylab='pm10')
 	  } 
	  else{
		  lines(1:size(yred)[2],yred[i,],col=cols[i])
	  }
}
# -> we have
y
s_std
```



## Fits
```{r}
# as.integer(runif(1,0,1000))*1.0
# seed = 881.0
seed = 314.0
cat("seed",seed,"\n")

niter=1000; nburn=800; nthin=2
# niter=50000; nburn=10000; nthin=40 # they did this in their tests
# niter=30000; nburn=20000; nthin=10
# niter=50000; nburn=40000; nthin=10
# niter=80000; nburn=60000; nthin=20
nout <- (niter-nburn)/nthin
cat(nout,"valid iterations\n")
```


```{r}
# params
m0_phi0 = 0
s20_phi0 = 1
A_ub_sigma = 5
A_ub_tau = 5
A_ub_lambda = 5

a_sigma  = 2; b_sigma  = 2
a_tau    = 2; b_tau    = 2
a_lambda = 2; b_lambda = 2
eta1_scale = 0.9

# mh is the of gaussian standard deviations for metropolis updates
# So these are not variances!
sig_mh_sig2 = 0.1
sig_mh_tau2 = 0.1
sig_mh_lambda2 = 0.1
sig_mh_eta1 = 0.1
sig_mh_phi1 = 0.1

update_eta1 = TRUE
update_phi1 = TRUE

a_alpha = 2; b_alpha = 2
time_specific_alpha = TRUE

# now space
spatial_cohesion = 3
mu0 = 0 
k0 = 1
v0 = 5
L0 = 1
```

## drpm C
```{r}
tempo_inizio <- Sys.time()
drpm1 <- drpm_fit(
		y=y, 
		s_coords = s_std,
        M=1,
        initial_partition = NULL,
		
        starting_alpha = 0.5,
        unit_specific_alpha = FALSE,
        time_specific_alpha = time_specific_alpha,
        alpha_0=FALSE,
		
        eta1_0=!(update_eta1),
        phi1_0=!(update_phi1),
        # modelPriors=c(0,100^2,1,1,1,1), # original default one
        modelPriors=c(m0_phi0,s20_phi0,A_ub_sigma,A_ub_tau,A_ub_lambda,eta1_scale),

        alphaPriors=rbind(c(a_alpha,b_alpha)), # if time_specific_alpha == TRUE
        
        simpleModel = 0,
        theta_tau2 = c(0, 2), # only used if simpleModel=1

		SpatialCohesion=spatial_cohesion, # auxiliary similarity
		# SpatialCohesion=4, # double dipper similarity
		cParms=c(mu0, k0, v0, L0),
		
		mh=c(sig_mh_sig2,sig_mh_tau2,sig_mh_lambda2,sig_mh_eta1,sig_mh_phi1),
		verbose=TRUE,
		# draws=1000,burn=0,thin=1)
		draws=niter,burn=nburn,thin=nthin)

tempo_fine <- Sys.time()
differenza_tempo <- tempo_fine - tempo_inizio
cat(crayon::cyan("Fit took:\n"))
print(round(differenza_tempo,digits = 4))

cat(crayon::red("\nLPML =",drpm1$lpml, "\nWAIC =",drpm1$waic))
```

LPML = 98.2203655319962 
WAIC = -211.142931562583

```{r}
names(drpm1)

cat("\nSi     size = ",size(drpm1$Si),"\n")
cat("gamma  size = ",size(drpm1$gamma),"\n")
cat("mu     size = ",size(drpm1$mu),"\n")
cat("sig2   size = ",size(drpm1$sig2),"\n")
cat("alpha  size = ",size(drpm1$alpha),"\n")
cat("theta  size = ",size(drpm1$theta),"\n")
cat("tau2   size = ",size(drpm1$tau2),"\n")
cat("eta1   size = ",size(drpm1$eta1),"\n")
cat("phi0   size = ",size(drpm1$phi0),"\n")
cat("phi1   size = ",size(drpm1$phi1),"\n")
cat("lam2   size = ",size(drpm1$lam2),"\n")
cat("llike  size = ",size(drpm1$llike),"\n")
cat("fitted size = ",size(drpm1$fitted),"\n")
```

```{r}
# save(drpm1, file = "temp_error.Rdata")
load(file = "temp_error.Rdata")
```


## clustering covariates
```{r}
n = dim(y)[1]
# Tm

# colnames(df_wsc)
covariate_scelte = c(
	"Altitude"
	# ,"WE_temp_2m"
	# ,"WE_wind_speed_10m_mean"
	# ,"WE_wind_speed_10m_max"
	# ,"WE_mode_wind_direction_10m"
	# "WE_tot_precipitation"
	# ,"WE_precipitation_t"
	# ,"WE_surface_pressure"
	# ,"WE_solar_radiation"
	# ,"WE_rh_min"
	# ,"WE_rh_mean"
	# ,"WE_rh_max"
	# ,"WE_wind_speed_100m_mean"
	# ,"WE_wind_speed_100m_max"
	# ,"WE_mode_wind_direction_100m"
	# ,"WE_blh_layer_max"
	# ,"WE_blh_layer_min"
	# ,"EM_nh3_livestock_mm"
	# ,"EM_nh3_agr_soils"
	# ,"EM_nh3_agr_waste_burn"
	# ,"EM_nh3_sum"
	# ,"EM_nox_traffic"
	# ,"EM_nox_sum"
	# ,"EM_so2_sum"
	# ,"LI_pigs"
	# ,"LI_bovine"
	# ,"LI_pigs_v2"
	# ,"LI_bovine_v2"
	# ,"LA_hvi"
	# ,"LA_lvi"
	# ,"LA_land_use"
	# ,"day"
	# ,"week"
	)

p = lenght(covariate_scelte)
X_cl = array(data = 0, dim = c(n, p, Tm))
dim(X_cl)
cat("N * p * T = ",n,"*",p,"*",Tm,"\n")

for(i in 1:n){
	st = stations[i]
	for(t in 1:Tm){
		df_st = df_wsc[which(df_wsc$IDStations == st),]
		for (pp in 1:p){
			X_cl[i,pp,t] = as.numeric(df_st[t,covariate_scelte[pp]])
		}
	}
}
colnames(X_cl) = covariate_scelte
head(X_cl)
```



## likelihood covariates
```{r}
n = dim(y)[1]
# Tm

colnames(df_wsc)
# penso vadano scelte quelle correlate alla target variable
# perché qui vogliamo solo migliorare il fit, non individuare/separare i cluster
covariate_scelte = c(
	# "Altitude"
	"WE_temp_2m"
	# ,"WE_wind_speed_10m_mean"
	# ,"WE_wind_speed_10m_max"
	# ,"WE_mode_wind_direction_10m"
	# "WE_tot_precipitation"
	# ,"WE_precipitation_t"
	# ,"WE_surface_pressure"
	# ,"WE_solar_radiation"
	# ,"WE_rh_min"
	# ,"WE_rh_mean"
	# ,"WE_rh_max"
	# ,"WE_wind_speed_100m_mean"
	# ,"WE_wind_speed_100m_max"
	# ,"WE_mode_wind_direction_100m"
	# ,"WE_blh_layer_max"
	# ,"WE_blh_layer_min"
	# ,"EM_nh3_livestock_mm"
	# ,"EM_nh3_agr_soils"
	# ,"EM_nh3_agr_waste_burn"
	# ,"EM_nh3_sum"
	# ,"EM_nox_traffic"
	# ,"EM_nox_sum"
	# ,"EM_so2_sum"
	# ,"LI_pigs"
	# ,"LI_bovine"
	# ,"LI_pigs_v2"
	# ,"LI_bovine_v2"
	# ,"LA_hvi"
	# ,"LA_lvi"
	# ,"LA_land_use"
	# ,"day"
	# ,"week"
	)

p = lenght(covariate_scelte)
X_lk = array(data = 0, dim = c(n, p, Tm))
dim(X_lk)
cat("N * p * T = ",n,"*",p,"*",Tm,"\n")

for(i in 1:n){
	st = stations[i]
	for(t in 1:Tm){
		df_st = df_wsc[which(df_wsc$IDStations == st),]
		for (pp in 1:p){
			X_lk[i,pp,t] = as.numeric(df_st[t,covariate_scelte[pp]])
		}
	}
}
colnames(X_lk) = covariate_scelte
head(X_lk)
```

fictitious covariate, just for testing
```{r}
p = 1
X_lk_copy = array(data = 0, dim = c(n, p, Tm))

# X_lk_copy[,1,] = X_lk[,1,]
X_lk_copy[,1,] = y*2

X_lk = X_lk_copy
# X_lk[,,] / 2 == y[,1]
```

## drpm J
```{r}
module_JDRPM <- juliaImport(juliaCall("include", module))
out = module_JDRPM$MCMC_fit(
	Y=as.matrix(y),              
	sp_coords = s_std,
	M_dp = 1,                     
	initial_partition = NA,
	
	starting_alpha = 0.5,         
	unit_specific_alpha = FALSE,       
	time_specific_alpha = time_specific_alpha,       
	update_alpha = TRUE,             
	
	include_eta1 = TRUE,                    
	include_phi1 = TRUE,
	update_eta1 = update_eta1,                    
	update_phi1 = update_phi1,
	
	sig2h_priors = c(a_sigma,b_sigma),
	eta1_priors = c(eta1_scale,sig_mh_eta1^2),
	
	tau2_priors = c(a_tau,b_tau),
	phi0_priors = c(m0_phi0,s20_phi0),
	phi1_priors = sig_mh_phi1^2,
	lambda2_priors = c(a_lambda,b_lambda),
	alpha_priors = c(a_alpha,b_alpha),  
	
	######## space
	spatial_cohesion_idx = spatial_cohesion,
	sp_params = list(c(mu0,mu0),k0,v0,matrix(c(L0,0.0,0.0,L0),nrow=2)),
	
	######## likelihood covariates
	# Xlk_covariates = X_lk, beta_priors = c(rep(0,p),1),
	Xlk_covariates = NA, beta_priors = NA,
	
	######## clustering covariates
	# covariate_similarity_idx = 4,
	# cv_params = list(0,1,2,2),
	# Xcl_covariates = X_cl,

	draws = niter, burnin = nburn, thin = nthin,
	# draws = 5, burnin = 0, thin = 1,
	logging = TRUE,
	seed = seed
)
```


-------------------------------

con
LPML: -1330.9103179215952 (the higher the better)
WAIC: 75.42884454241916 (the lower the better)

```
draws = 10000, burnin = 9000, thin = 2,

senza 
Elapsed time: 27 seconds, 778 milliseconds
LPML: -424.4560327439583 (the higher the better)
WAIC: -69.62662452505964 (the lower the better)

con
Elapsed time: 30 seconds, 471 milliseconds
LPML: -862.5732953406753 (the higher the better)
WAIC: 227.00164167413186 (the lower the better)
```





-------------------------------------------
- run 100k
C: LPML = 591.736559528529 
WAIC = -1485.06225799014

J con covariate lk: 
LPML: -9571.404384988806 (the higher the better)
WAIC: 499.05570310587393 (the lower the better)

J senza covariate lk:
LPML: -3928.6204576778982 (the higher the better)
WAIC: -1221.5068891555936 (the lower the better)

-------------------------------------------
- senza covariate nella likelihood
Elapsed time: 15 minutes, 36 seconds, 504 milliseconds
LPML: -2457.4864570366817 (the higher the better)
WAIC: 104.56692806809703 (the lower the better)

- con covariate nella likelihood
Elapsed time: 12 minutes, 53 seconds, 546 milliseconds
LPML: -3727.501798213436 (the higher the better)
WAIC: 268.9504905953344 (the lower the better)

- con covariate ma senza quella dal trace plot malvagio
Elapsed time: 15 minutes, 28 seconds, 845 milliseconds
LPML: -4101.864831738578 (the higher the better)
WAIC: 187.57410762137346 (the lower the better)


```{r}
rout = juliaGet(out)
names(rout)  = c("Si",
				 "gamma",
				 "alpha", 
				 "sigma2h", 
				 "muh", 
				 "eta1",
				 "beta",
				 "theta", 
				 "tau2", 
				 "phi0", 
				 "phi1",
				 "lambda2",
				 "fitted",
				 "llike",
				 "lpml",
				 "waic")

# reshape some stuff to uniform it to drpm output
rout$Si           = aperm(rout$Si,       c(2, 1, 3))
rout$gamma        = aperm(rout$gamma,    c(2, 1, 3))
rout$sigma2h      = aperm(rout$sigma2h,  c(2, 1, 3))
rout$muh          = aperm(rout$muh,      c(2, 1, 3))
rout$fitted       = aperm(rout$fitted,   c(2, 1, 3))
rout$llike        = aperm(rout$llike,    c(2, 1, 3))
rout$alpha        = aperm(rout$alpha,    c(2, 1))
rout$theta        = aperm(rout$theta,    c(2, 1))
rout$tau2         = aperm(rout$tau2,     c(2, 1))
rout$eta1         = aperm(rout$eta1,    c(2, 1))
rout$phi0     = matrix(rout$phi0,    ncol = 1)
rout$phi1     = matrix(rout$phi1,    ncol = 1)
rout$lambda2  = matrix(rout$lambda2, ncol = 1)
cat(crayon::red("\nLPML =",rout$lpml, "\nWAIC =",rout$waic))
```


```{r}
model_title = "model J with Xcl"

yredJ=t(rout$fitted[,,size(rout$fitted)[3]])
yred=y

cols = colora(size(yred)[1],56,0)
# cols = colora(size(yred)[1],"div",show = 0)

par(mar=c(4,4,4,2))
for(i in 1:size(yredJ)[1]){
   if(i==1){
     plot(1:size(yredJ)[2],yredJ[i,],col=cols[i],
     	 ylim=extrema(yred,yredJ,yredJ),
     	 type='l',xlab='time',ylab="fitted values",main=model_title)
 	  } 
	  else{
		  lines(1:size(yredJ)[2],yredJ[i,],col=cols[i])
	  }
}

yredJ=y
cols = colora(size(yred)[1],56,0)
# cols = colora(size(yred)[1],"div",show = 0)

par(mar=c(4,4,4,2))
for(i in 1:size(yredJ)[1]){
   if(i==1){
     plot(1:size(yredJ)[2],yredJ[i,],col=cols[i],
     	 ylim=extrema(yred,yredJ,yredJ),
     	 type='l',xlab='time',ylab="fitted values",main="Original values")
 	  } 
	  else{
		  lines(1:size(yredJ)[2],yredJ[i,],col=cols[i])
	  }
}
```



```{r}
names(rout)

cat("Si           size = ",size(rout$Si),"\n")
cat("gamma        size = ",size(rout$gamma),"\n")
cat("sigma2h      size = ",size(rout$sigma2h),"\n")
cat("muh          size = ",size(rout$muh),"\n")
cat("alpha        size = ",size(rout$alpha),"\n")
cat("theta        size = ",size(rout$theta),"\n")
cat("tau2         size = ",size(rout$tau2),"\n")
cat("eta1         size = ",size(rout$eta1),"\n")
cat("phi0         size = ",size(rout$phi0),"\n")
cat("phi1         size = ",size(rout$phi1),"\n")
cat("lambda2      size = ",size(rout$lambda2),"\n")
cat("beta         size = ",size(rout$beta),"\n")
cat("fitted       size = ",size(rout$fitted),"\n")
cat("llike        size = ",size(rout$llike),"\n")

cat("lpml = ",rout$lpml,"\n")
cat("waic = ",rout$waic,"\n")
```



```{r}
rout = rout_copy
```


```{r}
# rout_copy = rout
### non salvare l'out ma solo l'rout

# save(rout,out,file="julia_outputs_tmp.Rdata")
# save(drpm1, rout, out, file = "ran_100k_with_Xlk.Rdata")
load(file = "ran_100k_with_Xlk.Rdata")
```


## Trace plots

### beta
```{r}
for (covariata_idx in 1:length(covariate_scelte)){
	cols = colora(size(rout$beta)[3],44,0)
	# verde scuro: iterazioni iniziali
	# giallo: iterazioni finali
	par(mar=c(3,3,3,1))
	for (iter in 1:size(rout$beta)[3]){
		if(iter==1) {
			plot(rout$beta[,covariata_idx,iter],
				 ylim=extrema(rout$beta[,covariata_idx,]),
				 main=covariate_scelte[covariata_idx],
				 col = cols[iter],type="l")
		} else {
			lines(rout$beta[,covariata_idx,iter],col = cols[iter])
		}
	}
	legend("topleft",legend = c("initial iterates","final iterates"),
		   col = c(cols[1],cols[size(rout$beta)[3]]),lty=c(1,1),
		   lwd=3,cex=0.6,bty="n"
		   )
	# boxplot(rout$beta[,covariata_idx,],
		# main=covariate_scelte[covariata_idx])
}
```

### alpha
```{r}
for (time in 1:Tm){
		par(mfrow=c(1,2),mar=c(2,2,4,2))

plot(drpm1$alpha[,time],type="l",
	 main=bquote("Model DRPM C\nTrace plot of alpha at time "*.(time)
	 ), ylim=c(0,1),
	 xlab = "MCMC iterations",ylab="values")
plot(rout$alpha[,time],type="l",
	 main=bquote("Model DRPM J\nTrace plot of alpha at time "*.(time)
	 ), ylim=c(0,1),
	 xlab = "MCMC iterations",ylab="values")
}
```
### mu
```{r}
size(drpm1$mu)
size(rout$muh)
unitj = 1
for (time in 1:Tm){
		par(mfrow=c(1,2),mar=c(2,2,4,2))

	plot(drpm1$mu[time,unitj,],type="l",
		 ylim=c(min(drpm1$mu[time,unitj,],rout$muh[time,unitj,]),
		 	   max(drpm1$mu[time,unitj,],rout$muh[time,unitj,])),
		 main=bquote("Model DRPM C\nTrace plot of mu at time "*.(time) * " unit " * .(unitj)),
		 xlab = "MCMC iterations",ylab="values")
	plot(rout$muh[time,unitj,],type="l",
		 ylim=c(min(drpm1$mu[time,unitj,],rout$muh[time,unitj,]),
		 	   max(drpm1$mu[time,unitj,],rout$muh[time,unitj,])),
		 main=bquote("Model DRPM J\nTrace plot of mu at time "*.(time) * " unit " * .(unitj)),
		 xlab = "MCMC iterations",ylab="values")
}
```

### sigma2
```{r}
size(drpm1$sig2)
size(rout$sigma2h)
unitj = 1
for (time in 1:Tm){
		par(mfrow=c(1,2),mar=c(2,2,4,2))

	plot(drpm1$sig2[time,unitj,],type="l",
		 main=bquote("Model DRPM C\nTrace plot of sigma2 at time "*.(time) * " unit " * .(unitj)),
		 ylim=c(0,max(drpm1$sig2[time,unitj,], rout$sigma2h[time,unitj,])),
		 xlab = "MCMC iterations",ylab="values")
	plot(rout$sigma2h[time,unitj,],type="l",
		 main=bquote("Model DRPM J\nTrace plot of sigma2 at time "*.(time) * " unit " * .(unitj)),
		 ylim=c(0,max(drpm1$sig2[time,unitj,], rout$sigma2h[time,unitj,])),
		 xlab = "MCMC iterations",ylab="values")
}
```

### eta1
```{r}
dim(drpm1$eta1)
dim(rout$eta1)

cat("did we update eta1?", update_eta1)
for (unit in 1:N){
	par(mfrow=c(1,2),mar=c(2,2,4,2))
	plot(drpm1$eta1[,unit],type="l",
		 ylim=c(min(drpm1$eta1[,unit],rout$eta1[,unit]),
		 	    max(drpm1$eta1[,unit],rout$eta1[,unit])),
		 main=bquote("Model DRPM C\nTrace plot of eta1 at unit "*.(unit)),
		 xlab = "MCMC iterations",ylab="values")
	plot(rout$eta1[,unit],type="l",
		 ylim=c(min(drpm1$eta1[,unit],rout$eta1[,unit]),
		 	    max(drpm1$eta1[,unit],rout$eta1[,unit])),
		 main=bquote("Model DRPM J\nTrace plot of eta1 at unit "*.(unit)),
		 xlab = "MCMC iterations",ylab="values")
}
```


### theta
```{r}
for (time in 1:Tm){
	par(mfrow=c(1,2),mar=c(2,2,4,2))
	plot(drpm1$theta[,time],type="l",
		  ylim=c(min(drpm1$theta[,time],rout$theta[,time]),
		 	    max(drpm1$theta[,time],rout$theta[,time])),
		 main=bquote("Model DRPM C\nTrace plot of theta at time "*.(time)),
		 xlab = "MCMC iterations",ylab="values")
	plot(rout$theta[,time],type="l",
		  ylim=c(min(drpm1$theta[,time],rout$theta[,time]),
		 	    max(drpm1$theta[,time],rout$theta[,time])),
		 main=bquote("Model DRPM J\nTrace plot of theta at time "*.(time)),
		 xlab = "MCMC iterations",ylab="values")
}
```

### tau2
```{r}
dim(drpm1$tau2)
dim(rout$tau2)

for (time in 1:Tm){
	par(mfrow=c(1,2),mar=c(2,2,4,2))
	plot(drpm1$tau2[,time],type="l",
		 ylim=c(0,max(drpm1$tau2[,time],rout$tau2[,time])),
		 main=bquote("Model DRPM C\nTrace plot of tau2 at time "*.(time)),
		 xlab = "MCMC iterations",ylab="values")
	plot(rout$tau2[,time],type="l",
		 ylim=c(0,max(drpm1$tau2[,time],rout$tau2[,time])),
		 main=bquote("Model DRPM J\nTrace plot of tau2 at time "*.(time)),
		 xlab = "MCMC iterations",ylab="values")
}
```


### layer three
phi1, phi0, lambda2
```{r}
dim(drpm1$phi1)
dim(rout$phi1)

cat("did we update phi1?", update_phi1)
par(mfrow=c(1,2),mar=c(2,2,4,2))
plot(drpm1$phi1[,1],type="l",
	  ylim=c(min(drpm1$phi1[,1],rout$phi1[,1]),
		 	    max(drpm1$phi1[,1],rout$phi1[,1])),
	 main=bquote("Model DRPM C\nTrace plot of phi1"),
	 xlab = "MCMC iterations",ylab="values")
plot(rout$phi1[,1],type="l",
	  ylim=c(min(drpm1$phi1[,1],rout$phi1[,1]),
		 	    max(drpm1$phi1[,1],rout$phi1[,1])),
	 main=bquote("Model DRPM J\nTrace plot of phi1"),
	 xlab = "MCMC iterations",ylab="values")

dim(drpm1$phi0)
dim(rout$phi0)

par(mfrow=c(1,2),mar=c(2,2,4,2))
plot(drpm1$phi0[,1],type="l",
	 	  ylim=c(min(drpm1$phi0[,1],rout$phi0[,1]),
		 	    max(drpm1$phi0[,1],rout$phi0[,1])),
	 main=bquote("Model DRPM C\nTrace plot of phi0"),
	 xlab = "MCMC iterations",ylab="values")
plot(rout$phi0[,1],type="l",
	 	  ylim=c(min(drpm1$phi0[,1],rout$phi0[,1]),
		 	    max(drpm1$phi0[,1],rout$phi0[,1])),
	 main=bquote("Model DRPM J\nTrace plot of phi0"),
	 xlab = "MCMC iterations",ylab="values")


dim(drpm1$lam2)
dim(rout$lambda2)

par(mfrow=c(1,2),mar=c(2,2,4,2))
plot(drpm1$lam2[,1],type="l",
	 	  ylim=c(min(drpm1$lam2[,1],rout$lambda2[,1]),
		 	    max(drpm1$lam2[,1],rout$lambda2[,1])),
	 main=bquote("Model DRPM C\nTrace plot of lambda2"),
	 xlab = "MCMC iterations",ylab="values")
plot(rout$lambda2[,1],type="l",
	 	  ylim=c(min(drpm1$lam2[,1],rout$lambda2[,1]),
		 	    max(drpm1$lam2[,1],rout$lambda2[,1])),
	 main=bquote("Model DRPM J\nTrace plot of lambda2"),
	 xlab = "MCMC iterations",ylab="values")
```



## Partition plots
```{r, warning=F}
maxNClusters = 3

# partition_plots = function(drpm1, rout){ 
# Initialize a list to store the partitions for each time instant
partitions_drpmc <- list()
partitions_drpmj <- list()

# Loop over each time instant to extract the consensus partition
for (t in 1:Tm) {
  Sic_t <- drpm1$Si[t, , ]
  Sic_t <- t(Sic_t) 
  partitions_drpmc[[t]] <- salso(Sic_t, loss = "binder"
  							   , maxNClusters = maxNClusters
  							   )

  Sij_t <- rout$Si[t, , ]
  Sij_t <- t(Sij_t) 
  partitions_drpmj[[t]] <- salso(Sij_t, loss = "binder"
  							   # , maxNClusters = maxNClusters
  							   )
}
maxk = 0
cat(crayon::red("DRPM - C\n"))
for (t in 1:Tm){
	cat("Time",t,"- #clusters =",length(unique(partitions_drpmc[[t]])),"\n")
	maxk = max(length(unique(partitions_drpmc[[t]])),maxk)
}
cat("\n")
cat(crayon::red("DRPM - J\n"))
for (t in 1:Tm){
	cat("Time",t,"- #clusters =",length(unique(partitions_drpmj[[t]])),"\n")
	maxk = max(length(unique(partitions_drpmj[[t]])),maxk)
}
```


```{r, warning=F}
# cols=colora(len=maxk, seed=67, show=1)
# cols=colora(len=maxk, seed=41, show=0) # greens/light-blues
# cols=colora(len=maxk, seed=73, show=0) # dark blues
# cols=colora(len=maxk, seed=32, show=0) # viridis
# cols=colora(len=maxk, seed=22, show=0) # reds/blues
# cols=colora(len=maxk, seed=44, show=0) # greens
cols=colora(len=maxk, seed=56, show=0) # la 56
# cols = colora(len=10,"rand")

heatmap_matrix <- do.call(rbind, partitions_drpmc)
# Generate the heatmap
heatmap(heatmap_matrix, Rowv = NA, Colv = NA, scale = "none",
		main="model C", xlab = "units", ylab = "time instants",
        # col = terrain.colors(length(unique(as.vector(heatmap_matrix)))))
		col = cols)
heatmap_matrix <- do.call(rbind, partitions_drpmj)
# Generate the heatmap
heatmap(heatmap_matrix, Rowv = NA, Colv = NA, scale = "none",
		main="model J",xlab = "units", ylab = "time instants",
        # col = terrain.colors(length(unique(as.vector(heatmap_matrix)))))
		col = cols)

####################################################################

partitions = partitions_drpmc
partition_matrix <- do.call(cbind, partitions)
num_units <- nrow(partition_matrix)
Tm <- ncol(partition_matrix)
# Set up the plot
par(mar=c(4,4,2,2))
plot(1:Tm, rep(NA, Tm), type = "n",
     xlab = "Time Instants", ylab = "clusters", main="model C",
     ylim = range(partition_matrix)+c(-0.1,0.1), xaxt = "n", yaxt = "n")
axis(1, at = 1:Tm, labels = 1:Tm)
axis(2, at = unique(as.vector(partition_matrix)), las = 2)
# Add grid lines for clarity
abline(h = unique(as.vector(partition_matrix)), col = "lightgray", lty = "dotted")
abline(v = 1:Tm, col = "lightgray", lty = "dotted")
# Plot lines and points for each unit
for (unit in 1:num_units) {
  lines(1:Tm, partition_matrix[unit, ], type = "l", pch = 19,
        col = unit, lwd = 1)
}
# legend("topright", legend = paste("Unit", 1:num_units), col = 1:num_units,
       # lty = 1, lwd = 2, pch = 19, bty = "n")


partitions = partitions_drpmj
partition_matrix <- do.call(cbind, partitions)
num_units <- nrow(partition_matrix)
Tm <- ncol(partition_matrix)
# Set up the plot
par(mar=c(4,4,2,2))
plot(1:Tm, rep(NA, Tm), type = "n",
     xlab = "Time Instants", ylab = "clusters", main="model J",
     ylim = range(partition_matrix)+c(-0.1,0.1), xaxt = "n", yaxt = "n")
axis(1, at = 1:Tm, labels = 1:Tm)
axis(2, at = unique(as.vector(partition_matrix)), las = 2)
abline(h = unique(as.vector(partition_matrix)), col = "lightgray", lty = "dotted")
abline(v = 1:Tm, col = "lightgray", lty = "dotted")
for (unit in 1:num_units) {
  lines(1:Tm, partition_matrix[unit, ], type = "l", pch = 19,
        col = unit, lwd = 1)
}
# legend("topright", legend = paste("Unit", 1:num_units), col = 1:num_units,
       # lty = 1, lwd = 2, pch = 19, bty = "n")


####################################################################

partitions = partitions_drpmc
partition_matrix <- do.call(cbind, partitions)
par(mar=c(3.8,1,3,1),mfrow=c(1,2))
plot(NULL, NULL, xlim = c(1, Tm), ylim = c(1, num_units)+c(-0.5,0.5),
     xlab = "Time Instants", ylab = "Units",
     xaxt = "n", yaxt = "n", main = "model C")
axis(1, at = 1:Tm, labels = 1:Tm)
for (t in 1:Tm) {
  for (unit in 1:num_units) {
    text(x = t, y = unit, labels = as.character(unit),
         col = partition_matrix[unit, t], cex = 0.5)
  }
}

partitions = partitions_drpmj
partition_matrix <- do.call(cbind, partitions)
plot(NULL, NULL, xlim = c(1, Tm), ylim = c(1, num_units)+c(-0.5,0.5),
     xlab = "Time Instants", ylab = "Units",
     xaxt = "n", yaxt = "n", main = "model J")
axis(1, at = 1:Tm, labels = 1:Tm)
for (t in 1:Tm) {
  for (unit in 1:num_units) {
    text(x = t, y = unit, labels = as.character(unit),
         col = partition_matrix[unit, t], cex = 0.5)
  }
}
```


## Ari plot
```{r warning=FALSE}
LEN = Tm
##########################
model_name = "model C"
partition = partitions_drpmc
##########################

df_cluster = data.frame(clusters=c(),Time=c())
for(time in 1:Tm){
	salso_out <- partition[[time]]
	df_temp = data.frame(
		clusters = salso_out
	)
	df_temp$Time = rep(time,dim(df_temp)[1])
	df_cluster = rbind(df_cluster,df_temp)
	
	# clusters log
	clusters_now = df_temp$clusters
	n_clusters = unique(clusters_now)
	cat(crayon::red("Time",time,"- #clusters =",length(unique(clusters_now)),"\n"))
}
library(mclust)
# build the ARI matrix
ARImats <- matrix(NA, nrow=LEN, ncol=LEN)
rho_ARI <- list()
for(k in 1:LEN){
	rho_ARI[[k]] <- partition[[k]]
}
for(k in 1: LEN){
	for(kk in 1: LEN){
		ARImats[k,kk] <- adjustedRandIndex(rho_ARI[[k]], rho_ARI[[kk]])
	}
}
ncols_ari = 100
# if (min(ARImats)<0){
	# cols_ARI = colora(ncols_ari,79,0)
	# brks = seq(min(-1,floor(min(ARImats))),1,length.out=ncols_ari+1)
# } else {
	# cols_ARI = colora(ncols_ari,56,0)
	# cols_ARI = rev(cols_ARI) # must be ordered from cold to warm
	cols_ARI = rev(colora(ncols_ari,104,0)) # or 109
	# cols_ARI = colora(ncols_ari,102,0)
	# brks = seq(0,1,length.out=ncols_ari+1)
	brks = seq(min(-1,floor(min(ARImats))),1,length.out=ncols_ari+1)
# }
# or see ?designer.colors for colors
library(fields)
image.plot(ARImats,
		   main=paste0("Lagged ARI values - ",model_name),axes=FALSE,col=cols_ARI,
		   breaks=brks)
mtext(text=c(paste("",1:LEN)), side=2, line=0.3,at=seq(0,1,length=LEN), las=1, cex=0.8)
mtext(text=c(paste("",1:LEN)), side=1, line=0.3,at=seq(0,1,length=LEN), las=2, cex=0.8)

##########################
model_name = "model J"
partition = partitions_drpmj
##########################

df_cluster = data.frame(clusters=c(),Time=c())
for(time in 1:Tm){
	salso_out <- partition[[time]]
	df_temp = data.frame(
		clusters = salso_out
	)
	df_temp$Time = rep(time,dim(df_temp)[1])
	df_cluster = rbind(df_cluster,df_temp)
	
	# clusters log
	clusters_now = df_temp$clusters
	n_clusters = unique(clusters_now)
	cat(crayon::red("Time",time,"- #clusters =",length(unique(clusters_now)),"\n"))
}
library(mclust)
# build the ARI matrix
ARImats <- matrix(NA, nrow=LEN, ncol=LEN)
rho_ARI <- list()
for(k in 1:LEN){
	rho_ARI[[k]] <- partition[[k]]
}
for(k in 1: LEN){
	for(kk in 1: LEN){
		ARImats[k,kk] <- adjustedRandIndex(rho_ARI[[k]], rho_ARI[[kk]])
	}
}
ncols_ari = 100
# if (min(ARImats)<0){
	# cols_ARI = colora(ncols_ari,79,0)
	# brks = seq(min(-1,floor(min(ARImats))),1,length.out=ncols_ari+1)
# } else {
	# cols_ARI = colora(ncols_ari,56,0)
	# cols_ARI = rev(cols_ARI) # must be ordered from cold to warm
	cols_ARI = rev(colora(ncols_ari,104,0)) # or 109
	# cols_ARI = colora(ncols_ari,102,0)
	# brks = seq(0,1,length.out=ncols_ari+1)
	brks = seq(min(-1,floor(min(ARImats))),1,length.out=ncols_ari+1)
# }
# or see ?designer.colors for colors
library(fields)
image.plot(ARImats,
		   main=paste0("Lagged ARI values - ",model_name),axes=FALSE,col=cols_ARI,
		   breaks=brks)
mtext(text=c(paste("",1:LEN)), side=2, line=0.3,at=seq(0,1,length=LEN), las=1, cex=0.8)
mtext(text=c(paste("",1:LEN)), side=1, line=0.3,at=seq(0,1,length=LEN), las=2, cex=0.8)

##########################################################

# take last sample (maybe not the best choice)
yredC=t(drpm1$fitted[,,size(drpm1$fitted)[3]])
yredJ=t(rout$fitted[,,size(rout$fitted)[3]])
yred=y

cols = colora(size(yred)[1],56,0)
# cols = colora(size(yred)[1],"div",show = 0)

par(mar=c(4,4,4,2))
for(i in 1:size(yredC)[1]){
   if(i==1){
     plot(1:size(yredC)[2],yredC[i,],col=cols[i],
     	 ylim=extrema(yred,yredJ,yredC),
     	 type='l',xlab='time',ylab="fitted values",main="model C")
 	  } 
	  else{
		  lines(1:size(yredC)[2],yredC[i,],col=cols[i])
	  }
}

par(mar=c(4,4,4,2))
for(i in 1:size(yredJ)[1]){
   if(i==1){
     plot(1:size(yredJ)[2],yredJ[i,],col=cols[i],
     	 ylim=extrema(yred,yredJ,yredC),
     	 type='l',xlab='time',ylab="fitted values",main="model J")
 	  } 
	  else{
		  lines(1:size(yredJ)[2],yredJ[i,],col=cols[i])
	  }
}

# original real data
for(i in 1:size(yred)[1]){
   if(i==1){
     plot(1:size(yred)[2],yred[i,],col=cols[i],type='l',
     	 xlab='time',ylab='values',main="original data",
     	 ylim=extrema(yred,yredJ,yredC))
 	  } 
	  else{
		  lines(1:size(yred)[2],yred[i,],col=cols[i])
	  }
}
```


## salso plots
```{r}
##########################
model_name = "model C"
partition = partitions_drpmc
# model_name = "model J"
# partition = partitions_drpmj
##########################

par(mar=c(1,1,1,1))
for (time in 1:Tm){
	salso_out = partition[[time]]
	ssout = summary(salso_out)
	# plot(ssout,type="heatmap")
	# plot(ssout,type="mds")
	plot(ssout,type="pairs",data=s_std)
	text(0.3,0.91,pos=3,paste0(model_name," - Time ",time))
	# plot(ssout,type="dendrogram")
	# dev.off()
}


##########################
# model_name = "model C"
# partition = partitions_drpmc
model_name = "model J"
partition = partitions_drpmj
##########################

par(mar=c(1,1,1,1))
for (time in 1:Tm){
	salso_out = partition[[time]]
	ssout = summary(salso_out)
	# plot(ssout,type="heatmap")
	# plot(ssout,type="mds")
	plot(ssout,type="pairs",data=s_std)
	text(0.3,0.91,pos=3,paste0(model_name," - Time ",time))
	# plot(ssout,type="dendrogram")
	# dev.off()
}
```


## PM10 plots
```{r warning=FALSE}
# preparation
source("plot functions/plotter.R")
source("include_clusters_functions.R")
```


```{r warning=FALSE}
sites = data.frame(
	longitude = unique(df_weekly$Longitude), 
	latitude = unique(df_weekly$Latitude))

sites = data.frame(
	longitude = unique(df_weekly$Longitude), 
	latitude = unique(df_weekly$Latitude))
std_sites = data.frame(
	longitude = unique(df_wsc$Longitude), 
	latitude = unique(df_wsc$Latitude))
stations = unique(df_wsc$IDStations)
y=data.frame()

target = "AQ_pm10"
# target = "WE_tot_precipitation"

for(st in stations){
	y_we_pm10=cbind(as.data.frame(st),t(df_wsc[which(df_wsc$IDStations==st),target]))
	y=rbind(y,y_we_pm10)
}
rownames(y) = NULL
colnames(y)<- c("id",paste0("w", 1:53))

time_span = 1:Tm # low time span for quick testing, real one will be 1:53
```


```{r,warning=F}
##########################
# model_name = "model C"
# partition = partitions_drpmc
model_name = "model J"
partition = partitions_drpmj
##########################
df_cluster = data.frame(Longitude=c(),Latitude=c(),values=c(),clusters=c(),Time=c())
for(time in time_span){

	salso_out <- partition[[time]]
	
	df_temp = data.frame(
		Longitude = sites$longitude,
		Latitude = sites$latitude,
		clusters = salso_out[1:105]
	)
	
	idxs = which(is.na(df_temp$clusters))
	# replace(df_temp$clusters, idxs, 3)
	df_temp$clusters[idxs] = max(na.omit(df_temp$clusters))+1
	
	df_temp$Time = rep(time,dim(df_temp)[1])
	df_cluster = rbind(df_cluster,df_temp)
	
	# clusters log
	clusters_now = df_temp$clusters
	n_clusters = unique(clusters_now)
	ycurrent = y[,paste0("w",time)]
	cat(crayon::red("Time",time,"- #clusters =",length(unique(clusters_now)),"\n"))
}

clusters_old = NULL
for(time in time_span){
	cat(crayon::red("Time",time,"\n"))
	
	df_cluster_cut = df_cluster[df_cluster$Time==time,]
	clusters_now = df_cluster_cut$clusters
	####### no mode correct now
	# clusters_now = mode_correct_clusters(clusters_old,clusters_now,very_verbose = 0)
	# se fai heat plot non serve fare la mode correct
	# perché la heat plot la usi per vedere anche i valori di pm10, non la coerenza temporale
	# nei gruppi, che con la heat coloration si perde come visibilità (non so se è chiaro)
	df_cluster_cut$clusters = clusters_now
	
	# meglio l'idea 1
	cols = color_correct_clusters(df_cluster_cut,idea=1,verbose=0)
	
	# q = get_graph_plot(df_cluster_cut,cols)
	# print(q)
	p = plot_graph_and_hist(df_cluster_cut,cols,titolo = model_name)
	
	cur_num = sprintf("%02d", time)
	ggsave(file=paste0("../../tmp_images/",model_name,"-Graph and Boxplot-",cur_num,".png"),
	plot=p, units="px",width=2500, height=1200, dpi=300)
	dev.off()
	
	clusters_old = clusters_now
}
```





```{r,warning=F}
##########################
# model_name = "model C"
# partition = partitions_drpmc
model_name = "model J"
partition = partitions_drpmj
##########################
df_cluster = data.frame(Longitude=c(),Latitude=c(),values=c(),clusters=c(),Time=c())
for(time in time_span){

	salso_out <- partition[[time]]
	
	df_temp = data.frame(
		Longitude = sites$longitude,
		Latitude = sites$latitude,
		clusters = salso_out[1:105]
	)
	idxs = which(is.na(df_temp$clusters))
	df_temp$clusters[idxs] = max(na.omit(df_temp$clusters))+1
	
	df_temp$Time = rep(time,dim(df_temp)[1])
	df_cluster = rbind(df_cluster,df_temp)
	
	# clusters log
	clusters_now = df_temp$clusters
	n_clusters = unique(clusters_now)
	ycurrent = y[,paste0("w",time)]
	cat(crayon::red("Time",time,"- #clusters =",length(unique(clusters_now)),"\n"))
}

clusters_old = NULL
for(time in time_span){
	cat(crayon::red("Time",time,"\n"))
	
	df_cluster_cut = df_cluster[df_cluster$Time==time,]
	clusters_now = df_cluster_cut$clusters
	####### no mode correct now
	# clusters_now = mode_correct_clusters(clusters_old,clusters_now,very_verbose = 0)
	# se fai heat plot non serve fare la mode correct
	# perché la heat plot la usi per vedere anche i valori di pm10, non la coerenza temporale
	# nei gruppi, che con la heat coloration si perde come visibilità (non so se è chiaro)
	df_cluster_cut$clusters = clusters_now
	
	# meglio l'idea 1
	cols = color_correct_clusters(df_cluster_cut,idea=1,verbose=0)
	
	# q = get_graph_plot(df_cluster_cut,cols)
	# print(q)
	p = plot_graph_and_hist(df_cluster_cut,cols,titolo = model_name)
	
	cur_num = sprintf("%02d", time)
	ggsave(file=paste0("../../tmp_images/",model_name,"-Graph and Boxplot-",cur_num,".png"),
		   plot=p, units="px",width=2500, height=1200, dpi=300)
		   # units="px",width=2500, height=1400, dpi=300)
	dev.off()
	
	clusters_old = clusters_now
}
```

```{r}
#########################################
# titleJ = "model J - considering Altitude when clustering"
titleJ = "model J - ignoring covariates when clustering"
partition = partitions_drpmj
titleJ = "model C"
partition = partitions_drpmc
#########################################


pdf(paste0("../../tmp_images/",titleJ,".pdf"),width = 8, height = 5)
# png(paste0("../../tmp_images/",titleJ,".png"), width = 500, height = 300,units = "px")
par(mar=c(4,4,2,1))
time=1

##### if fitted with Xcl
# mean(X_cl[which(partition[[time]]==1),,1])
# mean(X_cl[which(partition[[time]]==2),,1])
# mean(X_cl[which(partition[[time]]==3),,1])
# plot(X_cl[,,1],pch=19,col=partition[[time]],
# 	 main=paste0("time=",time," - ",titleJ),xlab="units",ylab="Altitude")

cols = colora(maxk,34,0)
##### otherwise
cova_of_interest = as.data.frame(df_wsc[df_wsc$Time == unique(df_wsc$Time)[time],"Altitude"])
plot(cova_of_interest[,1],
	# col=cols[partition[[time]]],
	col=partition[[time]],
	pch=19,
	# cex=pmax(y[, time]*4, rep(0.7, N)),
	main=paste0("time=",time," - ",titleJ),xlab="units",ylab="Altitude"
	)

dev.off()
```

fino a qui ha tutto senso questa parte
# ==========
questa parte dopo no invece, non ci ho ancora lavorato

# TESTS

```{r}
library(gower)
dat1 <- as.data.frame(c(1,1,10))
colnames(dat1) = c("X")
dat2 <- as.data.frame(c(1,1,5))
colnames(dat2) = c("X")
gower_dist(dat1, dat2)
```

# ==========

# BSPOONS TASKS
```{r}
enrolled = c(
	191	     ,    
	185	     ,    
	384	     ,    
	377	     ,    
	369	     ,    
	421	     ,    
	397	     ,    
	218	     ,    
	432	     ,    
	0	     ,    
	0	     ,    
	0)    



job_offers =c(
	0,
   20,
   23,
   9,
   42,
   39,
   33,
   48,
   38,
   20,
   52,
   0)

months = c(
"Jan" ,
"Feb"  ,
"Mar" ,
"Apr"  ,
"May" ,
"Jun"  ,
"Jul" ,
"Aug"  ,
"Sep" ,
"Oct"  ,
"Nov" ,
"Dec"  )


spend = c(
 340000,
 497250,
 646000,
 804100,
 960500,
 991950,
 1008950,
 880600,
 889950,
 552500,
 367200,
 0)
```

```{r}
data = data.frame(
	enrolled = enrolled,
	job_offers = job_offers,
	months = months,
	spend = spend
)

data
```

# q1
```{r}
a = sum(data$enrolled[1:6])
b = sum(data$job_offers[3:8])
cat(a,"\n")
cat(b,"\n")
b*100/a
```

# q1

# q1

# q1













# ==========
# 4. OTHER DATA

```{r}
install.packages("spacetime")
library(spacetime)
data(air)
rural = STFDF(stations, dates, data.frame(PM10 = as.vector(air)))
```
```{r}
rural@data
```


# ==========

<!-- # 2. SIMPLE TEST -->
## data
```{r}
# seed_choice = round(runif(1,0,1000))
# cat(paste0("seed ",seed_choice))
# set.seed(seed_choice)
set.seed(345)

# Create the sites data frame
sites <- data.frame(
	longitude = c(0, 1, 2, 0, 1, 2, 0, 1, 2) / 2 + runif(9,-0.2,0),
	latitude = c(2,2,2,1, 1, 1,0,0,0) / 2       + runif(9,-0.2,0)
)
sites
sites = (sites-sapply(sites,mean)) / sapply(sites,sd) 
sites

YM = 10
# Generate yt data frame with three clusters for t1
yt = data.frame(
	t1 = c(rnorm(1,YM),rnorm(1),rnorm(1),rnorm(1,YM),rnorm(2,1),rnorm(1,YM),rnorm(2,-YM)),
	t2 = c(rnorm(2,YM),rnorm(1),rnorm(2,YM),rnorm(1,-YM),rnorm(1,YM),rnorm(2,-YM)),
	t3 = c(rnorm(2,YM),rnorm(1),rnorm(1,YM),rnorm(2,-YM),rnorm(1,YM),rnorm(2,-YM)),
	t4 = c(rnorm(3,YM),rnorm(2,YM),rnorm(1,-YM),rnorm(1,YM),rnorm(2,-YM))
)
yt
clusters_t1 <- cut(yt$t1, breaks = c(-Inf, -5, 5, Inf), labels = c("cl1", "cl2", "cl3"))
clusters_t2 <- cut(yt$t2, breaks = c(-Inf, -5, 5, Inf), labels = c("cl1", "cl2", "cl3"))
clusters_t3 <- cut(yt$t3, breaks = c(-Inf, -5, 5, Inf), labels = c("cl1", "cl2", "cl3"))
clusters_t4 <- cut(yt$t4, breaks = c(-Inf, -5, 5, Inf), labels = c("cl1", "cl2", "cl3"))


boxplot(yt)
cat(sapply(yt,mean),"\n")
cat(sapply(yt,sd),"\n")
# yt = (yt-sapply(yt,mean)) / sapply(yt,sd)
# yt
# boxplot(yt)

yred=yt
cols = colora(size(yred)[1],56,0)
for(i in 1:size(yred)[1]){
	if(i==1){
		plot(1:size(yred)[2],yred[i,],col=cols[i],
			 ylim=extrema(yred),type='l',xlab='weeks',ylab='pm10',main="original clusters")
	} 
	else{
		lines(1:size(yred)[2],yred[i,],col=cols[i])
	}
}

par(mfrow=c(2,2),mar=c(2,2,2,2))
plot(sites,col=clusters_t1,pch=19,cex=1.4,main="t=1 real data")
plot(sites,col=clusters_t2,pch=19,cex=1.4,main="t=2 real data")
plot(sites,col=clusters_t3,pch=19,cex=1.4,main="t=3 real data")
plot(sites,col=clusters_t4,pch=19,cex=1.4,main="t=4 real data")

# yt, sites
time_span = c(1,2,3,4)
```




## fits
```{r}
niter=1000; nburn=500; nthin=2
nout <- (niter-nburn)/nthin
cat(nout,"valid iterations\n")

# params
m0_phi0 = 0
s20_phi0 = 1
A_ub_sigma = 5
a_sigma = 5; b_sigma=2
A_ub_tau = 5
a_tau = 5; b_tau=2
A_ub_lambda = 5
a_lambda = 5; b_lambda=2
eta1_scale = 0.9

sig_mh_sig2 = 0.2
sig_mh_tau2 = 0.2
sig_mh_lambda2 = 0.2
sig_mh_eta1 = 0.2
sig_mh_phi1 = 0.2

mu0 = 0 
k0 = 1
v0 = 5
L0 = 1

a_alpha = 2; b_alpha = 2
```
## drpm C
```{r}
tempo_inizio <- Sys.time()
drpm_c <- drpm_fit(
	y=yt, 
	s_coords = sites,
	M=1,
	initial_partition = NULL,
	
	starting_alpha = 0.5,
	unit_specific_alpha = FALSE,
	time_specific_alpha = TRUE,
	alpha_0=FALSE,
	
	eta1_0=TRUE,
	phi1_0=TRUE,
	# modelPriors=c(0,100^2,1,1,1,1), # original default one
	modelPriors=c(m0_phi0,s20_phi0,A_ub_sigma,A_ub_tau,A_ub_lambda,eta1_scale),
	
	alphaPriors=rbind(c(a_alpha,b_alpha)), # if time_specific_alpha == TRUE
	
	simpleModel = 0,
	theta_tau2 = c(0, 2), # only used if simpleModel=1
	
	SpatialCohesion=3, # auxiliary similarity
	# SpatialCohesion=4, # double dipper similarity
	cParms=c(mu0, k0, v0, L0),
	
	mh=c(sig_mh_sig2,sig_mh_tau2,sig_mh_lambda2,sig_mh_eta1,sig_mh_phi1),
	verbose=TRUE,
	draws=niter,burn=nburn,thin=nthin)

tempo_fine <- Sys.time()
differenza_tempo <- tempo_fine - tempo_inizio
cat(crayon::cyan("Fit took:\n"))
print(round(differenza_tempo,digits = 4))

cat(crayon::red("\nLPML =",drpm1$lpml, "\nWAIC =",drpm1$waic))
```


## diagnostics
```{r}
for (loc in c(1,2,9)){
	for (time in c(1,2,3,4)){
		plot(drpm_c$mu[time,loc,],type="l",
			 main=bquote("Trace plot of " * mu * " at week " * .(time) * " - location " * .(loc)),
			 xlab = "MCMC iterations",ylab="values")
		abline(h=mean(drpm_c$mu[time,loc,]))
	}
}
```



## plot
```{r}
model_name = "simple_test"
loss = "VI"
maxNClusters = 5
df_cluster = data.frame(Longitude=c(),Latitude=c(),values=c(),clusters=c(),Time=c())
for(time in c(1,2,3,4)){
	
	salso_out <- salso(t(drpm_c$Si[time-(min(time_span)-1),,]),
					   loss=binder(a=1),
					   # loss=loss,
					   # loss="VI.lb",
					   maxNClusters = maxNClusters
	)
	
	df_temp = data.frame(
		Longitude = sites$longitude,
		Latitude = sites$latitude,
		clusters = salso_out
	)
	df_temp$Time = rep(time,dim(df_temp)[1])
	df_cluster = rbind(df_cluster,df_temp)
	
	
	
	# clusters log
	clusters_now = df_temp$clusters
	# n_clusters = max(clusters_now)
	n_clusters = unique(clusters_now)
	cat(crayon::red("Time",time,"- #clusters =",length(unique(clusters_now)),"\n"))
	# for (cl in n_clusters){
	# cat("Cluster",cl,"- size",length(ycurrent[which(clusters_now==cl)]),
	# "- mean",mean(ycurrent[which(clusters_now==cl)]),"\n")
	# }
}

library(mclust)
##########################
FIT = drpm_c # your fit
LEN = 4
##########################

# build the ARI matrix
ARImats <- matrix(NA, nrow=LEN, ncol=LEN)
rho_ARI <- list()
for(k in 1:LEN){
	rho_ARI[[k]] <- salso(t(FIT$Si[k,,]),
						  loss=binder(a=1),
						  # loss=loss,
						  # loss="VI.lb",
						  maxNClusters = maxNClusters
	) # adjust with your fit $Si dimension
}
for(k in 1: LEN){
	for(kk in 1: LEN){
		ARImats[k,kk] <- adjustedRandIndex(rho_ARI[[k]], rho_ARI[[kk]])
	}
}
ncols_ari = 100
if (min(ARImats)<0){
	cols_ARI = colora(ncols_ari,79,0)
	brks = seq(floor(min(ARImats)),1,length.out=ncols_ari+1)
} else {
	cols_ARI = colora(ncols_ari,56,0)
	cols_ARI = rev(cols_ARI) # must be ordered from cold to warm
	brks = seq(0,1,length.out=ncols_ari+1)
}
# or see ?designer.colors for colors
library(fields)
image.plot(ARImats,
		   main=paste0("Lagged ARI values - model ",model_name),axes=FALSE,col=cols_ARI,
		   breaks=brks)
mtext(text=c(paste("",1:LEN)), side=2, line=0.3,at=seq(0,1,length=LEN), las=1, cex=0.8)
mtext(text=c(paste("",1:LEN)), side=1, line=0.3,at=seq(0,1,length=LEN), las=2, cex=0.8)


yred=t(drpm_c$fitted[,,size(drpm_c$fitted)[3]])
cols = colora(size(yred)[1],56,0)
for(i in 1:size(yred)[1]){
	if(i==1){
		plot(1:size(yred)[2],yred[i,],col=cols[i],
			 ylim=extrema(yred),type='l',xlab='weeks',ylab='pm10',main="drpm C clusters")
	} 
	else{
		lines(1:size(yred)[2],yred[i,],col=cols[i])
	}
}

par(mfrow=c(2,2),mar=c(2,2,2,2))
cols = as.numeric(df_cluster[df_cluster$Time==1,]$clusters)
plot(sites,col=cols,pch=19,cex=1.4,main="t=1 - from drpm model")

cols = as.numeric(df_cluster[df_cluster$Time==2,]$clusters)
plot(sites,col=cols,pch=19,cex=1.4,main="t=2 - from drpm model")

cols = as.numeric(df_cluster[df_cluster$Time==3,]$clusters)
plot(sites,col=cols,pch=19,cex=1.4,main="t=3 - from drpm model")

cols = as.numeric(df_cluster[df_cluster$Time==4,]$clusters)
plot(sites,col=cols,pch=19,cex=1.4,main="t=4 - from drpm model")
```



## drpm J
```{r}
out = module_JDRPM$MCMC_fit(
	Y=as.matrix(yt),              
	sp_coords = as.matrix(sites),
	M_dp = 1,                     
	initial_partition = NA,
	Xlk_covariates = NA,
	Xcl_covariates = NA,
	
	starting_alpha = 0.5,         
	unit_specific_alpha = FALSE,       
	time_specific_alpha = TRUE,       
	update_alpha = TRUE,             
	
	include_eta1 = TRUE,                    
	include_phi1 = TRUE,
	update_eta1 = FALSE,                    
	update_phi1 = FALSE,
	
	sig2h_priors = c(a_sigma,b_sigma),
	eta1_priors = c(eta1_scale,sig_mh_eta1^2),
	# beta_priors = c(rep(1,p),2),
	beta_priors = NA,
	tau2_priors = c(a_tau,b_tau),
	phi0_priors = c(m0_phi0,s20_phi0),
	phi1_priors = sig_mh_phi1^2,
	lambda2_priors = c(a_lambda,b_lambda),
	alpha_priors = c(a_alpha,b_alpha),  
	
	spatial_cohesion_idx = 4,
	sp_params = list(c(1,2),1,2,matrix(c(1,2,2,4),nrow=2)),
	
	# covariate_similarity_idx = NA,  
	draws = 100,                    
	burnin = 20,                   
	thin = 10,                     
	logging = FALSE,
	seed = seed_choice
)
```

```{r}
rout = juliaGet(out)
names(rout)  = c("Si",
				 "gamma_out",
				 "alpha_out", 
				 "sigma2h_out", 
				 "muh_out", 
				 "eta1_iter",
				 "beta_out",
				 "theta_out", 
				 "tau2_out", 
				 "phi0_out", 
				 "phi1_out",
				 "lambda2_out",
				 "fitted",
				 "llike",
				 "lpml",
				 "waic")

# reshape some stuff to uniform it to drpm output
rout$Si           = aperm(rout$Si,       c(2, 1, 3))
rout$gamma_out    = aperm(rout$gamma_out,    c(2, 1, 3))
rout$sigma2h_out  = aperm(rout$sigma2h_out,  c(2, 1, 3))
rout$muh_out      = aperm(rout$muh_out,      c(2, 1, 3))
rout$alpha_out    = aperm(rout$alpha_out,    c(2, 1))
rout$theta_out    = aperm(rout$theta_out,    c(2, 1))
rout$tau2_out     = aperm(rout$tau2_out,     c(2, 1))
rout$eta1_iter    = aperm(rout$eta1_iter,    c(2, 1))
rout$phi0_out     = matrix(rout$phi0_out,    ncol = 1)
rout$phi1_out     = matrix(rout$phi1_out,    ncol = 1)
rout$lambda2_out  = matrix(rout$lambda2_out, ncol = 1)
```

```{r}
cat("Si           size = ",size(rout$Si),"\n")
cat("gamma_out    size = ",size(rout$gamma_out),"\n")
cat("sigma2h_out  size = ",size(rout$sigma2h_out),"\n")
cat("muh_out      size = ",size(rout$muh_out),"\n")
cat("alpha_out    size = ",size(rout$alpha_out),"\n")
cat("theta_out    size = ",size(rout$theta_out),"\n")
cat("tau2_out     size = ",size(rout$tau2_out),"\n")
cat("eta1_iter    size = ",size(rout$eta1_iter),"\n")
cat("phi0_out     size = ",size(rout$phi0_out),"\n")
cat("phi1_out     size = ",size(rout$phi1_out),"\n")
cat("lambda2_out  size = ",size(rout$lambda2_out),"\n")
cat("beta_out     size = ",size(rout$beta_out),"\n")
cat("fitted       size = ",size(rout$fitted),"\n")
cat("llike        size = ",size(rout$llike),"\n")
```



## plot
```{r}
model_name = "simple_test"
loss = "VI"
maxNClusters = 5
df_cluster = data.frame(Longitude=c(),Latitude=c(),values=c(),clusters=c(),Time=c())
for(time in c(1,2,3,4)){
	
	salso_out <- salso(t(rout$Si[time-(min(time_span)-1),,]),
					   loss=binder(a=1),
					   # loss=loss,
					   # loss="VI.lb",
					   maxNClusters = maxNClusters
	)
	
	df_temp = data.frame(
		Longitude = sites$longitude,
		Latitude = sites$latitude,
		clusters = salso_out
	)
	df_temp$Time = rep(time,dim(df_temp)[1])
	df_cluster = rbind(df_cluster,df_temp)
	
	
	
	# clusters log
	clusters_now = df_temp$clusters
	# n_clusters = max(clusters_now)
	n_clusters = unique(clusters_now)
	cat(crayon::red("Time",time,"- #clusters =",length(unique(clusters_now)),"\n"))
	# for (cl in n_clusters){
	# cat("Cluster",cl,"- size",length(ycurrent[which(clusters_now==cl)]),
	# "- mean",mean(ycurrent[which(clusters_now==cl)]),"\n")
	# }
}

library(mclust)
##########################
FIT = rout # your fit
LEN = 4
##########################

# build the ARI matrix
ARImats <- matrix(NA, nrow=LEN, ncol=LEN)
rho_ARI <- list()
for(k in 1:LEN){
	rho_ARI[[k]] <- salso(t(FIT$Si[k,,]),
						  loss=binder(a=1),
						  # loss=loss,
						  # loss="VI.lb",
						  maxNClusters = maxNClusters
	) # adjust with your fit $Si dimension
}
for(k in 1: LEN){
	for(kk in 1: LEN){
		ARImats[k,kk] <- adjustedRandIndex(rho_ARI[[k]], rho_ARI[[kk]])
	}
}
ncols_ari = 100
if (min(ARImats)<0){
	cols_ARI = colora(ncols_ari,79,0)
	brks = seq(floor(min(ARImats)),1,length.out=ncols_ari+1)
} else {
	cols_ARI = colora(ncols_ari,56,0)
	cols_ARI = rev(cols_ARI) # must be ordered from cold to warm
	brks = seq(0,1,length.out=ncols_ari+1)
}
# or see ?designer.colors for colors
library(fields)
image.plot(ARImats,
		   main=paste0("Lagged ARI values - model ",model_name),axes=FALSE,col=cols_ARI,
		   breaks=brks)
mtext(text=c(paste("",1:LEN)), side=2, line=0.3,at=seq(0,1,length=LEN), las=1, cex=0.8)
mtext(text=c(paste("",1:LEN)), side=1, line=0.3,at=seq(0,1,length=LEN), las=2, cex=0.8)


#### fitted not yet implemented in julia code
# yred=t(rout$fitted[,,size(rout$fitted)[3]])
# cols = colora(size(yred)[1],56,0)
# for(i in 1:size(yred)[1]){
#    if(i==1){
#      plot(1:size(yred)[2],yred[i,],col=cols[i],
#      	 ylim=extrema(yred),type='l',xlab='weeks',ylab='pm10',main="drpm C clusters")
#  	  } 
# 	  else{
# 		  lines(1:size(yred)[2],yred[i,],col=cols[i])
# 	  }
# }

par(mfrow=c(2,2),mar=c(2,2,2,2))
cols = as.numeric(df_cluster[df_cluster$Time==1,]$clusters)
plot(sites,col=cols,pch=19,cex=1.4,main="t=1 - from drpm model")

cols = as.numeric(df_cluster[df_cluster$Time==2,]$clusters)
plot(sites,col=cols,pch=19,cex=1.4,main="t=2 - from drpm model")

cols = as.numeric(df_cluster[df_cluster$Time==3,]$clusters)
plot(sites,col=cols,pch=19,cex=1.4,main="t=3 - from drpm model")

cols = as.numeric(df_cluster[df_cluster$Time==4,]$clusters)
plot(sites,col=cols,pch=19,cex=1.4,main="t=4 - from drpm model")
```



# TRACE PLOTS
## lambda2
```{r}
par(mar=c(4,2,2,2))
par(mfrow=c(1,2))
```


# CL PLOTS
```{r}
######################
# FIT = drpm_C
FIT = rout
model_name = "drpm J"
######################

df_cluster = data.frame(Longitude=c(),Latitude=c(),values=c(),clusters=c(),Time=c())
for(time in time_span){
	
	salso_out <- salso(t(FIT$Si[time-(min(time_span)-1),,]),
					   loss=binder(a=1),
					   # loss="VI",
					   # loss="VI.lb",
					   maxNClusters = 7
	)
	
	df_temp = data.frame(
		Longitude = sites$longitude,
		Latitude = sites$latitude,
		clusters = salso_out[1:105]
	)
	df_temp$Time = rep(time,dim(df_temp)[1])
	df_cluster = rbind(df_cluster,df_temp)
	
	
	
	# clusters log
	clusters_now = df_temp$clusters
	# n_clusters = max(clusters_now)
	n_clusters = unique(clusters_now)
	ycurrent = y[,paste0("w",time)]
	cat(crayon::red("Time",time,"- #clusters =",length(unique(clusters_now)),"\n"))
	# for (cl in n_clusters){
	# cat("Cluster",cl,"- size",length(ycurrent[which(clusters_now==cl)]),
	# "- mean",mean(ycurrent[which(clusters_now==cl)]),"\n")
	# }
}
```
## ari
```{r}
library(mclust)
LEN = max(time_span)

# build the ARI matrix
ARImats <- matrix(NA, nrow=LEN, ncol=LEN)
rho_ARI <- list()
for(k in 1:LEN){
	rho_ARI[[k]] <- salso(t(FIT$Si[k,,]),
						  loss=binder(a=1),
						  # loss="VI",
						  # loss="VI.lb",
						  maxNClusters =7
	) # adjust with your fit $Si dimension
}
for(k in 1: LEN){
	for(kk in 1: LEN){
		ARImats[k,kk] <- adjustedRandIndex(rho_ARI[[k]], rho_ARI[[kk]])
	}
}
hist(ARImats)
# pdf(paste0("./figures/Federico/LaggedARI_",model_name,".pdf"), height=8, width=10)
ncols_ari = 100
if (min(ARImats)<0){
	cols_ARI = colora(ncols_ari,79,0)
	brks = seq(floor(min(ARImats)),1,length.out=ncols_ari+1)
} else {
	cols_ARI = colora(ncols_ari,56,0)
	cols_ARI = rev(cols_ARI) # must be ordered from cold to warm
	brks = seq(0,1,length.out=ncols_ari+1)
}
# or see ?designer.colors for colors
library(fields)
image.plot(ARImats,
		   main=paste0("Lagged ARI values - model ",model_name),axes=FALSE,col=cols_ARI,
		   breaks=brks)
mtext(text=c(paste("",1:LEN)), side=2, line=0.3,at=seq(0,1,length=LEN), las=1, cex=0.8)
mtext(text=c(paste("",1:LEN)), side=1, line=0.3,at=seq(0,1,length=LEN), las=2, cex=0.8)
# dev.off()
```


## heat plot
```{r}
clusters_old = NULL
for(time in time_span){
	cat(crayon::red("Time",time,"\n"))
	
	df_cluster_cut = df_cluster[df_cluster$Time==time,]
	clusters_now = df_cluster_cut$clusters
	####### no mode correct now
	# clusters_now = mode_correct_clusters(clusters_old,clusters_now,very_verbose = 0)
	# se fai heat plot non serve fare la mode correct
	# perché la heat plot la usi per vedere anche i valori di pm10, non la coerenza temporale
	# nei gruppi, che con la heat coloration si perde come visibilità (non so se è chiaro)
	df_cluster_cut$clusters = clusters_now
	
	# meglio l'idea 1
	cols = color_correct_clusters(df_cluster_cut,idea=1,verbose=0)
	
	# q = get_graph_plot(df_cluster_cut,cols)
	# print(q)
	p = plot_graph_and_hist(df_cluster_cut,cols)
	
	clusters_old = clusters_now
	
}
```









