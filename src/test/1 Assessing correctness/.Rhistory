colnames(yfull)<- c("id",paste0("w", 1:53))
time_span = 1:20 # low time span for quick testing, real one will be 1:53
### alcuni a caso:
# quanti = 7; nsubjects = sample(1:105, quanti,replace = F)
### alcuni:
# nsubjects = 1:10
### tutti:
nsubjects = 1:105
y = yfull[nsubjects,1+time_span]
#############################################
# authors suggested to/did scale the spatial locations and also centered the observations
mn <- apply(y,2,mean)
sd <- apply(y,2,sd)
y <- t(t(y) - mn)
Tm = tps <- ncol(y) # time span
N = size(y)[1] # number of units
num_units = N
sites = sites[nsubjects,]
smn <- apply(sites,2,mean)
ssd <- apply(sites,2,sd)
s_std <- t((t(sites) - smn)/ssd)
########################################
yred=y[,time_span]
par(mar=c(4,4,2,2))
cols = colora(size(yred)[1],56,0)
for(i in 1:size(yred)[1]){
if(i==1){
plot(1:size(yred)[2],yred[i,],col=cols[i],ylim=extrema(yred),type='l',xlab='weeks',ylab='pm10')
}
else{
lines(1:size(yred)[2],yred[i,],col=cols[i])
}
}
# -> we have
y
s_std
sites = data.frame(
longitude = unique(df_weekly$Longitude),
latitude = unique(df_weekly$Latitude))
std_sites = data.frame(
longitude = unique(df_wsc$Longitude),
latitude = unique(df_wsc$Latitude))
stations = unique(df_wsc$IDStations)
yfull=data.frame()
target = "AQ_pm10"
# target = "WE_tot_precipitation"
for(st in stations){
y_we_pm10=cbind(as.data.frame(st),t(df_wsc[which(df_wsc$IDStations==st),target]))
yfull=rbind(yfull,y_we_pm10)
}
rownames(yfull) = NULL
colnames(yfull)<- c("id",paste0("w", 1:53))
time_span = 1:53 # low time span for quick testing, real one will be 1:53
### alcuni a caso:
# quanti = 7; nsubjects = sample(1:105, quanti,replace = F)
### alcuni:
# nsubjects = 1:10
### tutti:
nsubjects = 1:20
y = yfull[nsubjects,1+time_span]
#############################################
# authors suggested to/did scale the spatial locations and also centered the observations
mn <- apply(y,2,mean)
sd <- apply(y,2,sd)
y <- t(t(y) - mn)
Tm = tps <- ncol(y) # time span
N = size(y)[1] # number of units
num_units = N
sites = sites[nsubjects,]
smn <- apply(sites,2,mean)
ssd <- apply(sites,2,sd)
s_std <- t((t(sites) - smn)/ssd)
########################################
yred=y[,time_span]
par(mar=c(4,4,2,2))
cols = colora(size(yred)[1],56,0)
for(i in 1:size(yred)[1]){
if(i==1){
plot(1:size(yred)[2],yred[i,],col=cols[i],ylim=extrema(yred),type='l',xlab='weeks',ylab='pm10')
}
else{
lines(1:size(yred)[2],yred[i,],col=cols[i])
}
}
# -> we have
y
s_std
sites = data.frame(
longitude = unique(df_weekly$Longitude),
latitude = unique(df_weekly$Latitude))
std_sites = data.frame(
longitude = unique(df_wsc$Longitude),
latitude = unique(df_wsc$Latitude))
stations = unique(df_wsc$IDStations)
yfull=data.frame()
target = "AQ_pm10"
# target = "WE_tot_precipitation"
for(st in stations){
y_we_pm10=cbind(as.data.frame(st),t(df_wsc[which(df_wsc$IDStations==st),target]))
yfull=rbind(yfull,y_we_pm10)
}
rownames(yfull) = NULL
colnames(yfull)<- c("id",paste0("w", 1:53))
time_span = 1:53 # low time span for quick testing, real one will be 1:53
### alcuni a caso:
set.seed(2345)
quanti = 7; nsubjects = sample(1:105, quanti,replace = F)
### alcuni:
# nsubjects = 1:10
### tutti:
# nsubjects = 1:20
y = yfull[nsubjects,1+time_span]
#############################################
# authors suggested to/did scale the spatial locations and also centered the observations
mn <- apply(y,2,mean)
sd <- apply(y,2,sd)
y <- t(t(y) - mn)
Tm = tps <- ncol(y) # time span
N = size(y)[1] # number of units
num_units = N
sites = sites[nsubjects,]
smn <- apply(sites,2,mean)
ssd <- apply(sites,2,sd)
s_std <- t((t(sites) - smn)/ssd)
########################################
yred=y[,time_span]
par(mar=c(4,4,2,2))
cols = colora(size(yred)[1],56,0)
for(i in 1:size(yred)[1]){
if(i==1){
plot(1:size(yred)[2],yred[i,],col=cols[i],ylim=extrema(yred),type='l',xlab='weeks',ylab='pm10')
}
else{
lines(1:size(yred)[2],yred[i,],col=cols[i])
}
}
# -> we have
y
s_std
sites = data.frame(
longitude = unique(df_weekly$Longitude),
latitude = unique(df_weekly$Latitude))
std_sites = data.frame(
longitude = unique(df_wsc$Longitude),
latitude = unique(df_wsc$Latitude))
stations = unique(df_wsc$IDStations)
yfull=data.frame()
target = "AQ_pm10"
# target = "WE_tot_precipitation"
for(st in stations){
y_we_pm10=cbind(as.data.frame(st),t(df_wsc[which(df_wsc$IDStations==st),target]))
yfull=rbind(yfull,y_we_pm10)
}
rownames(yfull) = NULL
colnames(yfull)<- c("id",paste0("w", 1:53))
time_span = 1:53 # low time span for quick testing, real one will be 1:53
### alcuni a caso:
# set.seed(2345)
set.seed(1)
quanti = 7; nsubjects = sample(1:105, quanti,replace = F)
### alcuni:
# nsubjects = 1:10
### tutti:
# nsubjects = 1:20
y = yfull[nsubjects,1+time_span]
#############################################
# authors suggested to/did scale the spatial locations and also centered the observations
mn <- apply(y,2,mean)
sd <- apply(y,2,sd)
y <- t(t(y) - mn)
Tm = tps <- ncol(y) # time span
N = size(y)[1] # number of units
num_units = N
sites = sites[nsubjects,]
smn <- apply(sites,2,mean)
ssd <- apply(sites,2,sd)
s_std <- t((t(sites) - smn)/ssd)
########################################
yred=y[,time_span]
par(mar=c(4,4,2,2))
cols = colora(size(yred)[1],56,0)
for(i in 1:size(yred)[1]){
if(i==1){
plot(1:size(yred)[2],yred[i,],col=cols[i],ylim=extrema(yred),type='l',xlab='weeks',ylab='pm10')
}
else{
lines(1:size(yred)[2],yred[i,],col=cols[i])
}
}
# -> we have
y
s_std
sites = data.frame(
longitude = unique(df_weekly$Longitude),
latitude = unique(df_weekly$Latitude))
std_sites = data.frame(
longitude = unique(df_wsc$Longitude),
latitude = unique(df_wsc$Latitude))
stations = unique(df_wsc$IDStations)
yfull=data.frame()
target = "AQ_pm10"
# target = "WE_tot_precipitation"
for(st in stations){
y_we_pm10=cbind(as.data.frame(st),t(df_wsc[which(df_wsc$IDStations==st),target]))
yfull=rbind(yfull,y_we_pm10)
}
rownames(yfull) = NULL
colnames(yfull)<- c("id",paste0("w", 1:53))
time_span = 1:53 # low time span for quick testing, real one will be 1:53
### alcuni a caso:
# set.seed(2345)
set.seed(1)
quanti = 20; nsubjects = sample(1:105, quanti,replace = F)
### alcuni:
# nsubjects = 1:10
### tutti:
# nsubjects = 1:20
y = yfull[nsubjects,1+time_span]
#############################################
# authors suggested to/did scale the spatial locations and also centered the observations
mn <- apply(y,2,mean)
sd <- apply(y,2,sd)
y <- t(t(y) - mn)
Tm = tps <- ncol(y) # time span
N = size(y)[1] # number of units
num_units = N
sites = sites[nsubjects,]
smn <- apply(sites,2,mean)
ssd <- apply(sites,2,sd)
s_std <- t((t(sites) - smn)/ssd)
########################################
yred=y[,time_span]
par(mar=c(4,4,2,2))
cols = colora(size(yred)[1],56,0)
for(i in 1:size(yred)[1]){
if(i==1){
plot(1:size(yred)[2],yred[i,],col=cols[i],ylim=extrema(yred),type='l',xlab='weeks',ylab='pm10')
}
else{
lines(1:size(yred)[2],yred[i,],col=cols[i])
}
}
# -> we have
y
s_std
s_std
# as.integer(runif(1,0,1000))*1.0
# seed = 881.0
seed = 314.0
cat("seed",seed,"\n")
# niter=1000; nburn=500; nthin=2
# niter=50000; nburn=10000; nthin=40 # they did this in their tests
# niter=30000; nburn=20000; nthin=10
niter=50000; nburn=30000; nthin=20
# niter=80000; nburn=60000; nthin=20
nout <- (niter-nburn)/nthin
cat(nout,"valid iterations\n")
# params
m0_phi0 = 0
s20_phi0 = 10
A_ub_sigma = 5
A_ub_tau = 5
A_ub_lambda = 5
a_sigma  = 2; b_sigma  = 2
a_tau    = 2; b_tau    = 2
a_lambda = 2; b_lambda = 2
eta1_scale = 0.9
# mh is the of gaussian standard deviations for metropolis updates
# So these are not variances!
sig_mh_sig2 = 0.3
sig_mh_tau2 = 0.3
sig_mh_lambda2 = 0.3
sig_mh_eta1 = 0.3
sig_mh_phi1 = 0.3
update_eta1 = TRUE
update_phi1 = TRUE
a_alpha = 2; b_alpha = 2
time_specific_alpha = TRUE
# now space
spatial_cohesion = 3
mu0 = 0
k0 = 1
v0 = 5
L0 = 1
tempo_inizio <- Sys.time()
drpm1 <- drpm_fit(
y=y,
s_coords = s_std,
M=1,
initial_partition = NULL,
starting_alpha = 0.5,
unit_specific_alpha = FALSE,
time_specific_alpha = time_specific_alpha,
alpha_0=FALSE,
eta1_0=!(update_eta1),
phi1_0=!(update_phi1),
# modelPriors=c(0,100^2,1,1,1,1), # original default one
modelPriors=c(m0_phi0,s20_phi0,A_ub_sigma,A_ub_tau,A_ub_lambda,eta1_scale),
alphaPriors=rbind(c(a_alpha,b_alpha)), # if time_specific_alpha == TRUE
simpleModel = 0,
theta_tau2 = c(0, 2), # only used if simpleModel=1
SpatialCohesion=spatial_cohesion, # auxiliary similarity
# SpatialCohesion=4, # double dipper similarity
cParms=c(mu0, k0, v0, L0),
mh=c(sig_mh_sig2,sig_mh_tau2,sig_mh_lambda2,sig_mh_eta1,sig_mh_phi1),
verbose=TRUE,
# draws=1000,burn=0,thin=1)
draws=niter,burn=nburn,thin=nthin)
tempo_fine <- Sys.time()
differenza_tempo <- tempo_fine - tempo_inizio
cat(crayon::cyan("Fit took:\n"))
print(round(differenza_tempo,digits = 4))
cat(crayon::red("\nLPML =",drpm1$lpml, "\nWAIC =",drpm1$waic))
module_JDRPM <- juliaImport(juliaCall("include", module))
out = module_JDRPM$MCMC_fit(
Y=as.matrix(y),
sp_coords = s_std,
M_dp = 1,
initial_partition = NA,
starting_alpha = 0.5,
unit_specific_alpha = FALSE,
time_specific_alpha = time_specific_alpha,
update_alpha = TRUE,
include_eta1 = TRUE,
include_phi1 = TRUE,
update_eta1 = update_eta1,
update_phi1 = update_phi1,
sig2h_priors = c(a_sigma,b_sigma),
eta1_priors = c(eta1_scale,sig_mh_eta1^2),
tau2_priors = c(a_tau,b_tau),
phi0_priors = c(m0_phi0,s20_phi0),
phi1_priors = sig_mh_phi1^2,
lambda2_priors = c(a_lambda,b_lambda),
alpha_priors = c(a_alpha,b_alpha),
######## space
spatial_cohesion_idx = spatial_cohesion,
sp_params = list(c(mu0,mu0),k0,v0,matrix(c(L0,0.0,0.0,L0),nrow=2)),
######## likelihood covariates
# Xlk_covariates = X_lk, beta_priors = c(rep(0,p),1),
# Xlk_covariates = NA, beta_priors = NA,
######## clustering covariates
# covariate_similarity_idx = 4,
# cv_params = list(0,1,2,2),
# Xcl_covariates = X_cl,
draws = niter, burnin = nburn, thin = nthin,
# draws = 5, burnin = 0, thin = 1,
logging = TRUE,
seed = seed
)
module_JDRPM <- juliaImport(juliaCall("include", module))
out = module_JDRPM$MCMC_fit(
Y=as.matrix(y),
sp_coords = s_std,
M_dp = 1,
initial_partition = NA,
starting_alpha = 0.5,
unit_specific_alpha = FALSE,
time_specific_alpha = time_specific_alpha,
update_alpha = TRUE,
include_eta1 = TRUE,
include_phi1 = TRUE,
update_eta1 = update_eta1,
update_phi1 = update_phi1,
sig2h_priors = c(a_sigma,b_sigma),
eta1_priors = c(eta1_scale,sig_mh_eta1^2),
tau2_priors = c(a_tau,b_tau),
phi0_priors = c(m0_phi0,s20_phi0),
phi1_priors = sig_mh_phi1^2,
lambda2_priors = c(a_lambda,b_lambda),
alpha_priors = c(a_alpha,b_alpha),
######## space
spatial_cohesion_idx = spatial_cohesion,
sp_params = list(c(mu0,mu0),k0,v0,matrix(c(L0,0.0,0.0,L0),nrow=2)),
######## likelihood covariates
# Xlk_covariates = X_lk, beta_priors = c(rep(0,p),1),
# Xlk_covariates = NA, beta_priors = NA,
######## clustering covariates
# covariate_similarity_idx = 4,
# cv_params = list(0,1,2,2),
# Xcl_covariates = X_cl,
draws = niter, burnin = nburn, thin = nthin,
# draws = 5, burnin = 0, thin = 1,
logging = FALSE,
seed = seed
)
rout = juliaGet(out)
names(rout)  = c("Si",
"gamma",
"alpha",
"sigma2h",
"muh",
"eta1",
"beta",
"theta",
"tau2",
"phi0",
"phi1",
"lambda2",
"fitted",
"llike",
"lpml",
"waic")
# reshape some stuff to uniform it to drpm output
rout$Si           = aperm(rout$Si,       c(2, 1, 3))
rout$gamma        = aperm(rout$gamma,    c(2, 1, 3))
rout$sigma2h      = aperm(rout$sigma2h,  c(2, 1, 3))
rout$muh          = aperm(rout$muh,      c(2, 1, 3))
rout$fitted       = aperm(rout$fitted,   c(2, 1, 3))
rout$llike        = aperm(rout$llike,    c(2, 1, 3))
rout$alpha        = aperm(rout$alpha,    c(2, 1))
rout$theta        = aperm(rout$theta,    c(2, 1))
rout$tau2         = aperm(rout$tau2,     c(2, 1))
rout$eta1         = aperm(rout$eta1,    c(2, 1))
rout$phi0     = matrix(rout$phi0,    ncol = 1)
rout$phi1     = matrix(rout$phi1,    ncol = 1)
rout$lambda2  = matrix(rout$lambda2, ncol = 1)
cat(crayon::red("\nLPML =",rout$lpml, "\nWAIC =",rout$waic))
for (time in 1:Tm){
par(mfrow=c(1,2),mar=c(2,2,4,2))
plot(drpm1$alpha[,time],type="l",
main=bquote("Model DRPM C\nTrace plot of alpha at time "*.(time)
), ylim=c(0,1),
xlab = "MCMC iterations",ylab="values")
plot(rout$alpha[,time],type="l",
main=bquote("Model DRPM J\nTrace plot of alpha at time "*.(time)
), ylim=c(0,1),
xlab = "MCMC iterations",ylab="values")
}
dim(drpm1$eta1)
dim(rout$eta1)
cat("did we update eta1?", update_eta1)
for (unit in 1:N){
par(mfrow=c(1,2),mar=c(2,2,4,2))
plot(drpm1$eta1[,unit],type="l",
ylim=c(min(drpm1$eta1[,unit],rout$eta1[,unit]),
max(drpm1$eta1[,unit],rout$eta1[,unit])),
main=bquote("Model DRPM C\nTrace plot of eta1 at unit "*.(unit)),
xlab = "MCMC iterations",ylab="values")
plot(rout$eta1[,unit],type="l",
ylim=c(min(drpm1$eta1[,unit],rout$eta1[,unit]),
max(drpm1$eta1[,unit],rout$eta1[,unit])),
main=bquote("Model DRPM J\nTrace plot of eta1 at unit "*.(unit)),
xlab = "MCMC iterations",ylab="values")
}
dim(drpm1$phi1)
dim(rout$phi1)
cat("did we update phi1?", update_phi1)
par(mfrow=c(1,2),mar=c(2,2,4,2))
plot(drpm1$phi1[,1],type="l",
ylim=c(min(drpm1$phi1[,1],rout$phi1[,1]),
max(drpm1$phi1[,1],rout$phi1[,1])),
main=bquote("Model DRPM C\nTrace plot of phi1"),
xlab = "MCMC iterations",ylab="values")
plot(rout$phi1[,1],type="l",
ylim=c(min(drpm1$phi1[,1],rout$phi1[,1]),
max(drpm1$phi1[,1],rout$phi1[,1])),
main=bquote("Model DRPM J\nTrace plot of phi1"),
xlab = "MCMC iterations",ylab="values")
dim(drpm1$phi0)
dim(rout$phi0)
par(mfrow=c(1,2),mar=c(2,2,4,2))
plot(drpm1$phi0[,1],type="l",
ylim=c(min(drpm1$phi0[,1],rout$phi0[,1]),
max(drpm1$phi0[,1],rout$phi0[,1])),
main=bquote("Model DRPM C\nTrace plot of phi0"),
xlab = "MCMC iterations",ylab="values")
plot(rout$phi0[,1],type="l",
ylim=c(min(drpm1$phi0[,1],rout$phi0[,1]),
max(drpm1$phi0[,1],rout$phi0[,1])),
main=bquote("Model DRPM J\nTrace plot of phi0"),
xlab = "MCMC iterations",ylab="values")
dim(drpm1$lam2)
dim(rout$lambda2)
par(mfrow=c(1,2),mar=c(2,2,4,2))
plot(drpm1$lam2[,1],type="l",
ylim=c(min(drpm1$lam2[,1],rout$lambda2[,1]),
max(drpm1$lam2[,1],rout$lambda2[,1])),
main=bquote("Model DRPM C\nTrace plot of lambda2"),
xlab = "MCMC iterations",ylab="values")
plot(rout$lambda2[,1],type="l",
ylim=c(min(drpm1$lam2[,1],rout$lambda2[,1]),
max(drpm1$lam2[,1],rout$lambda2[,1])),
main=bquote("Model DRPM J\nTrace plot of lambda2"),
xlab = "MCMC iterations",ylab="values")
# params
m0_phi0 = 0
s20_phi0 = 10
A_ub_sigma = 5
A_ub_tau = 5
A_ub_lambda = 5
a_sigma  = 2; b_sigma  = 2
a_tau    = 2; b_tau    = 2
a_lambda = 2; b_lambda = 2
eta1_scale = 0.9
# mh is the of gaussian standard deviations for metropolis updates
# So these are not variances!
sig_mh_sig2 = 0.3
sig_mh_tau2 = 0.3
sig_mh_lambda2 = 0.3
sig_mh_eta1 = 0.2
sig_mh_phi1 = 0.2
update_eta1 = TRUE
update_phi1 = TRUE
a_alpha = 2; b_alpha = 2
time_specific_alpha = TRUE
# now space
spatial_cohesion = 3
mu0 = 0
k0 = 1
v0 = 5
L0 = 1
module_JDRPM <- juliaImport(juliaCall("include", module))
