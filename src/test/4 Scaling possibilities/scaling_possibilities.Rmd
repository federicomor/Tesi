---
title: "Untitled"
output: html_document
---


# setup
```{r, warning=FALSE}
library(salso)
library(RColorBrewer)
source("../include.R")
```



# LOAD 
## load C drpm
```{r}
devtools::load_all("../../drpm_main/")
# devtools::load_all("../../drpm_sporcato//")
```

## load J drpm
```{r}
library(JuliaConnectoR)
juliaSetupOk()

# juliaEval("using Pkg")
# juliaEval("Pkg.activate(\"../../JDRPM\")")
# juliaEval("Pkg.instantiate()")

# juliaEval("Pkg.status()")
# setup project
juliaEval("using Pkg; Pkg.status()")
juliaEval("Pkg.activate(\"../../JDRPM\")")
juliaEval("using Pkg; Pkg.status()")

module = normalizePath("../../JDRPM/src/JDRPM.jl")
module_JDRPM <- juliaImport(juliaCall("include", module))

module_JDRPM$trigger_compilation()
```

# ===========

# real DATA
```{r}
load("../thesis data/df_daily_full_logtransf.Rdata")
df = df_daily_full_logtransf

std_sites = data.frame(
	longitude = unique(df$Longitude), 
	latitude = unique(df$Latitude))
stations = unique(df$IDStations)
yfull=data.frame()

target = "AQ_pm10"
# target = "WE_tot_precipitation"
for(st in stations){
	y_we_pm10=cbind(as.data.frame(st),t(df[which(df$IDStations==st),target]))
	yfull=rbind(yfull,y_we_pm10)
}

yfull_2years = cbind(yfull,yfull[,2:365])
rownames(yfull_2years) = NULL
colnames(yfull_2years)<- c("id",paste0("d", 1:729))

rownames(yfull) = NULL
colnames(yfull)<- c("id",paste0("d", 1:365))

#######################################################
# reduce data set
# time_span = 1:365 # up to 365
time_span = 1:700 # up to 729
nsubjects = 1:5 # up to 105

# y = yfull[nsubjects,1+time_span]
y = yfull_2years[nsubjects,1+time_span]
sites = std_sites[nsubjects,]

yred=y[,time_span]
par(mar=c(4,4,2,2))
cols = colora(size(yred)[1],56,0)
for(i in 1:size(yred)[1]){
   if(i==1){
     plot(1:size(yred)[2],yred[i,],col=cols[i],
     	 ylim=extrema(as.matrix(yred)),
     	 type='l',xlab='weeks',ylab='pm10')
 	  } 
	  else{
		  lines(1:size(yred)[2],yred[i,],col=cols[i])
	  }
}
# -> we have
y
sites
```

# synth DATA
```{r}
create_data = function(N,Tm,p_cl=1, p_lk=1){
	y = matrix(data=runif(N*Tm),nrow = N,ncol = Tm)
	sp_coords = matrix(data=runif(N*2),nrow=N)
	X_cl = array(data = runif(N*p_cl*Tm), dim = c(N, p_cl, Tm))
	X_lk = array(data = runif(N*p_lk*Tm), dim = c(N, p_lk, Tm))
	return(list(y,sp_coords,X_cl, X_lk))
}
out = create_data(10,3)
y = out[[1]]
sp_coords = out[[2]]
X_cl = out[[3]]
X_lk = out[[4]]
```


# Fit params
```{r}
# params
m0_phi0 = 0
s20_phi0 = 10
A_ub_sigma = 7
A_ub_tau = 5
A_ub_lambda = 5

a_sigma  = 0.01; b_sigma  = 0.01
a_tau    = 1.9; b_tau    = 0.4
a_lambda = 1.9; b_lambda = 0.4
eta1_scale = 0.9

sig_mh_sig2 = 0.1
sig_mh_tau2 = 0.1
sig_mh_lambda2 = 0.1
sig_mh_eta1 = 0.1
sig_mh_phi1 = 0.1

update_eta1 = TRUE
update_phi1 = TRUE

a_alpha = 2; b_alpha = 2

# now space
spatial_cohesion = 3
mu0 = 0 
k0 = 1
v0 = 5
L0 = 1
```



# Fit
```{r}
# timespan_tests = round(seq(10,364,length.out=2))
nunits_tests =   round(seq(10,105,length.out=4))
timespan_tests = round(seq(10,729,length.out=8))

nruns_tests    = rep(3,5)
#### target & space
# nunits_tests   = c(5,10,50,100,250)
# timespan_tests = c(5,10,50,100,250)

#### target 
nunits_tests   = c(10,50,100,250)
timespan_tests = c(10,50,100,250)

niter_tests = matrix(0,nrow=length(nunits_tests),ncol=lenght(timespan_tests))
for (i in 1:length(nunits_tests)) {
	for (j in 1:length(timespan_tests)) {
		niter_tests[i,j] = 10000/(nunits_tests[i]*timespan_tests[j])*100
		# niter_tests[i,j] = 10000/(min(nunits_tests[i],timespan_tests[j]))*100
	}
}
nruns_tests
niter_tests
timespan_tests
nunits_tests

cat("size =",length(timespan_tests)*length(nunits_tests),"\n")

performance_C <- matrix(1e5, nrow = length(nunits_tests), ncol = length(timespan_tests))
performance_Julia <- matrix(1e5, nrow = length(nunits_tests), ncol = length(timespan_tests))
colnames(performance_C) = c(paste0("T_",timespan_tests))
rownames(performance_C) = c(paste0("n_",nunits_tests))
colnames(performance_Julia) = c(paste0("T_",timespan_tests))
rownames(performance_Julia) = c(paste0("n_",nunits_tests))

performance_C
performance_Julia
```


```{r}
# load("performance_C_ext1.Rdata")
# load("performance_Julia_ext1.Rdata")
```


```{r}
library(lubridate)
module_JDRPM <- juliaImport(juliaCall("include", module))

seed = 2.0
set.seed(2.0)

for (i in 1:length(nunits_tests)) {
  for (j in 1:length(timespan_tests)) {
  	
  	##### set data accordingly
	# reduce data set
	# nsubjects = 1:nunits_tests[i] # up to 105
	# time_span = 1:timespan_tests[j] # up to 365
	# y = yfull_2years[nsubjects,1+time_span]
	# ym = as.matrix(y)
	# sites = std_sites[nsubjects,]
	# sitesm = as.matrix(sites)
	
	out = create_data(nunits_tests[i],timespan_tests[j])
	y = out[[1]]
	sites = out[[2]]
	X_cl = out[[3]]
	X_lk = out[[4]]

	niter = niter_tests[i,j]
	nruns = nruns_tests[i]
	
	cat(crayon::green("##########",niter,"iterations\n"))
	nburn = niter-1
	nthin = 1
  	##### fit models
		
	##### J
	for (run in 1:nruns){
		tempo_inizio <- proc.time()
		out = module_JDRPM$MCMC_fit(
			Y=y,              
			# sp_coords = sites,
			M_dp = 1,                     
			initial_partition = NA,
			Xlk_covariates = NA,
			Xcl_covariates = NA,
			starting_alpha = 0.5,         
			unit_specific_alpha = FALSE,       
			time_specific_alpha = TRUE,       
			update_alpha = TRUE,
			include_eta1 = TRUE,                    
			include_phi1 = TRUE,
			update_eta1 = TRUE,                    
			update_phi1 = TRUE,
			sig2h_priors = c(a_sigma,b_sigma),
			eta1_priors = c(eta1_scale,sig_mh_eta1),
			# beta_priors = c(rep(1,p),2),
			beta_priors = NA,
			tau2_priors = c(a_tau,b_tau),
			phi0_priors = c(m0_phi0,s20_phi0),
			phi1_priors = sig_mh_phi1,
			lambda2_priors = c(a_lambda,b_lambda),
			alpha_priors = c(a_alpha,b_alpha),
			spatial_cohesion_idx = spatial_cohesion,
			sp_params = list(c(mu0,mu0),k0,v0,matrix(c(L0,0.0,0.0,L0),nrow=2)),
			# covariate_similarity_idx = NA,
			# draws = 2,burnin = 0, thin = 1,
			draws = niter,burnin = nburn, thin = nthin,
			logging = FALSE,
			seed = seed,
			simple_return = TRUE
		)
		tempo_fine <- proc.time()
		elapsed_time <- tempo_fine - tempo_inizio
		# Elapsed time in seconds
		differenza_tempo <- elapsed_time["elapsed"]
		cat(crayon::red(paste0("J case i=",i," j=",j," elapsed: ",differenza_tempo," s\n\n")))
		performance_Julia[i, j] = min(performance_Julia[i, j],
									  as.double(differenza_tempo) / niter)
	# }
	
	##### C	
	# for (run in 1:nruns){
  	tempo_inizio <- proc.time()
	drpm1 <- drpm_fit(
			y=y, 
			# s_coords = sites,
	        M=1,
	        initial_partition = NULL,
	        starting_alpha = 0.5,
	        unit_specific_alpha = FALSE,
	        time_specific_alpha = TRUE,
	        alpha_0=FALSE,
	        eta1_0 =FALSE,
	        phi1_0 =FALSE,
	        # modelPriors=c(0,100^2,1,1,1,1), # original default one
	        modelPriors=c(m0_phi0,s20_phi0,A_ub_sigma,A_ub_tau,A_ub_lambda,eta1_scale),
	        alphaPriors=rbind(c(a_alpha,b_alpha)), # if time_specific_alpha == TRUE
	        simpleModel = 0,
	        theta_tau2 = c(0, 2), # only used if simpleModel=1
			SpatialCohesion=spatial_cohesion, # auxiliary similarity
			# SpatialCohesion=4, # double dipper similarity
			cParms=c(mu0, k0, v0, L0),
			mh=c(sig_mh_sig2,sig_mh_tau2,sig_mh_lambda2,sig_mh_eta1,sig_mh_phi1),
			verbose=TRUE,
			# draws=1000,burn=0,thin=1)
			draws=niter,burn=nburn,thin=nthin)
		cat("\nLPML =",drpm1$lpml, "\nWAIC =",drpm1$waic,"\n")

		tempo_fine <- proc.time()
		elapsed_time <- tempo_fine - tempo_inizio
		# Elapsed time in seconds
		differenza_tempo <- elapsed_time["elapsed"]
		cat(crayon::red(paste0("C case i=",i," j=",j," elapsed: ",differenza_tempo," s\n\n")))
		performance_C[i, j] = min(performance_C[i, j],
								  as.double(differenza_tempo) / niter)
	}
  }
}
```
# refine cases
```{r}
# module_JDRPM <- juliaImport(juliaCall("include", module))
i=3
j=4
nruns=2
fit_also_C = F
seed = 3.0
	
##### set data accordingly
# reduce data set
# nsubjects = 1:nunits_tests[i] # up to 105
# time_span = 1:timespan_tests[j] # up to 365
# y = yfull_2years[nsubjects,1+time_span]
# ym = as.matrix(y)
# sites = std_sites[nsubjects,]
# sitesm = as.matrix(sites)

out = create_data(nunits_tests[i],timespan_tests[j])
y = out[[1]]
sites = out[[2]]
X_cl = out[[3]]
X_lk = out[[4]]

# niter = niter_tests[i,j]
niter = 8
cat(crayon::green("N",nunits_tests[i],"T",timespan_tests[j],"\n"))
cat(crayon::green("##########",niter,"iterations\n"))
nburn = niter-2
nthin = 1
 ##### fit models
	
##### J
for (run in 1:nruns){
	tempo_inizio <- proc.time()
	out = module_JDRPM$MCMC_fit(
		Y=y,              
		# sp_coords = sites,
		M_dp = 1,                     
		initial_partition = NA,
		Xlk_covariates = NA,
		Xcl_covariates = NA,
		starting_alpha = 0.5,         
		unit_specific_alpha = FALSE,       
		time_specific_alpha = TRUE,       
		update_alpha = TRUE,
		include_eta1 = TRUE,                    
		include_phi1 = TRUE,
		update_eta1 = TRUE,                    
		update_phi1 = TRUE,
		sig2h_priors = c(a_sigma,b_sigma),
		eta1_priors = c(eta1_scale,sig_mh_eta1),
		# beta_priors = c(rep(1,p),2),
		beta_priors = NA,
		tau2_priors = c(a_tau,b_tau),
		phi0_priors = c(m0_phi0,s20_phi0),
		phi1_priors = sig_mh_phi1,
		lambda2_priors = c(a_lambda,b_lambda),
		alpha_priors = c(a_alpha,b_alpha),
		spatial_cohesion_idx = spatial_cohesion,
		sp_params = list(c(mu0,mu0),k0,v0,matrix(c(L0,0.0,0.0,L0),nrow=2)),
		# covariate_similarity_idx = NA,
		# draws = 2,burnin = 0, thin = 1,
		draws = niter,burnin = nburn, thin = nthin,
		logging = FALSE,
		seed = seed,
		simple_return = TRUE,
		skip_checks = T
	)
	tempo_fine <- proc.time()
	elapsed_time <- tempo_fine - tempo_inizio
	# Elapsed time in seconds
	differenza_tempo <- elapsed_time["elapsed"]
	cat(crayon::red(paste0("J case i=",i," j=",j," elapsed: ",differenza_tempo," s\n\n")))
	performance_Julia[i, j] = min(performance_Julia[i, j],
								  as.double(differenza_tempo) / niter)

#### C
if (fit_also_C==T){
tempo_inizio <- proc.time()
drpm1 <- drpm_fit(
		y=y,
		s_coords = sites,
        M=1,
        initial_partition = NULL,
        starting_alpha = 0.5,
        unit_specific_alpha = FALSE,
        time_specific_alpha = TRUE,
        alpha_0=FALSE,
        eta1_0 =FALSE,
        phi1_0 =FALSE,
        # modelPriors=c(0,100^2,1,1,1,1), # original default one
        modelPriors=c(m0_phi0,s20_phi0,A_ub_sigma,A_ub_tau,A_ub_lambda,eta1_scale),
        alphaPriors=rbind(c(a_alpha,b_alpha)), # if time_specific_alpha == TRUE
        simpleModel = 0,
        theta_tau2 = c(0, 2), # only used if simpleModel=1
		SpatialCohesion=spatial_cohesion, # auxiliary similarity
		# SpatialCohesion=4, # double dipper similarity
		cParms=c(mu0, k0, v0, L0),
		mh=c(sig_mh_sig2,sig_mh_tau2,sig_mh_lambda2,sig_mh_eta1,sig_mh_phi1),
		verbose=TRUE,
		# draws=1000,burn=0,thin=1)
		draws=niter,burn=nburn,thin=nthin)
	cat("\nLPML =",drpm1$lpml, "\nWAIC =",drpm1$waic,"\n")

	tempo_fine <- proc.time()
	elapsed_time <- tempo_fine - tempo_inizio
	# Elapsed time in seconds
	differenza_tempo <- elapsed_time["elapsed"]
	cat(crayon::red(paste0("C case i=",i," j=",j," elapsed: ",differenza_tempo," s\n\n")))
	performance_C[i, j] = min(performance_C[i, j],
							  as.double(differenza_tempo) / niter)
}
}
```


# Analysis
```{r}
# they bring the outs
load("performance_C_target_lim250.Rdata")
load("performance_Julia_target_lim250.Rdata")
# load("performance_C_target_space_lim250.Rdata")
# load("performance_Julia_target_space_lim250.Rdata")
```


```{r}
performance_C
performance_Julia
# save(performance_C,file="performance_C_target_lim250.Rdata")
# save(performance_Julia,file="performance_Julia_target_lim250.Rdata")
```


```{r}
# outC = performance_C[2:5,2:5]
# outJ = performance_Julia[2:5,2:5]
outC = performance_C
outJ = performance_Julia
outC
outJ
speedup_matrix = outC/outJ # time on slow / time on fast
speedup_matrix
```


```{r}
library(shades)
Cplot_mat = function(mat,title,maxk){
ncols_ari <- 1000
cols <- colora(ncols_ari, 35,0)
cols = rev(cols)
ncol_writings = 5
cols_writings <- colora(ncol_writings, 35,0)
cols_writings <- rev(cols_writings)
brks <- seq(0,maxk, length.out = ncols_ari + 1)

# Plotting the matrix
library(fields)
image(mat*1000, axes = FALSE, col = cols, main=title, breaks = brks)
# image.plot(mat*1000, axes = FALSE, col = cols, main=title, breaks = brks)
		  
# Adding text annotations for each cell

xaxis = seq(0,1,length.out = size(mat)[1])
yaxis = seq(0,1,length.out = size(mat)[2])

for (i in 1:size(mat)[1]){
	for (j in 1:size(mat)[2]){
		col_chosen = floor(abs(ncol_writings-mat[i,j]/(maxk/1000)*(ncol_writings-1)))+1
		# cat(col_chosen,"\n")
		
		text(y=yaxis[j],x=xaxis[i],
			 # font=2,
		# labels = sprintf("%.2f\nms/it", mat[i, j]*1000),
		# labels = sprintf("%.2f", mat[i, j]*1000),
		labels = paste0(round(mat[i, j]*1000,digits=2)),
		# cex = 1.0, col = "#aaaaaa")
		cex = 1, col = cols_writings[col_chosen])
		# cex = mat[i, j], col = cols_writings[col_chosen])
		# cex = 1.0, col =complement(cols[col_chosen])[[1]])
		}
}

mtext(text=c(paste0("n=",nunits_tests[1:size(mat)[1]])),
	  side=1, line=0.3,at=seq(0,1,length=size(mat)[1]), las=1, cex=0.8)
mtext(text=c(paste0("T=",timespan_tests[1:size(mat)[1]])),
	  side=2, line=0.3,at=seq(0,1,length=size(mat)[1]), las=1, cex=0.8)

}
#############################################################
Jplot_mat = function(mat,title,maxk){
ncols_ari <- 1000
cols <- colora(ncols_ari, 35,0)
cols = rev(cols)
ncol_writings = 5
cols_writings <- colora(ncol_writings, 35,0)
cols_writings <- rev(cols_writings)
brks <- seq(0,maxk, length.out = ncols_ari + 1)

# Plotting the matrix
library(fields)
# image(mat*1000, axes = FALSE, col = cols, main=title, breaks = brks)
image.plot(mat*1000, axes = FALSE, col = cols, main=title, breaks = brks,legend.width = 1.2)
		  
# Adding text annotations for each cell

xaxis = seq(0,1,length.out = size(mat)[1])
yaxis = seq(0,1,length.out = size(mat)[2])

for (i in 1:size(mat)[1]){
	for (j in 1:size(mat)[2]){
		col_chosen = floor(abs(ncol_writings-mat[i,j]/(maxk/1000)*(ncol_writings-1)))+1
		# cat(col_chosen,"\n")
		
		text(y=yaxis[j],x=xaxis[i],
			 # font=2,
		# labels = sprintf("%.2f\nms/it", mat[i, j]*1000),
		# labels = sprintf("%.2f", mat[i, j]*1000),
		# labels = sprintf("%.2f\n(%.1fx)", mat[i, j]*1000,speedup_matrix[i,j]),
		labels = paste0(round(mat[i, j]*1000,digits=2),
						"\n(",round(speedup_matrix[i,j],digits=2),"x)"),
		# cex = 1.0, col = "#aaaaaa")
		cex = 1, col = cols_writings[col_chosen])
		# cex = mat[i, j], col = cols_writings[col_chosen])
		# cex = 1.0, col =complement(cols[col_chosen])[[1]])
		}
}

mtext(text=c(paste0("n=",nunits_tests[1:size(mat)[1]])),
	  side=1, line=0.3,at=seq(0,1,length=size(mat)[1]), las=1, cex=0.8)
mtext(text=c(paste0("T=",timespan_tests[1:size(mat)[1]])),
	  side=2, line=0.3,at=seq(0,1,length=size(mat)[1]), las=1, cex=0.8)

}
```


```{r}
save_plots = T
if (save_plots==T){
	# pdf(file="target.pdf",width=10,height = 5)
	# pdf(file="target_space.pdf",width=10,height = 5)
}
maxk = max(outC,outJ)*1000
par(mar=c(2.1,2.3,2,1),mfrow=c(1,2),oma=c(0.2,0.2,0.1,1.5))
Cplot_mat(outC,title="fit C - target only",maxk)
Jplot_mat(outJ,title="fit J - target only",maxk)
# Cplot_mat(outC,title="fit C - target + space",maxk)
# Jplot_mat(outJ,title="fit J - target + space",maxk)

# Jplot_mat(outJ,title="fit J | target + space + Xlk + Xcl",maxk)
# mtext("ms/it",side=3,line=-0.8,at=1.235,cex=0.9)
mtext("ms/it",side=3,line=-0.8,at=1.24,cex=0.9)
# mtext("Scaling performance comparison", side = 3, line = 0.1, outer = T)
if (save_plots==T){ dev.off() }
```



```{r}
t(outC)
t(outJ)
t(speedup_matrix)
```


# other plots
```{r}
cols = colora(8,"div",seed_div = "Paired",show=1)

clog = function(x){
	# return(x)
	return(log(x))
}

pchC = 19
pchJ = 15
plot(ylim=extrema(clog(outC),clog(outJ)),lty=2,
      timespan_tests,clog(outC[1,]),type="o",pch=pchC,cex=0.8,col=cols[1])
lines(timespan_tests,clog(outC[2,]),type="o",pch=pchC,cex=0.8,col=cols[3],lty=2)
lines(timespan_tests,clog(outC[3,]),type="o",pch=pchC,cex=0.8,col=cols[5],lty=2)
lines(timespan_tests,clog(outC[4,]),type="o",pch=pchC,cex=0.8,col=cols[7],lty=2)

lines(timespan_tests,clog(outJ[1,]),type="o",pch=pchJ,cex=0.8,col=cols[2])
lines(timespan_tests,clog(outJ[2,]),type="o",pch=pchJ,cex=0.8,col=cols[4])
lines(timespan_tests,clog(outJ[3,]),type="o",pch=pchJ,cex=0.8,col=cols[6])
lines(timespan_tests,clog(outJ[4,]),type="o",pch=pchJ,cex=0.8,col=cols[8])


legend("bottomright",title="C          Julia",
# legend(max(timespan_tests)-110,-6.5,title="C              Julia",
	   title.adj = 0.15,title.font = 3,
	   legend = c("T=10","T=50","T=100","T=250",
	   		   #"T=10","T=50","T=100"),
	   		   "","","",""),
	   pch=c(rep(pchC,4),rep(pchJ,4)),
	   lty = c(rep(2,4),rep(1,4)),
	   col=c(cols[1],cols[3],cols[5],cols[7],
	   	  cols[2],cols[4],cols[6],cols[8]),
	   ncol=2,bty="n")

# legend("bottom", legend = paste("unit", 1:size(yred)[1]), col = cols,
# 	   lty = 1,lwd=2,
# 	   cex=0.8, bty="n",
# 	   ncol=5)
```


# ==========
# WITH COVARIATES
```{r}
load("performance_Julia_target_space_lim250.Rdata")
performance_J_base = performance_Julia # target + space
```

# Fit
```{r}
# timespan_tests = round(seq(10,364,length.out=2))
nunits_tests =   round(seq(10,105,length.out=4))
timespan_tests = round(seq(10,729,length.out=8))

nruns_tests    = rep(4,5)
#### target & space
# nunits_tests   = c(5,10,50,100,250)
# timespan_tests = c(5,10,50,100,250)

#### target 
nunits_tests   = c(10,50,100,250)
timespan_tests = c(10,50,100,250)
p = 5

niter_tests = matrix(0,nrow=length(nunits_tests),ncol=lenght(timespan_tests))
for (i in 1:length(nunits_tests)) {
	for (j in 1:length(timespan_tests)) {
		niter_tests[i,j] = 10000/(nunits_tests[i]*timespan_tests[j])*50
		# niter_tests[i,j] = 10000/(min(nunits_tests[i],timespan_tests[j]))*100
	}
}
nruns_tests
niter_tests
timespan_tests
nunits_tests

cat("size =",length(timespan_tests)*length(nunits_tests),"\n")

performance_J_Xcl <- matrix(1e5, nrow = length(nunits_tests), ncol = length(timespan_tests))
performance_J_Xcl_Xlk <- matrix(1e5, nrow = length(nunits_tests), ncol = length(timespan_tests))
colnames(performance_J_Xcl) = c(paste0("T_",timespan_tests))
rownames(performance_J_Xcl) = c(paste0("n_",nunits_tests))
colnames(performance_J_Xcl_Xlk) = c(paste0("T_",timespan_tests))
rownames(performance_J_Xcl_Xlk) = c(paste0("n_",nunits_tests))

performance_J_Xcl
performance_J_Xcl_Xlk
```


```{r}
library(lubridate)
module_JDRPM <- juliaImport(juliaCall("include", module))

seed = 2.0
set.seed(2.0)

for (i in 1:length(nunits_tests)) {
  for (j in 1:length(timespan_tests)) {
  	
  	##### set data accordingly
	# reduce data set
	# nsubjects = 1:nunits_tests[i] # up to 105
	# time_span = 1:timespan_tests[j] # up to 365
	# y = yfull_2years[nsubjects,1+time_span]
	# ym = as.matrix(y)
	# sites = std_sites[nsubjects,]
	# sitesm = as.matrix(sites)
	
	out = create_data(nunits_tests[i],timespan_tests[j],p_cl = p, p_lk = p)
	y = out[[1]]
	sites = out[[2]]
	X_cl = out[[3]]
	X_lk = out[[4]]

	niter = niter_tests[i,j]
	nruns = nruns_tests[i]
	
	cat(crayon::green("##########",niter,"iterations\n"))
	nburn = niter-1
	nthin = 1
  	##### fit models
		
	##### J Xcl
	for (run in 1:nruns){
		tempo_inizio <- proc.time()
		out = module_JDRPM$MCMC_fit(
			Y=y,
			sp_coords = sites,
			M_dp = 1,
			initial_partition = NA,
			starting_alpha = 0.5,
			unit_specific_alpha = FALSE,
			time_specific_alpha = TRUE,
			update_alpha = TRUE,
			include_eta1 = TRUE,
			include_phi1 = TRUE,
			update_eta1 = TRUE,
			update_phi1 = TRUE,
			sig2h_priors = c(a_sigma,b_sigma),
			eta1_priors = c(eta1_scale,sig_mh_eta1),
			# beta_priors = c(rep(1,p),2),
			beta_priors = NA,
			tau2_priors = c(a_tau,b_tau),
			phi0_priors = c(m0_phi0,s20_phi0),
			phi1_priors = sig_mh_phi1,
			lambda2_priors = c(a_lambda,b_lambda),
			alpha_priors = c(a_alpha,b_alpha),

			####### space
			spatial_cohesion_idx = spatial_cohesion,
			sp_params = list(c(mu0,mu0),k0,v0,matrix(c(L0,0.0,0.0,L0),nrow=2)),
			######## likelihood covariates
			# Xlk_covariates = X_lk, beta_priors = c(rep(0,p),1),
			Xlk_covariates = NA, beta_priors = NA,
			######## clustering covariates
			covariate_similarity_idx = 4,
			cv_params = list(0,1,2,2),
			Xcl_covariates = X_cl,

			draws = niter,burnin = nburn, thin = nthin,
			logging = FALSE,
			seed = seed,
			simple_return = TRUE
		)
		tempo_fine <- proc.time()
		elapsed_time <- tempo_fine - tempo_inizio
		# Elapsed time in seconds
		differenza_tempo <- elapsed_time["elapsed"]
		cat(crayon::red(paste0("J Xcl case i=",i," j=",j," elapsed: ",differenza_tempo," s\n\n")))
		performance_J_Xcl[i, j] = min(performance_J_Xcl[i, j],
									  as.double(differenza_tempo) / niter)
	# }
	
	##### J Xall
	# for (run in 1:nruns){
#   	tempo_inizio <- proc.time()
# 		out = module_JDRPM$MCMC_fit(
# 			Y=y,              
# 			sp_coords = sites,
# 			M_dp = 1,                     
# 			initial_partition = NA,
# 			starting_alpha = 0.5,         
# 			unit_specific_alpha = FALSE,       
# 			time_specific_alpha = TRUE,       
# 			update_alpha = TRUE,
# 			include_eta1 = TRUE,                    
# 			include_phi1 = TRUE,
# 			update_eta1 = TRUE,                    
# 			update_phi1 = TRUE,
# 			sig2h_priors = c(a_sigma,b_sigma),
# 			eta1_priors = c(eta1_scale,sig_mh_eta1),
# 			# beta_priors = c(rep(1,p),2),
# 			beta_priors = NA,
# 			tau2_priors = c(a_tau,b_tau),
# 			phi0_priors = c(m0_phi0,s20_phi0),
# 			phi1_priors = sig_mh_phi1,
# 			lambda2_priors = c(a_lambda,b_lambda),
# 			alpha_priors = c(a_alpha,b_alpha),
# 			
# 			####### space
# 			spatial_cohesion_idx = spatial_cohesion,
# 			sp_params = list(c(mu0,mu0),k0,v0,matrix(c(L0,0.0,0.0,L0),nrow=2)),
# 			######## likelihood covariates
# 			Xlk_covariates = X_lk, beta_priors = c(rep(0,p),1),
# 			# Xlk_covariates = NA, beta_priors = NA,
# 			######## clustering covariates
# 			covariate_similarity_idx = 4,
# 			cv_params = list(0,1,2,2),
# 			Xcl_covariates = X_cl,
# 			
# 			draws = niter,burnin = nburn, thin = nthin,
# 			logging = FALSE,
# 			seed = seed,
# 			simple_return = TRUE
# 		)
# 
# 		tempo_fine <- proc.time()
# 		elapsed_time <- tempo_fine - tempo_inizio
# 		# Elapsed time in seconds
# 		differenza_tempo <- elapsed_time["elapsed"]
# 		cat(crayon::red(paste0("J Xall case i=",i," j=",j," elapsed: ",differenza_tempo," s\n\n")))
# 		performance_J_Xcl_Xlk[i, j] = min(performance_J_Xcl_Xlk[i, j],
# 								  as.double(differenza_tempo) / niter)
	}
  }
}
```

# refine cases
```{r}
i = 4
j = 3
nruns = 2
# niter = niter_tests[i,j]
niter = 10

out = create_data(nunits_tests[i],timespan_tests[j],p_cl = p, p_lk = p)
y = out[[1]]
sites = out[[2]]
X_cl = out[[3]]
X_lk = out[[4]]

nburn = niter-1
nthin = 1

fit_Xcl = TRUE
fit_Xall = FALSE

##### J Xcl
for (run in 1:nruns){
	if (fit_Xcl==T){
	tempo_inizio <- proc.time()
	out = module_JDRPM$MCMC_fit(
		Y=y,              
		sp_coords = sites,
		M_dp = 1,                     
		initial_partition = NA,
		starting_alpha = 0.5,         
		unit_specific_alpha = FALSE,       
		time_specific_alpha = TRUE,       
		update_alpha = TRUE,
		include_eta1 = TRUE,                    
		include_phi1 = TRUE,
		update_eta1 = TRUE,                    
		update_phi1 = TRUE,
		sig2h_priors = c(a_sigma,b_sigma),
		eta1_priors = c(eta1_scale,sig_mh_eta1),
		# beta_priors = c(rep(1,p),2),
		beta_priors = NA,
		tau2_priors = c(a_tau,b_tau),
		phi0_priors = c(m0_phi0,s20_phi0),
		phi1_priors = sig_mh_phi1,
		lambda2_priors = c(a_lambda,b_lambda),
		alpha_priors = c(a_alpha,b_alpha),
		
		####### space
		spatial_cohesion_idx = spatial_cohesion,
		sp_params = list(c(mu0,mu0),k0,v0,matrix(c(L0,0.0,0.0,L0),nrow=2)),
		######## likelihood covariates
		# Xlk_covariates = X_lk, beta_priors = c(rep(0,p),1),
		Xlk_covariates = NA, beta_priors = NA,
		######## clustering covariates
		covariate_similarity_idx = 4,
		cv_params = list(0,1,2,2),
		Xcl_covariates = X_cl,
		
		draws = niter,burnin = nburn, thin = nthin,
		logging = FALSE,
		seed = seed,
		simple_return = TRUE
	)
	tempo_fine <- proc.time()
	elapsed_time <- tempo_fine - tempo_inizio
	# Elapsed time in seconds
	differenza_tempo <- elapsed_time["elapsed"]
	cat(crayon::red(paste0("J Xcl case i=",i," j=",j," elapsed: ",differenza_tempo," s\n\n")))
	performance_J_Xcl[i, j] = min(performance_J_Xcl[i, j],
								  as.double(differenza_tempo) / niter)
	}

##### J Xall
	if (fit_Xall == T){
  tempo_inizio <- proc.time()
	out = module_JDRPM$MCMC_fit(
		Y=y,              
		sp_coords = sites,
		M_dp = 1,                     
		initial_partition = NA,
		starting_alpha = 0.5,         
		unit_specific_alpha = FALSE,       
		time_specific_alpha = TRUE,       
		update_alpha = TRUE,
		include_eta1 = TRUE,                    
		include_phi1 = TRUE,
		update_eta1 = TRUE,                    
		update_phi1 = TRUE,
		sig2h_priors = c(a_sigma,b_sigma),
		eta1_priors = c(eta1_scale,sig_mh_eta1),
		# beta_priors = c(rep(1,p),2),
		beta_priors = NA,
		tau2_priors = c(a_tau,b_tau),
		phi0_priors = c(m0_phi0,s20_phi0),
		phi1_priors = sig_mh_phi1,
		lambda2_priors = c(a_lambda,b_lambda),
		alpha_priors = c(a_alpha,b_alpha),
		
		####### space
		spatial_cohesion_idx = spatial_cohesion,
		sp_params = list(c(mu0,mu0),k0,v0,matrix(c(L0,0.0,0.0,L0),nrow=2)),
		######## likelihood covariates
		Xlk_covariates = X_lk, beta_priors = c(rep(0,p),1),
		# Xlk_covariates = NA, beta_priors = NA,
		######## clustering covariates
		covariate_similarity_idx = 4,
		cv_params = list(0,1,2,2),
		Xcl_covariates = X_cl,
		
		draws = niter,burnin = nburn, thin = nthin,
		logging = FALSE,
		seed = seed,
		simple_return = TRUE
	)

	tempo_fine <- proc.time()
	elapsed_time <- tempo_fine - tempo_inizio
	# Elapsed time in seconds
	differenza_tempo <- elapsed_time["elapsed"]
	cat(crayon::red(paste0("J Xall case i=",i," j=",j," elapsed: ",differenza_tempo," s\n\n")))
	performance_J_Xcl_Xlk[i, j] = min(performance_J_Xcl_Xlk[i, j],
							  as.double(differenza_tempo) / niter)
	}
}
```


# Analysis
```{r}
# save(performance_J_Xcl,file="performance_J_Xcl.Rdata")
# save(performance_J_Xcl_Xlk,file="performance_J_Xcl_Xlk.Rdata")
# load(file="performance_J_Xcl.Rdata")
# load(file="performance_J_Xcl_Xlk.Rdata")
```


```{r}
outJ_base = performance_J_base[2:5,2:5]
t(outJ_base)
t(performance_J_Xcl)
t(performance_J_Xcl_Xlk)
performance_J_Xcl > outJ_base
performance_J_Xcl_Xlk > outJ_base
performance_J_Xcl < performance_J_Xcl_Xlk
```


```{r}
# time on slow / time on fast
# OR
# time old / time new
# time base model / time upgraded model
speedup_cl = outJ_base / performance_J_Xcl
speedup_cllk = outJ_base / performance_J_Xcl_Xlk
t(speedup_cl)
t(speedup_cllk)
speedup_cllk < speedup_cl
```


# plots
```{r}
library(shades)
JXcl_plot_mat = function(mat,title,maxk){
ncols_ari <- 1000
cols <- colora(ncols_ari, 35,0)
cols = rev(cols)
ncol_writings = 5
cols_writings <- colora(ncol_writings, 35,0)
cols_writings <- rev(cols_writings)
brks <- seq(0,maxk, length.out = ncols_ari + 1)

# Plotting the matrix
library(fields)
image(mat*1000, axes = FALSE, col = cols, main=title, breaks = brks)
# image.plot(mat*1000, axes = FALSE, col = cols, main=title, breaks = brks)
		  
# Adding text annotations for each cell

xaxis = seq(0,1,length.out = size(mat)[1])
yaxis = seq(0,1,length.out = size(mat)[2])

for (i in 1:size(mat)[1]){
	for (j in 1:size(mat)[2]){
		col_chosen = floor(abs(ncol_writings-mat[i,j]/(maxk/1000)*(ncol_writings-1)))+1
		# cat(col_chosen,"\n")
		
		text(y=yaxis[j],x=xaxis[i],
			 # font=2,
		# labels = sprintf("%.2f\nms/it", mat[i, j]*1000),
		# labels = sprintf("%.2f", mat[i, j]*1000),
		labels = paste0(round(mat[i, j]*1000,digits=2),
						"\n(",round(speedup_cl[i,j],digits=2),"x)"),
		# cex = 1.0, col = "#aaaaaa")
		cex = 1, col = cols_writings[col_chosen])
		# cex = mat[i, j], col = cols_writings[col_chosen])
		# cex = 1.0, col =complement(cols[col_chosen])[[1]])
		}
}

mtext(text=c(paste0("n=",nunits_tests[1:size(mat)[1]])),
	  side=1, line=0.3,at=seq(0,1,length=size(mat)[1]), las=1, cex=0.8)
mtext(text=c(paste0("T=",timespan_tests[1:size(mat)[1]])),
	  side=2, line=0.3,at=seq(0,1,length=size(mat)[1]), las=1, cex=0.8)

}
#############################################################
Jall_plot_mat = function(mat,title,maxk){
ncols_ari <- 1000
cols <- colora(ncols_ari, 35,0)
cols = rev(cols)
ncol_writings = 5
cols_writings <- colora(ncol_writings, 35,0)
cols_writings <- rev(cols_writings)
brks <- seq(0,maxk, length.out = ncols_ari + 1)

# Plotting the matrix
library(fields)
# image(mat*1000, axes = FALSE, col = cols, main=title, breaks = brks)
image.plot(mat*1000, axes = FALSE, col = cols, main=title, breaks = brks,legend.width = 1.2)
		  
# Adding text annotations for each cell

xaxis = seq(0,1,length.out = size(mat)[1])
yaxis = seq(0,1,length.out = size(mat)[2])

for (i in 1:size(mat)[1]){
	for (j in 1:size(mat)[2]){
		col_chosen = floor(abs(ncol_writings-mat[i,j]/(maxk/1000)*(ncol_writings-1)))+1
		# cat(col_chosen,"\n")
		
		text(y=yaxis[j],x=xaxis[i],
			 # font=2,
		# labels = sprintf("%.2f\nms/it", mat[i, j]*1000),
		# labels = sprintf("%.2f", mat[i, j]*1000),
		# labels = sprintf("%.2f\n(%.1fx)", mat[i, j]*1000,speedup_matrix[i,j]),
		labels = paste0(round(mat[i, j]*1000,digits=2),
						"\n(",round(speedup_cllk[i,j],digits=2),"x)"),
		# cex = 1.0, col = "#aaaaaa")
		cex = 1, col = cols_writings[col_chosen])
		# cex = mat[i, j], col = cols_writings[col_chosen])
		# cex = 1.0, col =complement(cols[col_chosen])[[1]])
		}
}

mtext(text=c(paste0("n=",nunits_tests[1:size(mat)[1]])),
	  side=1, line=0.3,at=seq(0,1,length=size(mat)[1]), las=1, cex=0.8)
mtext(text=c(paste0("T=",timespan_tests[1:size(mat)[1]])),
	  side=2, line=0.3,at=seq(0,1,length=size(mat)[1]), las=1, cex=0.8)

}
```


```{r}
save_plots = T
if (save_plots==T){
	pdf(file="target_space_covariates.pdf",width=10,height = 5)
	# pdf(file="target_space.pdf",width=10,height = 5)
}
maxk = max(performance_J_Xcl,performance_J_Xcl_Xlk)*1000
par(mar=c(2.1,2.3,2,1),mfrow=c(1,2),oma=c(0.2,0.2,0.1,1.5))
JXcl_plot_mat(performance_J_Xcl,title="fit J - target + space + Xcl (p=5)",maxk)
Jall_plot_mat(performance_J_Xcl_Xlk,title="fit J - target + space + Xcl + Xlk (p=5)",maxk)
# Cplot_mat(outC,title="fit C - target + space",maxk)
# Jplot_mat(outJ,title="fit J - target + space",maxk)

# Jplot_mat(outJ,title="fit J | target + space + Xlk + Xcl",maxk)
# mtext("(p=5)",side=3,line=-21,at=1.24,cex=0.9)
# mtext("(p=5)",side=3,line=-0.1,at=1.24,cex=0.9)
mtext("ms/it",side=3,line=-0.8,at=1.24,cex=0.9)
# mtext("Scaling performance comparison", side = 3, line = 0.1, outer = T)
if (save_plots==T){ dev.off() }
```
	


# ==========
# SUMMARY COMPARISON



```{r}
load("performance_C_target_lim250.Rdata")
Ct = performance_C
load("performance_C_target_space_lim250.Rdata")
Cts = performance_C[2:5,2:5]

load("performance_Julia_target_lim250.Rdata")
Jt = performance_Julia
load("performance_Julia_target_space_lim250.Rdata")
Jts = performance_Julia[2:5,2:5]
load("performance_J_Xcl.Rdata")
Jtsc = performance_J_Xcl
load("performance_J_Xcl_Xlk.Rdata")
Jtscl = performance_J_Xcl_Xlk

nunits_tests   = c(10,50,100,250)
timespan_tests = c(10,50,100,250)
p = 5
```


```{r}
cat(crayon::red("Ct\n"))
Ct
cat(crayon::red("Cts\n"))
Cts
cat(crayon::red("Jt\n"))
Jt
cat(crayon::red("Jts\n"))
Jts
cat(crayon::red("Jtsc\n"))
Jtsc
cat(crayon::red("Jtscl\n"))
Jtscl
```


# speedups
```{r}
# time on slow / time on fast
# OR
# time old / time new
# time base model / time upgraded model
scaling_perf = Jts
spCt = Ct / scaling_perf
spCts = Cts / scaling_perf
spJt = Jt / scaling_perf
spJts = Jts / scaling_perf
spJtsc = Jtsc / scaling_perf
spJtscl = Jtscl / scaling_perf

spCt
spCts
spJt
spJts
spJtsc
spJtscl
```

# plots
```{r}
save_plot = F
if (save_plot) {
	# pdf(file="summary_performance.pdf",width = 8,height = 7)
	# pdf(file="summary_performance.pdf",width = 7,height = 6)
	pdf(file="summary_performance_higher.pdf",width = 7,height = 7)
}

timespan_plots = c(1,2,3,4)
nunits_plots = c(1,2,3,4)
dxJ = 0
dxC = 0.2
dx = max(dxJ, dxC)

# par(mfrow=c(2,2),mar=c(3,2,2,2),mai=c(.2,.5,.5,.5),oma=c(1,0.1,0.1,0.1))
scala = 5.8
layout(matrix(c(1,2,3,4,5,5), ncol=2, byrow=TRUE),heights=c(scala,scala,1))
par(mar=c(0.1,2,1,2),mai=c(.4,.2,.1,.2),oma=c(0.1,0.7,0.1,0.1))

for (i in 1:4){
plot(1, type = "n", xlab = "", ylab = "",
	 xlim = c(1-dx,4+dx), axes=F,
     ylim = c(0, 2.5), xaxt="n")

# Changing x axis
xtick<-paste0("T=",as.character(timespan_tests))
axis(side=1, at=timespan_plots, labels = xtick)
axis(2)

abline(h=1,col="#cccccc",lty=1)
abline(h=0.5,col="#dddddd",lty=2)
abline(h=1.5,col="#dddddd",lty=2)
abline(h=2,col="#eeeeee",lty=4)

# lines(x=c(1,4),y=c(1,1),col="#cccccc",lty=1)
# lines(x=c(1,4),y=c(0.5,0.5),col="#dddddd",lty=2)
# lines(x=c(1,4),y=c(1.75,1.75),col="#dddddd",lty=2)

title(main=paste0("n=",nunits_tests[i]),line=-0.4)
cols = colora(8,"div",seed_div = "Paired",show = 0)
cexs = 2.4
lwds = 1.5
points(x=timespan_plots + dxC,y = spCt[i,],   pch=15, cex=cexs, col=cols[1], lwd=2)
points(x=timespan_plots + dxC,y = spCts[i,],  pch=16, cex=cexs, col=cols[3], lwd=2)
points(x=timespan_plots + dxJ,y = spJt[i,],   pch=0, cex=cexs, col=cols[2], lwd=lwds)
points(x=timespan_plots + dxJ,y = spJts[i,],  pch=1, cex=cexs, col=cols[4], lwd=lwds)
points(x=timespan_plots + dxJ,y = spJtsc[i,] ,pch=2, cex=cexs, col=cols[5], lwd=lwds)
points(x=timespan_plots + dxJ,y = spJtscl[i,],pch=5, cex=cexs, col=cols[7], lwd=lwds)
}
# legend("bottom",
par(mai=c(0,0,0,0))
plot.new()
legend("center",
	   bty="n",cex=1.4,
       # legend = c("Ct","Cts","Jt","Jts","Jtsc","Jtscl"),
       legend = c("C target","C target+space","J target",
	   "J target+space","J target+space+Xcl","J target+space+Xcl+Xlk"),
	   pch=c(15,16,0,1,2,5),ncol=3,pt.cex = 2.1,
	   pt.lwd = c(1,1,rep(lwds,4)),
	   col=cols[c(1,3,2,4,5,7)])

if (save_plot) { dev.off() }

```


# individuals
```{r}
save_plot = T

timespan_plots = c(1,2,3,4)
nunits_plots = c(1,2,3,4)
dxJ = 0
dxC = 0.2
dx = max(dxJ, dxC)

for (i in 2:3){
# for (i in 2:2){
	if (save_plot) {
	# pdf(file="summary_performance.pdf",width = 8,height = 7)
	# pdf(file=paste0("summary_performance_n",nunits_tests[i],"_legended_bottom.pdf"),
	pdf(file=paste0("summary_performance_n",nunits_tests[i],"_legended_bigger.pdf"),
		# width = 6,height = 4)
		width = 6,height = 4)
}

# layout(matrix(data=c(1,1,2,2),nrow=2,byrow=T),heights=c(4,1))
par(mar=c(0.1,2,1,2),mai=c(.4,.3,.1,.2),oma=c(0.1,1,0.1,0.1))
plot(1, type = "n", xlab = "", ylab = "",
	 xlim = c(1-dx,4+dx), axes=F,
     ylim = c(0.1, 2.4), xaxt="n")

# Changing x axis
xtick<-paste0("T=",as.character(timespan_tests))
axis(side=1, at=timespan_plots, labels = xtick)
axis(2)

abline(h=1,col="#cccccc",lty=1)
abline(h=0.5,col="#dddddd",lty=2)
abline(h=1.5,col="#dddddd",lty=2)
abline(h=2,col="#eeeeee",lty=4)

# lines(x=c(1,4),y=c(1,1),col="#cccccc",lty=1)
# lines(x=c(1,4),y=c(0.5,0.5),col="#dddddd",lty=2)
# lines(x=c(1,4),y=c(1.75,1.75),col="#dddddd",lty=2)

title(main=paste0("n=",nunits_tests[i]),line=-2)
cols = colora(8,"div",seed_div = "Paired",show = 0)
cexs = 2.4
points(x=timespan_plots + dxC,y = spCt[i,],   pch=15, cex=cexs, col=cols[1])
points(x=timespan_plots + dxC,y = spCts[i,],  pch=16, cex=cexs, col=cols[3])
points(x=timespan_plots + dxJ,y = spJt[i,],   pch=0, cex=cexs, col=cols[2], lwd=1.7)
points(x=timespan_plots + dxJ,y = spJts[i,],  pch=1, cex=cexs, col=cols[4], lwd=1.7)
points(x=timespan_plots + dxJ,y = spJtsc[i,] ,pch=2, cex=cexs, col=cols[5], lwd=1.7)
points(x=timespan_plots + dxJ,y = spJtscl[i,],pch=5, cex=cexs, col=cols[7], lwd=1.7)

# plot.new()
# par(mar=c(0,0,0,0),mai=c(0,0,0,0),oma=c(0,0,0,0))
legend("bottom",
	   bty="n",cex=0.8,
       # legend = c("Ct","Cts","Jt","Jts","Jtsc","Jtscl"),
	   # pch=c(15,16,0,1,2,5),ncol=6,pt.cex = 1.6,
       legend = c("C target","C target+space","J target","J target+space","J target+space+Xcl","J target+space+Xcl+Xlk"),
	   pch=c(15,16,0,1,2,5),ncol=3,pt.cex = 1.6,
	   pt.lwd = c(1,1,rep(lwds,4)),
	   # pch=c(15,16,0,1,2,5),ncol=3,pt.cex = 1.6,
	   col=cols[c(1,3,2,4,5,7)])
if (save_plot) { dev.off() }
}
```


# ==========
# Scaling wrt P


# idea 1
```{r}
nruns_tests = 1

#### target 
plk_test = c(0,1,3,5,7)
pcl_test = c(0,1,3,5,7)

niter_tests = matrix(0,nrow=length(plk_test),ncol=lenght(plk_test))
for (i in 1:length(plk_test)) {
	for (j in 1:length(plk_test)) {
		# niter_tests[i,j] = 1600/(plk_test[i]*plk_test[j]+1)*100
		niter_tests[i,j] = 80
	}
}
nruns_tests
niter_tests
```


```{r}
n = 50
Tm = 50

performance_Julia <- matrix(1e5, nrow = length(plk_test), ncol = length(plk_test))
colnames(performance_Julia) = c(paste0("plk_",plk_test))
rownames(performance_Julia) = c(paste0("pcl_",pcl_test))

performance_Julia
```

```{r}
load(file="test_varying_p.Rdata")
```


# fit
```{r}
library(lubridate)
# module_JDRPM <- juliaImport(juliaCall("include", module))

seed = 2.0

# for (cl in 4:length(pcl_test)) {
for (cl in 5:5) {
for (lk in 1:length(plk_test)) {
	
	out = create_data(n,Tm,p_cl = pcl_test[cl], p_lk = plk_test[lk])
	y = out[[1]]
	sites = out[[2]]
	X_cl = out[[3]]
	X_lk = out[[4]]

	niter = niter_tests[cl,lk]
	nruns = nruns_tests
	
	cat(crayon::green("########## lk",plk_test[lk]," cl",pcl_test[cl],"\n"))
	nburn = niter-1
	nthin = 1
  	##### fit models
		
	##### J Xcl
	for (run in 1:nruns){
		tempo_inizio <- proc.time()
		out = module_JDRPM$MCMC_fit(
			Y=y,
			sp_coords = sites,
			M_dp = 1,
			initial_partition = NA,
			starting_alpha = 0.5,
			unit_specific_alpha = FALSE,
			time_specific_alpha = TRUE,
			update_alpha = TRUE,
			include_eta1 = TRUE,
			include_phi1 = TRUE,
			update_eta1 = TRUE,
			update_phi1 = TRUE,
			sig2h_priors = c(a_sigma,b_sigma),
			eta1_priors = c(eta1_scale,sig_mh_eta1),
			# beta_priors = c(rep(1,p),2),
			beta_priors = NA,
			tau2_priors = c(a_tau,b_tau),
			phi0_priors = c(m0_phi0,s20_phi0),
			phi1_priors = sig_mh_phi1,
			lambda2_priors = c(a_lambda,b_lambda),
			alpha_priors = c(a_alpha,b_alpha),

			####### space
			spatial_cohesion_idx = spatial_cohesion,
			sp_params = list(c(mu0,mu0),k0,v0,matrix(c(L0,0.0,0.0,L0),nrow=2)),
			######## likelihood covariates
			Xlk_covariates = if (lk>1) X_lk else NA, beta_priors = c(rep(0,plk_test[lk]),1),
			# Xlk_covariates = NA, beta_priors = NA,
			######## clustering covariates
			covariate_similarity_idx = 4,
			cv_params = as.list(c(0,1,rep(c(7.5,2),pcl_test[cl]))),
			Xcl_covariates = if (cl>1) X_cl else NA,

			draws = niter,burnin = nburn, thin = nthin,
			logging = FALSE,
			seed = seed,
			skip_checks = T,
			simple_return = TRUE
		)
		tempo_fine <- proc.time()
		elapsed_time <- tempo_fine - tempo_inizio
		# Elapsed time in seconds
		differenza_tempo <- elapsed_time["elapsed"]
		cat(crayon::red(paste0("J Xcl case lk=",plk_test[lk]," cl=",pcl_test[cl],
							   " elapsed: ",differenza_tempo,"s i.e.\n",
							   differenza_tempo/niter," s/it \n\n")))
		cat(crayon::magenta("current value",performance_Julia[cl, lk],
				   "\nnew candidate",as.double(differenza_tempo) / niter,"\n"))
		if (as.double(differenza_tempo) / niter < performance_Julia[cl, lk]){
			cat(crayon::magenta("UPDATE\n"))
		}
		performance_Julia[cl, lk] = min(performance_Julia[cl, lk],
									  as.double(differenza_tempo) / niter)
	# }
	
	}
  }
}
```
# refine
```{r}
cl = 3
lk = 2
nruns = 1

out = create_data(n,Tm,p_cl = pcl_test[cl], p_lk = plk_test[lk])
y = out[[1]]
sites = out[[2]]
X_cl = out[[3]]
X_lk = out[[4]]

niter = niter_tests[cl,lk]
nruns = nruns_tests

cat(crayon::green("########## lk",plk_test[lk]," cl",pcl_test[cl],"\n"))
nburn = niter-1
nthin = 1

##### J Xcl
for (run in 1:nruns){
	tempo_inizio <- proc.time()
	out = module_JDRPM$MCMC_fit(
		Y=y,
		sp_coords = sites,
		M_dp = 1,
		initial_partition = NA,
		starting_alpha = 0.5,
		unit_specific_alpha = FALSE,
		time_specific_alpha = TRUE,
		update_alpha = TRUE,
		include_eta1 = TRUE,
		include_phi1 = TRUE,
		update_eta1 = TRUE,
		update_phi1 = TRUE,
		sig2h_priors = c(a_sigma,b_sigma),
		eta1_priors = c(eta1_scale,sig_mh_eta1),
		# beta_priors = c(rep(1,p),2),
		beta_priors = NA,
		tau2_priors = c(a_tau,b_tau),
		phi0_priors = c(m0_phi0,s20_phi0),
		phi1_priors = sig_mh_phi1,
		lambda2_priors = c(a_lambda,b_lambda),
		alpha_priors = c(a_alpha,b_alpha),

		####### space
		spatial_cohesion_idx = spatial_cohesion,
		sp_params = list(c(mu0,mu0),k0,v0,matrix(c(L0,0.0,0.0,L0),nrow=2)),
		######## likelihood covariates
		Xlk_covariates = if (lk>1) X_lk else NA, beta_priors = c(rep(0,plk_test[lk]),1),
		# Xlk_covariates = NA, beta_priors = NA,
		######## clustering covariates
		covariate_similarity_idx = 4,
		cv_params = as.list(c(0,1,rep(c(4,2),pcl_test[cl]))),
		Xcl_covariates = if (cl>1) X_cl else NA,

		draws = niter,burnin = nburn, thin = nthin,
		logging = FALSE,
		seed = seed,
		skip_checks = T,
		simple_return = TRUE
	)
	tempo_fine <- proc.time()
	elapsed_time <- tempo_fine - tempo_inizio
	# Elapsed time in seconds
	differenza_tempo <- elapsed_time["elapsed"]
	cat(crayon::red(paste0("J Xcl case lk=",plk_test[lk]," cl=",pcl_test[cl],
						   " elapsed: ",differenza_tempo,"s i.e.\n",
						   differenza_tempo/niter," s/it \n\n")))
	cat(crayon::magenta("current value",performance_Julia[cl, lk],
					   "\nnew candidate",as.double(differenza_tempo) / niter,"\n"))
	performance_Julia[cl, lk] = min(performance_Julia[cl, lk],
								  as.double(differenza_tempo) / niter)
# }
}
```


```{r}
save(performance_Julia,file="test_varying_p.Rdata")
```


# plot
```{r}
performance_Julia
# 0.024 è il tempo di C con target + space per questi n e T
speedup_matrix = 0.024/performance_Julia # time on slow / time on fast
speedup_matrix
```


```{r}
Jplot_mat = function(mat,title,maxk){
ncols_ari <- 1000
cols <- colora(ncols_ari, 35,0)
cols = rev(cols)
ncol_writings = 3
cols_writings <- colora(ncol_writings, 35,0)
# cols_writings <- colora(ncol_writings, "rand",1)
cols_writings <- rev(cols_writings)
brks <- seq(0,maxk, length.out = ncols_ari + 1)

# Plotting the matrix
library(fields)
# image(mat*1000, axes = FALSE, col = cols, main=title, breaks = brks)
image.plot(mat*1000, axes = FALSE, col = cols, main=title, breaks = brks,legend.width = 1.2)
		  
# Adding text annotations for each cell

xaxis = seq(0,1,length.out = size(mat)[1])
yaxis = seq(0,1,length.out = size(mat)[2])

for (i in 1:size(mat)[1]){
	for (j in 1:size(mat)[2]){
		col_chosen = floor(abs(ncol_writings-mat[i,j]/(maxk/1000)*(ncol_writings-1)))+1
		# cat(col_chosen,"\n")
		
		col1 = "#ffffff" #"#CC78AF" "#F8DCD9"
		col2 = "#aaaaaa"
		col3 = "#d8DCD9"
		
		text(y=yaxis[j],x=xaxis[i],
			 # font=2,
		# labels = sprintf("%.2f\nms/it", mat[i, j]*1000),
		# labels = sprintf("%.2f", mat[i, j]*1000),
		# labels = sprintf("%.2f\n(%.1fx)", mat[i, j]*1000,speedup_matrix[i,j]),
		labels = paste0(round(mat[i, j]*1000,digits=2),
						"\n(",round(speedup_matrix[i,j],digits=2),"x)"),
		# cex = 1.0, col = "#aaaaaa")
		# cex = 1, col = cols_writings[col_chosen])
		# cex = 1, col = if (speedup_matrix[i,j]>1) col1 else col2)
		cex = 1, col = col3)
		# cex = mat[i, j], col = cols_writings[col_chosen])
		# cex = 1.0, col =complement(cols[col_chosen])[[1]])
		}
}
# colora(3,"rand")

mtext(text=c(paste0("cl=",pcl_test[1:size(mat)[1]])),
	  side=1, line=0.3,at=seq(0,1,length=size(mat)[1]), las=1, cex=0.8)
mtext(text=c(paste0("lk=",plk_test[1:size(mat)[1]])),
	  side=2, line=0.3,at=seq(0,1,length=size(mat)[1]), las=1, cex=0.8)
}
```


```{r}
save_plots = F
if (save_plots==T){
	pdf(file="test_varying_p.pdf",width=7,height = 5)
}
maxk = max(performance_Julia)*1000
par(mar=c(2.1,2.3,2,1),oma=c(0.2,0.2,0.1,1.5))
Jplot_mat(performance_Julia,title="fit J - space + Xlk + Xcl for varying p",maxk)

# mtext("ms/it",side=3,line=-0.8,at=1.235,cex=0.9)
mtext("ms/it",side=3,line=-0.8,at=1.24,cex=0.9)
# mtext("Scaling performance comparison", side = 3, line = 0.1, outer = T)
if (save_plots==T){ dev.off() }
```

# FINAL PLOT
```{r}
load("performance_C_target_lim250.Rdata")
performance_C
load("performance_C_target_space_lim250.Rdata")
performance_C

load("performance_Julia_target_lim250.Rdata")
J_no_space = performance_Julia
load("performance_Julia_target_space_lim250.Rdata")
J_space = performance_Julia

load("test_varying_p.Rdata")
J_varying_p = performance_Julia
```

```{r}
# case T=50, N=50

cls = c(0,1,3,5,7)
C_no_space = 0.014075
C_space = 0.02400
```

```{r}
# cols = colora(4,"rand")
# 112, 55
cols = colora(4,55,0)
cols_C = colora(4,"rand",0)

plot( cls,as.numeric(J_varying_p[,1]),type="o",pch=19,col=cols[1],ylim=extrema(J_varying_p))
abline(h=C_no_space,col="gray70")
abline(h=C_space,   col="gray70")
lines(cls,as.numeric(J_varying_p[,1]),type="o",pch=19,col=cols[1])
lines(cls,as.numeric(J_varying_p[,2]),type="o",pch=19,col=cols[2])
lines(cls,as.numeric(J_varying_p[,3]),type="o",pch=19,col=cols[3])
lines(cls,as.numeric(J_varying_p[,4]),type="o",pch=19,col=cols[4])

```



