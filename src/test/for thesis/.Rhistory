# 						# main=bquote(alpha==.(amn[jj]) ~~ Time ~ .(jj)),
# 						main=bquote(~~ Time ~ .(jj)),
# 						ylab="", xlab="")
# 		}
# dev.off()
hh <- hh + 1
# plot stuff
m.n <- as.numeric(strsplit(h, "")[[1]])
header <- bquote("C | sp" * .(ifelse(s=="1",":Yes",":No")) * ", "
* eta[1]*.(ifelse(m.n[1]==1,":Yes",":No"))*","~
phi[1]*.(ifelse(m.n[2]==1,":Yes",":No"))*","~
alpha[t]*.(ifelse(m.n[3]==1,":Yes",":No")))
parts = generate_partition(out)
plot_ARI(parts,header)
}
dev.off()
}
tempo_fine <- Sys.time()
differenza_tempo <- tempo_fine - tempo_inizio
cat(crayon::cyan("Fit took:\n"))
print(round(differenza_tempo,digits = 4))
tempo_inizio <- Sys.time()
set.seed(1)
C.models.out <- list()
hh <- 1
# s="1"
# h <- "111"; s <- "0";
model <- "C"
for(s in c("0","1")){
pdf(paste0("gstat_test_C_sp",s,".pdf"),height=11.7, width=8)
par(mfrow=c(4,2),mar=c(2,2,2,2), mgp=c(1.5,0.5,0))
for(h in c("111","110","101","100","011","010","001","000")){
m.n <- as.numeric(strsplit(h, "")[[1]])
eta1Update <- m.n[1]!=0
phi1Update <- m.n[2]!=0
alphaUpdate <- m.n[3]!=0
if(s=="0"){
sc <- NULL
} else {
sc <- s_std
}
cat("model is ", h, "\n")
cat("space is ", s, "\n")
cat("seed is ", 1*hh, "\n")
set.seed(1*hh)
# param_0 = 1 <=> we update it
# param_0 = 0 <=> we dont update it
out = drpm_fit(
y=y,
s_coords = sc,
M=1,
initial_partition = NULL,
starting_alpha = 0.5,
unit_specific_alpha = FALSE,
time_specific_alpha = FALSE,
alpha_0 = ifelse(alphaUpdate, 0, 1),
eta1_0 = ifelse(eta1Update, 0, 1),
phi1_0 = ifelse(phi1Update, 0, 1),
modelPriors=c(m0_phi0,s20_phi0,A_ub_sigma,A_ub_tau,A_ub_lambda,eta1_scale),
alphaPriors=rbind(c(a_alpha,b_alpha)),
simpleModel = 0,
SpatialCohesion=sp,
cParms=c(mu0, k0, v0, L0),
mh=c(sig_mh_sig2,sig_mh_tau2,sig_mh_lambda2,sig_mh_eta1,sig_mh_phi1),
draws=niter,burn=nburn,thin=nthin)
# print(date())
cat("lpml = ", out$lpml, "\n")
cat("waic = ", out$waic, "\n\n\n")
C.models.out[[hh]] <-  out
names(C.models.out)[hh] <- paste0("out",h,"_",model)
# If there is desire to produce plot of each fit uncomment these lines
rho <- list()
# ccprob <- list()
#
for(k in 1:tps){
rho[[k]] <- salso(t(out$Si[k,,]), loss="binder")
}
# amn <- round(apply(C.models.out[[hh]]$alpha,2,mean),2)
# print(amn)
# pdf(paste0("PM10_", h,"_",s,"_",model,"_SC",sp,"_2.pdf"),
# 	    height=10, width=12.5)
# 		# pchs <- c(letters, paste0(letters,0:9))
# 		par(mfrow=c(3,4))
# 		for(jj in 1:tps){
# 			cex1 <- ((y[,jj]-mean(y[,jj]))/sd(y[,jj])+3)/3
# 			plot(s_std, col=rho[[jj]], pch=19,cex=cex1,
# 			# plot(s_std, col=rho[[jj]], pch=pchs[rho[[jj]]],cex=cex1,
# 						# main=bquote(alpha==.(amn[jj]) ~~ Time ~ .(jj)),
# 						main=bquote(~~ Time ~ .(jj)),
# 						ylab="", xlab="")
# 		}
# dev.off()
hh <- hh + 1
# plot stuff
m.n <- as.numeric(strsplit(h, "")[[1]])
header <- bquote("C | sp" * .(ifelse(s=="1",":Yes",":No")) * ", "
* eta[1]*.(ifelse(m.n[1]==1,":Yes",":No"))*","~
phi[1]*.(ifelse(m.n[2]==1,":Yes",":No"))*","~
alpha[t]*.(ifelse(m.n[3]==1,":Yes",":No")))
parts = generate_partition(out)
plot_ARI(parts,header)
}
dev.off()
}
tempo_fine <- Sys.time()
differenza_tempo <- tempo_fine - tempo_inizio
cat(crayon::cyan("Fit took:\n"))
print(round(differenza_tempo,digits = 4))
names(C.models.out)
model
tempo_inizio <- Sys.time()
set.seed(1)
C.models.out <- list()
hh <- 1
# s="1"
# h <- "111"; s <- "0";
model <- "C"
for(s in c("0","1")){
pdf(paste0("gstat_test_C_sp",s,".pdf"),height=11.7, width=8)
par(mfrow=c(4,2),mar=c(2,2,2,2), mgp=c(1.5,0.5,0))
for(h in c("111","110","101","100","011","010","001","000")){
m.n <- as.numeric(strsplit(h, "")[[1]])
eta1Update <- m.n[1]!=0
phi1Update <- m.n[2]!=0
alphaUpdate <- m.n[3]!=0
if(s=="0"){
sc <- NULL
} else {
sc <- s_std
}
cat("model is ", h, "\n")
cat("space is ", s, "\n")
cat("seed is ", 1*hh, "\n")
set.seed(1*hh)
# param_0 = 1 <=> we update it
# param_0 = 0 <=> we dont update it
out = drpm_fit(
y=y,
s_coords = sc,
M=1,
initial_partition = NULL,
starting_alpha = 0.5,
unit_specific_alpha = FALSE,
time_specific_alpha = FALSE,
alpha_0 = ifelse(alphaUpdate, 0, 1),
eta1_0 = ifelse(eta1Update, 0, 1),
phi1_0 = ifelse(phi1Update, 0, 1),
modelPriors=c(m0_phi0,s20_phi0,A_ub_sigma,A_ub_tau,A_ub_lambda,eta1_scale),
alphaPriors=rbind(c(a_alpha,b_alpha)),
simpleModel = 0,
SpatialCohesion=sp,
cParms=c(mu0, k0, v0, L0),
mh=c(sig_mh_sig2,sig_mh_tau2,sig_mh_lambda2,sig_mh_eta1,sig_mh_phi1),
draws=niter,burn=nburn,thin=nthin)
# print(date())
cat("lpml = ", out$lpml, "\n")
cat("waic = ", out$waic, "\n\n\n")
C.models.out[[hh]] <-  out
names(C.models.out)[hh] <- paste0("out_",h,"_","sp_",s,"_",model)
# If there is desire to produce plot of each fit uncomment these lines
rho <- list()
# ccprob <- list()
#
for(k in 1:tps){
rho[[k]] <- salso(t(out$Si[k,,]), loss="binder")
}
# amn <- round(apply(C.models.out[[hh]]$alpha,2,mean),2)
# print(amn)
# pdf(paste0("PM10_", h,"_",s,"_",model,"_SC",sp,"_2.pdf"),
# 	    height=10, width=12.5)
# 		# pchs <- c(letters, paste0(letters,0:9))
# 		par(mfrow=c(3,4))
# 		for(jj in 1:tps){
# 			cex1 <- ((y[,jj]-mean(y[,jj]))/sd(y[,jj])+3)/3
# 			plot(s_std, col=rho[[jj]], pch=19,cex=cex1,
# 			# plot(s_std, col=rho[[jj]], pch=pchs[rho[[jj]]],cex=cex1,
# 						# main=bquote(alpha==.(amn[jj]) ~~ Time ~ .(jj)),
# 						main=bquote(~~ Time ~ .(jj)),
# 						ylab="", xlab="")
# 		}
# dev.off()
hh <- hh + 1
# plot stuff
m.n <- as.numeric(strsplit(h, "")[[1]])
header <- bquote("C | sp" * .(ifelse(s=="1",":Yes",":No")) * ", "
* eta[1]*.(ifelse(m.n[1]==1,":Yes",":No"))*","~
phi[1]*.(ifelse(m.n[2]==1,":Yes",":No"))*","~
alpha[t]*.(ifelse(m.n[3]==1,":Yes",":No")))
parts = generate_partition(out)
plot_ARI(parts,header)
}
dev.off()
}
tempo_fine <- Sys.time()
differenza_tempo <- tempo_fine - tempo_inizio
cat(crayon::cyan("Fit took:\n"))
print(round(differenza_tempo,digits = 4))
names(C.models.out)
seed
burnin
niter
tempo_inizio <- Sys.time()
set.seed(1)
J.models.out <- list()
hh <- 1
# s="1"
# h <- "111"; s <- "0";
# model <- "J"
for(s in c("0","1")){
pdf(paste0("gstat_test_C_sp",s,".pdf"),height=11.7, width=8)
par(mfrow=c(4,2),mar=c(2,2,2,2), mgp=c(1.5,0.5,0))
for(h in c("111","110","101","100","011","010","001","000")){
m.n <- as.numeric(strsplit(h, "")[[1]])
eta1Update <- m.n[1]==1
phi1Update <- m.n[2]==1
alphaUpdate <- m.n[3]==1
# convention of the C code:
# param_0 = 1 <=> we update it
# param_0 = 0 <=> we dont update it
if(s=="0"){
sc <- NULL
} else {
sc <- s_std
}
cat("model is ", h, "\n")
cat("space is ", s, "\n")
# cat("seed is ", 1*hh, "\n")
# set.seed(1*hh)
out = module_JDRPM$MCMC_fit(
Y=as.matrix(y),
sp_coords = sc,
M_dp = 1,
initial_partition = NA,
Xlk_covariates = NA,
Xcl_covariates = NA,
starting_alpha = 0.5,
unit_specific_alpha = FALSE,
time_specific_alpha = FALSE,
update_alpha = alphaUpdate,
include_eta1 = TRUE,
include_phi1 = TRUE,
update_eta1 = eta1Update,
update_phi1 = phi1Update,
sig2h_priors = c(a_sigma,b_sigma),
eta1_priors = c(eta1_scale,sig_mh_eta1^2),
# beta_priors = c(rep(1,p),2),
beta_priors = NA,
tau2_priors = c(a_tau,b_tau),
phi0_priors = c(m0_phi0,s20_phi0),
phi1_priors = sig_mh_phi1^2,
lambda2_priors = c(a_lambda,b_lambda),
alpha_priors = c(a_alpha,b_alpha),
spatial_cohesion_idx = sp,
sp_params = list(c(mu0,mu0),k0,v0,matrix(c(L0,0.0,0.0,L0),nrow=2)),
draws = niter,burnin = nburn, thin = nthin,
logging = FALSE,
seed = seed
)
rout = juliaGet(out)
names(rout) = c("Si","gamma","alpha", "sigma2h", "muh", "eta1","beta",
"theta", "tau2", "phi0", "phi1","lambda2","fitted",
"llike","lpml","waic")
# reshape some stuff to uniform it to drpm output
rout$Si           = aperm(rout$Si,       c(2, 1, 3))
rout$gamma        = aperm(rout$gamma,    c(2, 1, 3))
rout$sigma2h      = aperm(rout$sigma2h,  c(2, 1, 3))
rout$muh          = aperm(rout$muh,      c(2, 1, 3))
rout$fitted       = aperm(rout$fitted,   c(2, 1, 3))
rout$llike        = aperm(rout$llike,    c(2, 1, 3))
if (is.null(size(rout$alpha))) {
# do nothing
# } else if size(rout$alpha) == 2 {
} else {
rout$alpha        = aperm(rout$alpha,    c(2, 1))
}
rout$theta        = aperm(rout$theta,    c(2, 1))
rout$tau2         = aperm(rout$tau2,     c(2, 1))
rout$eta1         = aperm(rout$eta1,    c(2, 1))
rout$phi0     = matrix(rout$phi0,    ncol = 1)
rout$phi1     = matrix(rout$phi1,    ncol = 1)
rout$lambda2  = matrix(rout$lambda2, ncol = 1)
J.models.out[[hh]] <-  out
names(J.models.out)[hh] <- paste0("out_",h,"_","sp",s,"_",model)
# If there is desire to produce plot of each fit uncomment these lines
rho <- list()
# ccprob <- list()
#
for(k in 1:tps){
rho[[k]] <- salso(t(rout$Si[k,,]), loss="binder")
}
# amn <- round(apply(C.models.out[[hh]]$alpha,2,mean),2)
# print(amn)
# pdf(paste0("PM10_", h,"_",s,"_",model,"_SC",sp,"_2.pdf"),
# 	    height=10, width=12.5)
# 		# pchs <- c(letters, paste0(letters,0:9))
# 		par(mfrow=c(3,4))
# 		for(jj in 1:tps){
# 			cex1 <- ((y[,jj]-mean(y[,jj]))/sd(y[,jj])+3)/3
# 			plot(s_std, col=rho[[jj]], pch=19,cex=cex1,
# 			# plot(s_std, col=rho[[jj]], pch=pchs[rho[[jj]]],cex=cex1,
# 						# main=bquote(alpha==.(amn[jj]) ~~ Time ~ .(jj)),
# 						main=bquote(~~ Time ~ .(jj)),
# 						ylab="", xlab="")
# 		}
# dev.off()
hh <- hh + 1
# plot stuff
m.n <- as.numeric(strsplit(h, "")[[1]])
header <- bquote("J | sp" * .(ifelse(s=="1",":Yes",":No")) * ", "
* eta[1]*.(ifelse(m.n[1]==1,":Yes",":No"))*","~
phi[1]*.(ifelse(m.n[2]==1,":Yes",":No"))*","~
alpha[t]*.(ifelse(m.n[3]==1,":Yes",":No")))
parts = generate_partition(rout)
plot_ARI(parts,header)
}
dev.off()
}
m.n <- as.numeric(strsplit(h, "")[[1]])
eta1Update <- m.n[1]==1
phi1Update <- m.n[2]==1
alphaUpdate <- m.n[3]==1
if(s=="0"){
sc <- NULL
} else {
sc <- s_std
}
cat("model is ", h, "\n")
cat("space is ", s, "\n")
out = module_JDRPM$MCMC_fit(
Y=as.matrix(y),
sp_coords = sc,
M_dp = 1,
initial_partition = NA,
Xlk_covariates = NA,
Xcl_covariates = NA,
starting_alpha = 0.5,
unit_specific_alpha = FALSE,
time_specific_alpha = FALSE,
update_alpha = alphaUpdate,
include_eta1 = TRUE,
include_phi1 = TRUE,
update_eta1 = eta1Update,
update_phi1 = phi1Update,
sig2h_priors = c(a_sigma,b_sigma),
eta1_priors = c(eta1_scale,sig_mh_eta1^2),
# beta_priors = c(rep(1,p),2),
beta_priors = NA,
tau2_priors = c(a_tau,b_tau),
phi0_priors = c(m0_phi0,s20_phi0),
phi1_priors = sig_mh_phi1^2,
lambda2_priors = c(a_lambda,b_lambda),
alpha_priors = c(a_alpha,b_alpha),
spatial_cohesion_idx = sp,
sp_params = list(c(mu0,mu0),k0,v0,matrix(c(L0,0.0,0.0,L0),nrow=2)),
draws = niter,burnin = nburn, thin = nthin,
logging = FALSE,
seed = seed
)
sc
module_JDRPM$test_R_to_J_conversion(sc)
module_JDRPM <- juliaImport(juliaCall("include", module))
out = module_JDRPM$MCMC_fit(
Y=as.matrix(y),
sp_coords = sc,
M_dp = 1,
initial_partition = NA,
Xlk_covariates = NA,
Xcl_covariates = NA,
starting_alpha = 0.5,
unit_specific_alpha = FALSE,
time_specific_alpha = FALSE,
update_alpha = alphaUpdate,
include_eta1 = TRUE,
include_phi1 = TRUE,
update_eta1 = eta1Update,
update_phi1 = phi1Update,
sig2h_priors = c(a_sigma,b_sigma),
eta1_priors = c(eta1_scale,sig_mh_eta1^2),
# beta_priors = c(rep(1,p),2),
beta_priors = NA,
tau2_priors = c(a_tau,b_tau),
phi0_priors = c(m0_phi0,s20_phi0),
phi1_priors = sig_mh_phi1^2,
lambda2_priors = c(a_lambda,b_lambda),
alpha_priors = c(a_alpha,b_alpha),
spatial_cohesion_idx = sp,
sp_params = list(c(mu0,mu0),k0,v0,matrix(c(L0,0.0,0.0,L0),nrow=2)),
draws = niter,burnin = nburn, thin = nthin,
logging = FALSE,
seed = seed
)
module_JDRPM <- juliaImport(juliaCall("include", module))
tempo_inizio <- Sys.time()
set.seed(1)
J.models.out <- list()
hh <- 1
# s="1"
# h <- "111"; s <- "0";
# model <- "J"
for(s in c("0","1")){
pdf(paste0("gstat_test_C_sp",s,".pdf"),height=11.7, width=8)
par(mfrow=c(4,2),mar=c(2,2,2,2), mgp=c(1.5,0.5,0))
for(h in c("111","110","101","100","011","010","001","000")){
m.n <- as.numeric(strsplit(h, "")[[1]])
eta1Update <- m.n[1]==1
phi1Update <- m.n[2]==1
alphaUpdate <- m.n[3]==1
# convention of the C code:
# param_0 = 1 <=> we update it
# param_0 = 0 <=> we dont update it
if(s=="0"){
sc <- NULL
} else {
sc <- s_std
}
cat("model is ", h, "\n")
cat("space is ", s, "\n")
# cat("seed is ", 1*hh, "\n")
# set.seed(1*hh)
out = module_JDRPM$MCMC_fit(
Y=as.matrix(y),
sp_coords = sc,
M_dp = 1,
initial_partition = NA,
Xlk_covariates = NA,
Xcl_covariates = NA,
starting_alpha = 0.5,
unit_specific_alpha = FALSE,
time_specific_alpha = FALSE,
update_alpha = alphaUpdate,
include_eta1 = TRUE,
include_phi1 = TRUE,
update_eta1 = eta1Update,
update_phi1 = phi1Update,
sig2h_priors = c(a_sigma,b_sigma),
eta1_priors = c(eta1_scale,sig_mh_eta1^2),
# beta_priors = c(rep(1,p),2),
beta_priors = NA,
tau2_priors = c(a_tau,b_tau),
phi0_priors = c(m0_phi0,s20_phi0),
phi1_priors = sig_mh_phi1^2,
lambda2_priors = c(a_lambda,b_lambda),
alpha_priors = c(a_alpha,b_alpha),
spatial_cohesion_idx = sp,
sp_params = list(c(mu0,mu0),k0,v0,matrix(c(L0,0.0,0.0,L0),nrow=2)),
draws = niter,burnin = nburn, thin = nthin,
logging = FALSE,
seed = seed
)
rout = juliaGet(out)
names(rout) = c("Si","gamma","alpha", "sigma2h", "muh", "eta1","beta",
"theta", "tau2", "phi0", "phi1","lambda2","fitted",
"llike","lpml","waic")
# reshape some stuff to uniform it to drpm output
rout$Si           = aperm(rout$Si,       c(2, 1, 3))
rout$gamma        = aperm(rout$gamma,    c(2, 1, 3))
rout$sigma2h      = aperm(rout$sigma2h,  c(2, 1, 3))
rout$muh          = aperm(rout$muh,      c(2, 1, 3))
rout$fitted       = aperm(rout$fitted,   c(2, 1, 3))
rout$llike        = aperm(rout$llike,    c(2, 1, 3))
if (is.null(size(rout$alpha))) {
# do nothing
# } else if size(rout$alpha) == 2 {
} else {
rout$alpha        = aperm(rout$alpha,    c(2, 1))
}
rout$theta        = aperm(rout$theta,    c(2, 1))
rout$tau2         = aperm(rout$tau2,     c(2, 1))
rout$eta1         = aperm(rout$eta1,    c(2, 1))
rout$phi0     = matrix(rout$phi0,    ncol = 1)
rout$phi1     = matrix(rout$phi1,    ncol = 1)
rout$lambda2  = matrix(rout$lambda2, ncol = 1)
J.models.out[[hh]] <-  out
names(J.models.out)[hh] <- paste0("out_",h,"_","sp",s,"_",model)
# If there is desire to produce plot of each fit uncomment these lines
rho <- list()
# ccprob <- list()
#
for(k in 1:tps){
rho[[k]] <- salso(t(rout$Si[k,,]), loss="binder")
}
# amn <- round(apply(C.models.out[[hh]]$alpha,2,mean),2)
# print(amn)
# pdf(paste0("PM10_", h,"_",s,"_",model,"_SC",sp,"_2.pdf"),
# 	    height=10, width=12.5)
# 		# pchs <- c(letters, paste0(letters,0:9))
# 		par(mfrow=c(3,4))
# 		for(jj in 1:tps){
# 			cex1 <- ((y[,jj]-mean(y[,jj]))/sd(y[,jj])+3)/3
# 			plot(s_std, col=rho[[jj]], pch=19,cex=cex1,
# 			# plot(s_std, col=rho[[jj]], pch=pchs[rho[[jj]]],cex=cex1,
# 						# main=bquote(alpha==.(amn[jj]) ~~ Time ~ .(jj)),
# 						main=bquote(~~ Time ~ .(jj)),
# 						ylab="", xlab="")
# 		}
# dev.off()
hh <- hh + 1
# plot stuff
m.n <- as.numeric(strsplit(h, "")[[1]])
header <- bquote("J | sp" * .(ifelse(s=="1",":Yes",":No")) * ", "
* eta[1]*.(ifelse(m.n[1]==1,":Yes",":No"))*","~
phi[1]*.(ifelse(m.n[2]==1,":Yes",":No"))*","~
alpha[t]*.(ifelse(m.n[3]==1,":Yes",":No")))
parts = generate_partition(rout)
plot_ARI(parts,header)
}
dev.off()
}
tempo_fine <- Sys.time()
differenza_tempo <- tempo_fine - tempo_inizio
cat(crayon::cyan("Fit took:\n"))
print(round(differenza_tempo,digits = 4))
