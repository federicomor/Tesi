---
title: "Untitled"
output: html_document
---

```{r}
#######################################################################################
#						    										 				  #
# Spatio-temporal data set with rural background PM10 concentrations in Germany 2005  #
#                           														  #
#######################################################################################

# Set working directory to folder "JCGS_Codes" folder.
# setwd("JCGS_Codes")
# source("Functions.R")
library(salso)
library(MCMCpack)
library(mclust)
source("../src/include.R") # just for helper functions morally
```


# LOAD 
## load C drpm
```{r}
devtools::load_all("../../drpm_main/")
# devtools::load_all("../../drpm_sporcato/")
```

## load J drpm
```{r}
library(JuliaConnectoR)
juliaSetupOk()

# juliaEval("using Pkg")
# juliaEval("Pkg.activate(\"../../JDRPM\")")
# juliaEval("Pkg.instantiate()")

# setup project
juliaEval("using Pkg; Pkg.status()")
juliaEval("Pkg.activate(\"../../JDRPM\")")
juliaEval("using Pkg; Pkg.status()")

module = normalizePath("../../JDRPM/src/JDRPM.jl")
module_JDRPM <- juliaImport(juliaCall("include", module))
```

# Data
```{r}
# This data is found in the gstat package
library(gstat)
data(DE_RB_2005)
dat <- DE_RB_2005

# Create ymat with columns corresponding to time rows stations
N <- length(dat@sp)
Tm <- 365
y <- matrix(NA, nrow=N, ncol=Tm)
for(i in 1:Tm){
	y[dat@index[dat@index[,2]==i,1], i] <- dat@data[dat@index[,2]==i,1]
}

# Try to create an average PM10 per month
year <- c(rep(1,31),rep(2,28),rep(3,31),rep(4,30),rep(5,31),
         rep(6,30),rep(7,31),rep(8,31),rep(9,30),rep(10,31),
         rep(11,30),rep(12,31))
week <- rep(1:52, each=7)
ymn <- t(apply(y, 1, function(x) tapply(x,year,mean, na.rm=TRUE)))


## Keep those that don't have any missing values when overageing over a month
ysub2 <- ymn[-c(4,16,25,27,30,43,52,59,69),]


mn <- apply(ysub2,2,mean)
sd <- apply(ysub2,2,sd)

# Center the observations
y <- t(t(ysub2) - mn)

cols = colora(len=size(y)[1],56,0)
# original real data
for(i in 1:size(y)[1]){
   if(i==1){
     plot(1:size(y)[2],y[i,],col=cols[i],type='l',
     	 xlab='time',ylab='values',main="original data",
     	 ylim=extrema(y))
 	  } 
	  else{
		  lines(1:size(y)[2],y[i,],col=cols[i])
	  }
}
tps <- ncol(y)

s_coords <- (dat@sp@coords)[-c(4,16,25,27,30,43,52,59,69),]
smn <- apply(s_coords,2,mean)
ssd <- apply(s_coords,2,sd)
s_std <- t((t(s_coords) - smn)/ssd)
```

# Plot functions
```{r}
N = size(y)[1]
Tm = size(y)[2]

generate_partition = function(model){
	partition = list()
	for (t in 1:Tm){
		Si_jt <- model$Si[t, , ]
		Si_jt <- t(Si_jt) 
		partition[[t]] <- salso(Si_jt, loss = "binder")
	}
	return(partition)
}

plot_partition_with_numbers = function(partition,title){
	partition_matrix <- do.call(cbind, partition)
	plot(NULL, NULL, xlim = c(1, Tm), ylim = c(1, N)+c(-0.5,0.5),
	     xlab = "time", ylab = "units",
	     xaxt = "n", yaxt = "n", main = title)
	axis(1, at = 1:Tm, labels = 1:Tm)
	for (t in 1:Tm) {
	  for (unit in 1:N) {
	    text(x = t, y = unit, labels = as.character(unit),
	         col = partition_matrix[unit, t], cex = 1.5)
	  }
	}
}

plot_ARI = function(partition,title){
	LEN = Tm
	df_cluster = data.frame(clusters=c(),Time=c())
	for(time in 1:Tm){
		salso_out <- partition[[time]]
		df_temp = data.frame(
			clusters = salso_out
		)
		df_temp$Time = rep(time,dim(df_temp)[1])
		df_cluster = rbind(df_cluster,df_temp)
		# clusters log
		# clusters_now = df_temp$clusters
		# n_clusters = unique(clusters_now)
		# cat(crayon::red("Time",time,"- #clusters =",length(unique(clusters_now)),"\n"))
	}
	library(mclust)
	# build the ARI matrix
	ARImats <- matrix(NA, nrow=LEN, ncol=LEN)
	rho_ARI <- list()
	for(k in 1:LEN){
		rho_ARI[[k]] <- partition[[k]]
	}
	for(k in 1: LEN){
		for(kk in 1: LEN){
			ARImats[k,kk] <- adjustedRandIndex(rho_ARI[[k]], rho_ARI[[kk]])
		}
	}
	ncols_ari = 100
	# if (min(ARImats)<0){
		# cols_ARI = colora(ncols_ari,79,0)
		# brks = seq(min(-1,floor(min(ARImats))),1,length.out=ncols_ari+1)
	# } else {
		# cols_ARI = colora(ncols_ari,56,0)
		# cols_ARI = rev(cols_ARI) # must be ordered from cold to warm
		cols_ARI = rev(colora(ncols_ari,104,0)) # or 109
		# cols_ARI = colora(ncols_ari,102,0)
		# brks = seq(0,1,length.out=ncols_ari+1)
		brks = seq(min(-1,floor(min(ARImats))),1,length.out=ncols_ari+1)
	# }
	# or see ?designer.colors for colors
	library(fields)
	image.plot(ARImats,
			   main=title,axes=FALSE,col=cols_ARI,
			   # main=paste0("Lagged ARI values - ",title),axes=FALSE,col=cols_ARI,
			   breaks=brks)
	mtext(text=c(paste("",1:LEN)), side=2, line=0.3,at=seq(0,1,length=LEN), las=1, cex=0.8)
	mtext(text=c(paste("",1:LEN)), side=1, line=0.3,at=seq(0,1,length=LEN), las=2, cex=0.8)
}
```

example
```{r,warning=F}
# ################################
# # model_name="model J"
# # model = rout
# model_name="model C"
# model = C.models.out[[1]]
# ################################
# parts = generate_partition(rout)
# plot_partition_with_numbers(parts,model_name)
# plot_ARI(parts,model_name)
```

#========

# Params
```{r}
# as.integer(runif(1,0,1000))*1.0
# seed = 881.0
seed = 314.0
cat("seed",seed,"\n")

niter=50000; nburn=10000; nthin=40 # valori del file originale
# niter=50000; nburn=30000; nthin=20 # scelta intermedia?
# niter=30000; nburn=22000; nthin=8 # secondo i miei test
niter=20; nburn=0; nthin=1 # test super veloce
nout <- (niter-nburn)/nthin
cat(nout,"valid iterations\n")
```

```{r}
# params
m0_phi0 = 0
s20_phi0 = 10
A_ub_sigma = 5
A_ub_tau = 5
A_ub_lambda = 5

a_sigma  = 2; b_sigma  = 2
a_tau    = 2; b_tau    = 2
a_lambda = 2; b_lambda = 2
eta1_scale = 1

sig_mh_sig2 = 0.4
sig_mh_tau2 = 0.4
sig_mh_lambda2 = 0.4
sig_mh_eta1 = 0.1
sig_mh_phi1 = 0.1

a_alpha = 2; b_alpha = 2

# now space
sp = 3
mu0 = 0 
k0 = 1
v0 = 5
L0 = 1
```


# Fit C
ci ha messo 43 minuti a fittare 3k iterazioni per ogni modello
sono 16 modelli => tempo medio per iterazione = 43min / (3k*16) = 0.0008958333

il fit serio prevede 50k iterazioni per modello
=> tempo tot stimate = 0.0008958333 * (50k*16) = 716min = 12h :/
con 40k iterazioni?
=> tempo tot stimate = 0.0008958333 * (40k*16) = 573min = 9.5h :/
con 30k iterazioni?
=> tempo tot stimate = 0.0008958333 * (30k*16) = 430min = 7h :/

```{r,warning=F}
tempo_inizio <- Sys.time()
set.seed(9)
C.models.out <- list()
hh <- 1
# s="1"
# h <- "111"; s <- "0";
model <- "C"
for(s in c("0","1")){
	pdf(paste0("gstat_test_C_sp",s,".pdf"),height=11.7, width=8.3)
	par(mfrow=c(4,2),mar=c(2,2,2,2), mgp=c(1.5,0.5,0))
	
	for(h in c("111","110","101","100","011","010","001","000")){

	  m.n <- as.numeric(strsplit(h, "")[[1]])

	  eta1Update <- m.n[1]!=0
	  phi1Update <- m.n[2]!=0
	  alphaUpdate <- m.n[3]!=0

	  if(s=="0"){
		  sc <- NULL
	  } else {
		  sc <- s_std
	  }

	  cat("model is ", h, "\n")
	  cat("space is ", s, "\n")
	  # set.seed(1*hh)
	  # set.seed(1*(hh+1)^3)
	  # set.seed(runif(1,0,100))
	  # cat("seed is ", 1*hh, "\n")

# param_0 = 0 <=> we update it
# param_0 = 1 <=> we dont update it

	  out = drpm_fit(
		y=y,
		s_coords = sc,
        M=1,
        initial_partition = NULL,
        starting_alpha = 0.5,
        unit_specific_alpha = FALSE,
        time_specific_alpha = FALSE,
		alpha_0 = ifelse(alphaUpdate, 0, 1), # if true it puts 0
		# ah the sense should be "do we keep the same paramvalue_0 for all the fitting"?
		# then we answer no if we want to update it... a bit unclear in the docs
        eta1_0 = ifelse(eta1Update, 0, 1),
        phi1_0 = ifelse(phi1Update, 0, 1),
        modelPriors=c(m0_phi0,s20_phi0,A_ub_sigma,A_ub_tau,A_ub_lambda,eta1_scale),
        alphaPriors=rbind(c(a_alpha,b_alpha)),
        simpleModel = 0,
		SpatialCohesion=sp,
		cParms=c(mu0, k0, v0, L0),
		mh=c(sig_mh_sig2,sig_mh_tau2,sig_mh_lambda2,sig_mh_eta1,sig_mh_phi1),
		draws=niter,burn=nburn,thin=nthin)
		# draws=200,burn=100,thin=1)
	  
	  
	  # print(date())
    cat("lpml = ", out$lpml, "\n")
    cat("waic = ", out$waic, "\n\n\n")
		C.models.out[[hh]] <-  out
		names(C.models.out)[hh] <- paste0("Cout_",h,"_","sp",s,"_",model)

        # If there is desire to produce plot of each fit uncomment these lines
		rho <- list()
		# ccprob <- list()
		# 
		for(k in 1:tps){
			rho[[k]] <- salso(t(out$Si[k,,]), loss="binder")
		}
		# amn <- round(apply(C.models.out[[hh]]$alpha,2,mean),2)
		# print(amn)

	pdf(paste0("C_", h,"_sp",s,".pdf"),height=10, width=12)
			# pchs <- c(letters, paste0(letters,0:9))
			# pchs = c(1:20)
			par(mfrow=c(3,4),mar=c(2.5,2.5,2.5,1),oma=c(1,1,3,1))
			for(jj in 1:tps){
				cex1 <- ((y[,jj]-mean(y[,jj]))/sd(y[,jj])+3)/2
				cex1 = cex1^1.2
				plot(s_std, col=rho[[jj]],
					 cex=cex1,
					 pch=19,
					 # pch=pchs[rho[[jj]]],
					 		# main=bquote(alpha==.(amn[jj]) ~~ Time ~ .(jj)),
							main=bquote(~~ Time ~ .(jj)),
							ylab="", xlab="")
			}
			header <- bquote("C | sp" * .(ifelse(s==1,":Yes",":No")) * ", "~
							 	eta[1]*.(ifelse(m.n[1]==1,":Yes",":No"))*", "~
	    	             phi[1]*.(ifelse(m.n[2]==1,":Yes",":No"))*", "~
	        	         alpha[t]*.(ifelse(m.n[3]==1,":Yes",":No")))
			mtext(header, side = 3, line = 0, outer = TRUE, font=2, cex=1.5)
	dev.off()
	
		hh <- hh + 1
		
		# plot stuff
		m.n <- as.numeric(strsplit(h, "")[[1]])
		header <- bquote("C | sp" * .(ifelse(s=="1",":Yes",":No")) * ", "
						 * eta[1]*.(ifelse(m.n[1]==1,":Yes",":No"))*","~
	    	             phi[1]*.(ifelse(m.n[2]==1,":Yes",":No"))*","~
	        	         alpha[t]*.(ifelse(m.n[3]==1,":Yes",":No")))
		
		parts = generate_partition(out)
		plot_ARI(parts,header)
		
	}
	dev.off()
}
tempo_fine <- Sys.time()
differenza_tempo <- tempo_fine - tempo_inizio
cat(crayon::cyan("Fit took:\n"))
print(round(differenza_tempo,digits = 4))
```


```{r}
drpm1 = C.models.out[[3]]
```


```{r}
for (time in 1:Tm){
		# par(mfrow=c(1,2),mar=c(2,2,4,2))

plot(drpm1$alpha[,time],type="l",
	 main=bquote("Model DRPM C\nTrace plot of alpha at time "*.(time)
	 ), ylim=c(0,1),
	 xlab = "MCMC iterations",ylab="values")
# plot(rout$alpha[,time],type="l",
# 	 main=bquote("Model DRPM J\nTrace plot of alpha at time "*.(time)
# 	 ), ylim=c(0,1),
# 	 xlab = "MCMC iterations",ylab="values")
}
size(drpm1$mu)
# size(rout$muh)
unitj = 1
for (time in 1:Tm){
		# par(mfrow=c(1,2),mar=c(2,2,4,2))

	plot(drpm1$mu[time,unitj,],type="l",
		 ylim=c(min(drpm1$mu[time,unitj,]),max(drpm1$mu[time,unitj,])),
		 main=bquote("Model DRPM C\nTrace plot of mu at time "*.(time) * " unit " * .(unitj)),
		 xlab = "MCMC iterations",ylab="values")
	# plot(rout$muh[time,unitj,],type="l",
	# 	 ylim=c(min(drpm1$mu[time,unitj,],rout$muh[time,unitj,]),
	# 	 	   max(drpm1$mu[time,unitj,],rout$muh[time,unitj,])),
	# 	 main=bquote("Model DRPM J\nTrace plot of mu at time "*.(time) * " unit " * .(unitj)),
	# 	 xlab = "MCMC iterations",ylab="values")
}
size(drpm1$sig2)
# size(rout$sigma2h)
unitj = 1
for (time in 1:Tm){
		# par(mfrow=c(1,2),mar=c(2,2,4,2))

	plot(drpm1$sig2[time,unitj,],type="l",
		 main=bquote("Model DRPM C\nTrace plot of sigma2 at time "*.(time) * " unit " * .(unitj)),
		 ylim=c(0,max(drpm1$sig2[time,unitj,])),
		 xlab = "MCMC iterations",ylab="values")
	# plot(rout$sigma2h[time,unitj,],type="l",
	# 	 main=bquote("Model DRPM J\nTrace plot of sigma2 at time "*.(time) * " unit " * .(unitj)),
	# 	 ylim=c(0,max(drpm1$sig2[time,unitj,], rout$sigma2h[time,unitj,])),
	# 	 xlab = "MCMC iterations",ylab="values")
}
```


```{r,warning=F}
##########################
model_name = "model C"
partition = generate_partition(C.models.out[[1]])
##########################

par(mar=c(1,1,1,1))
for (time in 1:Tm){
	salso_out = partition[[time]]
	ssout = summary(salso_out)
	# plot(ssout,type="heatmap")
	# plot(ssout,type="mds")
	plot(ssout,type="pairs",data=s_std)
	text(0.3,0.91,pos=3,paste0(model_name," - Time ",time))
	# plot(ssout,type="dendrogram")
	# dev.off()
}
```

```{r,warning=F}
##########################
model = "model C"
partition = generate_partition(C.models.out[[1]])
##########################
par(mfrow=c(3,4),mar=c(1,1,2,1),oma=c(1,1,1,1))
# cols = rainbow(12)
for (time in 1:Tm){
	plot(s_std,pch=19,
		 # col=cols[partition[[time]]],
		 col=partition[[time]],
		 xlab="",ylab="",
		 axes = F,
		 cex=pmax(y[, time]/6, rep(0.5, N)),
		 main=paste0(model," at t=",time))
}
```


# Fit J
```{r,warning=F}
module_JDRPM <- juliaImport(juliaCall("include", module))
tempo_inizio <- Sys.time()
set.seed(1)
J.models.out <- list()
hh <- 1
# s="1"
# h <- "111"; s <- "0";
# model <- "J"
for(s in c("0","1")){
	pdf(paste0("gstat_test_J_sp",s,".pdf"),height=11.7, width=8.3)
	par(mfrow=c(4,2),mar=c(2,2,2,2), mgp=c(1.5,0.5,0))
	
	for(h in c("111","110","101","100","011","010","001","000")){

	  m.n <- as.numeric(strsplit(h, "")[[1]])

	  eta1Update <- m.n[1]==1
	  phi1Update <- m.n[2]==1
	  alphaUpdate <- m.n[3]==1
	  # convention of the C code:
		# param_0 = 1 <=> we update it
		# param_0 = 0 <=> we dont update it

	  if(s=="0"){
		  sc <- NULL
	  } else {
		  sc <- s_std
	  }

	  cat("model is ", h, "\n")
	  cat("space is ", s, "\n")
	  cat("seed is ", 1*hh, "\n")
	  # set.seed(1*hh)
	  seed = 1*hh

	  out = module_JDRPM$MCMC_fit(
			Y=as.matrix(y),              
			sp_coords = sc,
			M_dp = 1,                     
			initial_partition = NA,
			Xlk_covariates = NA,
			Xcl_covariates = NA,
			
			starting_alpha = 0.5,         
			unit_specific_alpha = FALSE,       
			time_specific_alpha = FALSE,       
			update_alpha = alphaUpdate,             
			
			include_eta1 = TRUE,                    
			include_phi1 = TRUE,
			update_eta1 = eta1Update,                    
			update_phi1 = phi1Update,
			
			sig2h_priors = c(a_sigma,b_sigma),
			eta1_priors = c(eta1_scale,sig_mh_eta1^2),
			# beta_priors = c(rep(1,p),2),
			beta_priors = NA,
			tau2_priors = c(a_tau,b_tau),
			phi0_priors = c(m0_phi0,s20_phi0),
			phi1_priors = sig_mh_phi1^2,
			lambda2_priors = c(a_lambda,b_lambda),
			alpha_priors = c(a_alpha,b_alpha),  
			
			spatial_cohesion_idx = sp,
			sp_params = list(c(mu0,mu0),k0,v0,matrix(c(L0,0.0,0.0,L0),nrow=2)),
			draws = niter,burnin = nburn, thin = nthin,
			logging = FALSE,
			seed = seed,
			simple_return = TRUE
		)
	  
		# rout = juliaGet(out)
		# names(rout) = c("Si","gamma","alpha", "sigma2h", "muh", "eta1","beta",
		# 				 "theta", "tau2", "phi0", "phi1","lambda2","fitted",
		# 				 "llike","lpml","waic")
		# # reshape some stuff to uniform it to drpm output
		# rout$Si           = aperm(rout$Si,       c(2, 1, 3))
		# rout$gamma        = aperm(rout$gamma,    c(2, 1, 3))
		# rout$sigma2h      = aperm(rout$sigma2h,  c(2, 1, 3))
		# rout$muh          = aperm(rout$muh,      c(2, 1, 3))
		# rout$fitted       = aperm(rout$fitted,   c(2, 1, 3))
		# rout$llike        = aperm(rout$llike,    c(2, 1, 3))
		# if (is.null(size(rout$alpha))) {
		# 	# do nothing
		# # } else if size(rout$alpha) == 2 {
		# } else {
		# 	rout$alpha        = aperm(rout$alpha,    c(2, 1))
		# }
		# rout$theta        = aperm(rout$theta,    c(2, 1))
		# rout$tau2         = aperm(rout$tau2,     c(2, 1))
		# rout$eta1         = aperm(rout$eta1,    c(2, 1))
		# rout$phi0     = matrix(rout$phi0,    ncol = 1)
		# rout$phi1     = matrix(rout$phi1,    ncol = 1)
		# rout$lambda2  = matrix(rout$lambda2, ncol = 1)
	    ############### now easier with simple_return option
	    rout = juliaGet(out)
		names(rout) = c("Si","lpml","waic")
		rout$Si = aperm(rout$Si, c(2, 1, 3))
			  
	  
		J.models.out[[hh]] <- rout
		names(J.models.out)[hh] <- paste0("Jout_",h,"_","sp",s,"_",model)

        # If there is desire to produce plot of each fit uncomment these lines
		rho <- list()
		# ccprob <- list()
		# 
		for(k in 1:tps){
			rho[[k]] <- salso(t(rout$Si[k,,]), loss="binder")
		}
		# amn <- round(apply(C.models.out[[hh]]$alpha,2,mean),2)
		# print(amn)

	pdf(paste0("J_", h,"_sp",s,".pdf"),height=10, width=12)
			# pchs <- c(letters, paste0(letters,0:9))
			par(mfrow=c(3,4),mar=c(2.5,2.5,2.5,1),oma=c(1,1,3,1))
			for(jj in 1:tps){
				cex1 <- ((y[,jj]-mean(y[,jj]))/sd(y[,jj])+3)/2
				cex1 = cex1^1.2
				plot(s_std, col=rho[[jj]], pch=19,cex=cex1,
				# plot(s_std, col=rho[[jj]], pch=pchs[rho[[jj]]],cex=cex1,
							# main=bquote(alpha==.(amn[jj]) ~~ Time ~ .(jj)),
							main=bquote(~~ Time ~ .(jj)),
							ylab="", xlab="")
			}
			header <- bquote("J | sp" * .(ifelse(s==1,":Yes",":No")) * ", "~
							 	eta[1]*.(ifelse(m.n[1]==1,":Yes",":No"))*", "~
	    	             phi[1]*.(ifelse(m.n[2]==1,":Yes",":No"))*", "~
	        	         alpha[t]*.(ifelse(m.n[3]==1,":Yes",":No")))
			mtext(header, side = 3, line = 0, outer = TRUE, font=2, cex=1.5)
	dev.off()
		hh <- hh + 1
		
		# plot stuff
		m.n <- as.numeric(strsplit(h, "")[[1]])
		header <- bquote("J | sp" * .(ifelse(s=="1",":Yes",":No")) * ", "
						 * eta[1]*.(ifelse(m.n[1]==1,":Yes",":No"))*","~
	    	             phi[1]*.(ifelse(m.n[2]==1,":Yes",":No"))*","~
	        	         alpha[t]*.(ifelse(m.n[3]==1,":Yes",":No")))
		
		parts = generate_partition(rout)
		plot_ARI(parts,header)
	}
	dev.off()
}
tempo_fine <- Sys.time()
differenza_tempo <- tempo_fine - tempo_inizio
cat(crayon::cyan("Fit took:\n"))
print(round(differenza_tempo,digits = 4))
```


```{r,warning=F}
par(mfrow=c(2,4),mar=c(2,2,2,2), mgp=c(1.5,0.5,0))
################################
model_name="\nmodel J"
model = rout
parts = generate_partition(rout)
plot_ARI(parts,model_name)
################################
model_name="\nmodel C"
model = C.models.out[[1]]
parts = generate_partition(rout)
plot_ARI(parts,model_name)
```

#========
# Plots
```{r}
# My run of output has been saved in an .RData object.
# It is provided and can be loaded if so desired. 
# load("./PM10_ALL_SpCo_4_rev.RData")
```


```{r}
# Create table that contains the WAIC and LPML values
lpml <- lpmlr <-  waic <- numeric()
amn <- matrix(NA, nrow = length(models.out), ncol=ncol(y))
for(j in 1:length(models.out)){
	lpml[j] <- models.out[[j]]$lpml
  # lpmlr[j] <- lpml.robust(models.out[[j]]$llike)[5]
	waic[j] <- models.out[[j]]$waic
	amn[j,] <- round(apply(models.out[[j]]$alpha,2,mean),2)
}
res <- data.frame(names=names(models.out), lpml=lpml, waic=waic)
res[order(res[,2]),]
```


```{r,warning=F}
library(xtable)
# Order as seen in Table 3 that focuses on Temporal models only
ord <- c(8,7,4,2,7,5,3,1,16,14,12,10,15,13,11,9)
# xtable(res[8:1,c(3,4)], digits=0)


library(fields)
# Compute the lagged partitions for all 16 models
ARImats <- vector("list", length(models.out))
for (i in 1:length(models.out)) {
  ARImats[[i]] <- matrix(NA, nrow=tps, ncol=tps)
}

for(h in 1:length(models.out)){
	for(k in 1:tps){
		rho[[k]] <- salso(t(models.out[[h]]$Si[k,,]), loss="binder")
	}

	for(k in 1: tps){
		for(kk in 1: tps){
			ARImats[[h]][k,kk] <- adjustedRandIndex(rho[[k]], rho[[kk]])
		}
	}
}

pch=as.character(1:nrow(y))
```

# figure 5
```{r}
#
# This is Figure 5 in the paper.  Includes lagged ARI plots for models that include time only (no space)
#
ord2 <- c(8,6,4,2,7,5,3,1)

# pdf(paste0("LaggedARI_NoSpace2.pdf"), height=7, width=13)

	par(mfrow=c(2,4),mar=c(2,2,2,2), mgp=c(1.5,0.5,0))
	for(h in ord2){
		m.n <- as.numeric(do.call(c, strsplit(strsplit(names(models.out)[h], "t|\\_")[[1]][c(2,3)], "")))
		header <- bquote(eta[1]*.(ifelse(m.n[1]==1,"-Yes","-No"))*","~
	    	             phi[1]*.(ifelse(m.n[2]==1,"-Yes","-No"))*","~
	        	         alpha[t]*.(ifelse(m.n[3]==1,"-Yes","-No")))
		image.plot(ARImats[[h]], main=header, zlim=range(do.call(c,ARImats),na.rm=TRUE), axes=FALSE)
		mtext(text=c(paste("",1:tps)), side=2, line=0.3, at=seq(0,1,length=12), las=1, cex=0.8)
		mtext(text=c(paste("",1:tps)), side=1, line=0.3, at=seq(0,1,length=12), las=2, cex=0.8)
	}
# dev.off()
```


```{r}
#  This plot is Figure 6 in the paper.
#  In includes estimated partitions over time for four models.
#
#  temperal dependence in data model 1-Yes, 0-No (eta parameters)
#  temperal dependence in atoms 1-Yes, 0-No (phi1 parameter)
#  temperal dependence in partition 1-Yes, 0-No (alpha parameter)
#
#  spatial dependence in partition
#
# In the plot I include the following models
# 000_0, 001_0, 110_0, 111_0
# pdf("PartitionsOverTime3.pdf", height=15, width=15)
    par(mfrow=c(2,2))
    for(kkk in c(8,7, 2, 1)){

      rho <- list()
      ccprob <- list()

      for(k in 1:tps){
	      rho[[k]] <- salso(t(models.out[[kkk]]$Si[k,,]), loss="binder")
      }

      m.n <- as.numeric(do.call(c, strsplit(strsplit(names(models.out)[kkk], "t|\\_")[[1]][c(2,3)], "")))
      header <- bquote(eta[1]*.(ifelse(m.n[1]==1,"-Yes","-No"))*","~
	    	       phi[1]*.(ifelse(m.n[2]==1,"-Yes","-No"))*","~
	        	   alpha[t]*.(ifelse(m.n[3]==1,"-Yes","-No")))

      plot(rep(1:12, each=nrow(y)), rep(1:60, times=ncol(y)), type='n',
           yaxt="n",ylab="", xlab="time", main=header, cex.main=2, cex.lab=1.75,
           xaxt="n")
      axis(side=1, at=1:12, cex.axis=1.5)
      for(jj in 1:ncol(y)){
        ord <- order(rho[[jj]])
        cex1 <- rep(0.8,length(ord))
        text(rep(jj, each=nrow(y)), 1:60, labels=pch[ord], col=rho[[jj]][ord], cex=cex1[ord])
        if(jj>1)text(jj-0.5, 61, bquote(alpha[.(jj)]==.(amn[kkk,jj])), cex=0.85)
      }
    }

# dev.off()
```

# figure 7
```{r}
###########################################
#
# Analysis with space in the partition model
#
#
# This is Figure 7 in the paper.  Lagged-ARI plots for models that include space in the partition
#
ord2 <- c(16,14,12,10,15,13,11,9)

# pdf(paste0("LaggedARI_OnlySpace2.pdf"), height=7, width=13)

	par(mfrow=c(2,4),mar=c(2,2,2,2), mgp=c(1.5,0.5,0))
	for(h in ord2){
		m.n <- as.numeric(do.call(c, strsplit(strsplit(names(models.out)[h], "t|\\_")[[1]][c(2,3)], "")))
		header <- bquote(eta[1]*.(ifelse(m.n[1]==1,"-Yes","-No"))*","~
	    	             phi[1]*.(ifelse(m.n[2]==1,"-Yes","-No"))*","~
	        	         alpha[t]*.(ifelse(m.n[3]==1,"-Yes","-No")))
		image.plot(ARImats[[h]], main=header, zlim=range(do.call(c,ARImats),na.rm=TRUE), axes=FALSE)
		mtext(text=c(paste("",1:tps)), side=2, line=0.3, at=seq(0,1,length=12), las=1, cex=0.8)
		mtext(text=c(paste("",1:tps)), side=1, line=0.3, at=seq(0,1,length=12), las=2, cex=0.8)
	}
# dev.off()
```


```{r}
# This is Figure 8 in the paper.
# It shows spatially refrenced estimated partitions for model 9 (i.e., 111 1 everything turned on)
# which fits data the best.
#
# There are more clusters with sPPM and so I need to create a color vector so that color doesn't
# get replicated and it is easy to identify the clusters

colors <- c("black","red","green","blue","cyan","purple","yellow","gray",
            "orange","maroon", "lavender", "magenta","turquoise")

rho <- list()

for(k in 1:tps){
	rho[[k]] <- salso(t(models.out[[9]]$Si[k,,]), loss="binder")
}
adj.rand <- matrix(NA,nrow=tps, ncol=tps)
for(k in 1:tps){
	for(kk in 1:tps){
		adj.rand[k,kk] <- adjustedRandIndex(rho[[k]], rho[[kk]])
	}
}

# pdf(paste0("PM10_", 111,"_",1,"_",model,"_SC",sp,"4.pdf"), height=12, width=9)

	par(mfrow=c(4,3),mar=c(3,3,2,1), mgp=c(1.5,0.5,0))

	for(jj in 1:tps){
      cex1 <- ((y[,jj]-mean(y[,jj]))/sd(y[,jj])+3)/3
      plot(s_coords, col=rho[[jj]], pch=pchs[rho[[jj]]],cex=cex1,
				main=bquote(Time~period ~ .(jj)*"," ~~ alpha==.(amn[9,jj])),
				ylab="", xlab="", yaxt="n", xaxt="n", type='n')

      text(s_coords[,], labels=pch, col=colors[rho[[jj]]], cex=cex1[])
	}

# dev.off()
```


```{r}
#######################################################################
#######################################################################
#
# Table of all adjusted rand index values.  Not included in the paper
#
xtable(round(adj.rand,2))


#
# Plot of adjusted rand index values, along with posterior means of alpha, and overall data values
# This plot was not included in the paper.
#
# pdf("LaggedARIvalues.pdf",height=11, width=9)
	par(mfrow=c(4,3))
	plot(mn, type='n', xlab="Month", ylab="PM10", main="PM10 for each station",
			ylim=range(t(t(y) + mn)))
	for(k in 1:nrow(y)){
		lines(t(t(y) + mn)[k,], type='b' )
	}
	plot(amn[9,], type='b', xlab="Month", ylab=expression(E(alpha[t]*'|'*Y)), main=expression("Posterior mean of" ~ alpha[t]))
	for(k in 1:(tps-2)){
		plot(adj.rand[k,((k+1):tps)], col=1, type='b', xlab="Lagged Month", ylab="Adjusted Rand Index",
#			main= bquote(ARI(hat(rho)[.(k)],.)))
			main= bquote("Lagged ARI values for" ~ hat(rho)[.(k)]))
	}
# dev.off()
```


```{r}
#
# This plot is not included in the Final draft of the paper
#
# pdf("MeanAlphaPM10.pdf",height=5, width=7)
	par(mfrow=c(2,1))
	plot(mn, type='b', xlab="Month", ylab="PM10")
	plot(amn[9,], type='b', xlab="Month", ylab=expression(E(alpha[t]*'|'*Y)))
# dev.off()


#
# All lagged plots in one figure.  This plot didn't make it into the final draft of the paper.
#
ord <- c(8,6,4,2,7,5,3,1,16,14,12,10,15,13,11,9)

# pdf(paste0("LaggedARI.pdf"), height=10, width=10)

	par(mfrow=c(4,4),mar=c(2,2,2,2), mgp=c(1.5,0.5,0))
	for(h in ord){
		m.n <- as.numeric(do.call(c, strsplit(strsplit(names(models.out)[h], "t|\\_")[[1]][c(2,3)], "")))
		header <- bquote(eta[1]*.(ifelse(m.n[1]==1,"-Yes","-No"))*","~
	    	             phi[1]*.(ifelse(m.n[2]==1,"-Yes","-No"))*","~
	        	         alpha[t]*.(ifelse(m.n[3]==1,"-Yes","-No"))*","~
	            	     "space"*.(ifelse(m.n[4]==1,"-Yes","-No")))
		image.plot(ARImats[[h]], main=header, zlim=range(do.call(c,ARImats),na.rm=TRUE), axes=FALSE)
		mtext(text=c(paste("",1:tps)), side=2, line=0.3, at=seq(0,1,length=12), las=1, cex=0.8)
		mtext(text=c(paste("",1:tps)), side=1, line=0.3, at=seq(0,1,length=12), las=2, cex=0.8)
	}
# dev.off()




```

